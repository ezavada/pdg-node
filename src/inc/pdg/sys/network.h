// -----------------------------------------------
// network.h
// 
// network manager functionality
//
// Written by Ed Zavada, 2004-2012
// Copyright (c) 2012, Dream Rock Studios, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// -----------------------------------------------


#ifndef PDG_NETWORK_H_INCLUDED
#define PDG_NETWORK_H_INCLUDED

#include "pdg_project.h"

#include "pdg/sys/platform.h"

#include "pdg/sys/global_types.h"
#include "pdg/sys/singleton.h"
#include "pdg/sys/eventemitter.h"


//! \defgroup Network
//! Collection of classes, types and constants that are used for networking

namespace pdg {

// -----------------------------------------------------------------------------------
// Network Event Data
// used for sending network messages and starting up connections
// -----------------------------------------------------------------------------------

//! connection is now valid for data transfer
//! \ingroup Network
//! \ingroup Events
struct NetConnect {
    long        id;       // id number for the connection
    void*       context;  // the context passed in when the connection was created
    const char* name;     // name of the connection, must copy if you want to preserve it
    bool        incoming; // if true this is a client connecting to a server port & context is the server port's context
};

//! nothing further can be done with that connection
//! \ingroup Network
//! \ingroup Events
struct NetDisconnect {
    long        id;         // id number for the connection, or -portNum if this was a listening port
    void*       context;    // the context passed in when the connection was created
};

//! got data
//! \ingroup Network
//! \ingroup Events
struct NetData {
    long        id;       // id number for the connection
    void*       context;  // the context passed in when the connection was created
    long        dataLen;  // length of data in ptr
    const char* dataPtr;  // must call NetworkManager::releaseNetData() to free this
    ms_time     arrivalMs;  // millisecond timestamp when received. Compare to OS::getMilliseconds() to see how long packet sat in a queue
};

//! got an error from network layer, not necessarily fatal
//! will be followed by NetDisconnect if this was a fatal error
//! \ingroup Network
//! \ingroup Events
struct NetError {
    long        id;         // id number for the connection that had the error. Listening ports are returned with -portNum as id
    void*       context;    // the context passed in when the connection was created
    long        error;      // an error code
};


typedef bool (*GatekeeperFunc) (NetData* ndptr, void* gateContext);


// -----------------------------------------------------------------------------------
//! NetworkManager
//! used for sending network messages and starting up connections
//! \ingroup Network
// -----------------------------------------------------------------------------------

class NetworkManager : public EventEmitter, public Singleton<NetworkManager> {
friend class Singleton<NetworkManager>;
public:

    // errors that can be generated by the Network Manager
    // other error codes can still be generated by the OS
    // or low level networking code, and will usually be passed
    // on as is
    enum {
        error_BadPacket      = -1,
        error_OversizePacket = -2,
        error_OutOfMemory    = -3
    };
    
    // connection flags for opening a connection or a server port
    enum {
        flag_PublicPort   = 1 << 0, // port is publicly advertised -- server port only
        flag_UDPOnly      = 1 << 1, // udp only
        flag_TCPOnly      = 1 << 2, // reliable connection only
        flag_NoFraming    = 1 << 3, // no low level framing, raw connection only
        flag_NoHandshake  = 1 << 4, // don't do any connection handshake
        
        flag_RawUDP       = flag_NoFraming + flag_NoHandshake + flag_UDPOnly,
        flag_RawTCP       = flag_NoFraming + flag_NoHandshake + flag_TCPOnly
    };
    
    // Start opening a connection to a remote endpoint.
    //
    // Once the connection is established an eventType_NetConnect event will
    // be generated. Until NetConnect is received, there is no way to interact
    // with this connection, since the NetConnect provides the id used in all
    // the calls. Also, no events other than NetError will be generated for this 
    // connection until NetConnect is received.
    // If the connection fails to be established, an eventType_NetError event 
    // with connection id zero (0) will be generated
    // See the flags enumeration above for details on what the flags mean
    virtual void    openConnection(const char* destination, void* userContext = 0,
                                    unsigned char connectFlags = 0) = 0;
    
    // close a connection, with an optional error code, clean close if error = 0
    // Once the connection has closed, an eventType_NetDisconnect will be generated
    // After receipt of NetDisconnect, no further events for this connection id
    // will be received and any calls using the connection id will be ignored or
    // generate errors
    virtual void    closeConnection(long id, int error = 0) = 0;

    // send data on a particular established connection
    virtual void    sendData(long id, void* data, long dataLen) = 0;

    // send data to all established connections
	virtual void    broadcastData(void* data, long datalen) = 0;

    // free the received data when you are done using it
    // you must call this when you get an eventType_NetData after you have
    // finished with the data
    virtual void    releaseNetData(NetData* data) = 0;
    
    // set user context data for a connection
    // typically you would do this when you get a NetConnect event for an incoming connection
    // at a server port, so you can give the connection its own context
    virtual void    setConnectionContext(long id, void* userContext) = 0;
    
    // set maximum size of a packet we are allowed to receive on the connection
    // this is necessary to prevent a hacker from sending unreasonably large
    // packet to exhaust the memory of a server and make it crash
    // this value is 1024 (1k) if setMaxIncomingPacketSize is not called to make
    // it larger. This is per connection, not global
    virtual void    setMaxIncomingPacketSize(long id, long maxLen) = 0;

    // Open a listening connection on a particular port that 
    // waits for incoming connections
    //
    // Whenever a new connection to the server is established, an eventType_NetConnect 
    // event will be generated, which provides the id for the newly established
    // connection. 
    // If the listening port cannot be established, an eventType_NetError event 
    // with connection id of the negative of the port number will be generated
    // See the flags enumeration above for details on what the flags mean
    virtual void    createServerPort(short portNum, void* userContext = 0, 
                                    unsigned char connectFlags = flag_PublicPort) = 0;

    // close a particular listening port
    // no event is produced, the system simply stops listening for incoming connections
    // on that port
    virtual void    closeServerPort(short portNum) = 0;

    // give time to the network layer to do anything it may need to do, such as
    // sending queued packets or pings
    virtual void    idle() = 0;

    // for a server, sets the name and connection creator (arbitrary long) that are
    // advertised. Any Server Ports created after this call will use the information
    // as given. call setPublicInfo(0, 0) for defaults.
    virtual void    setPublicInfo(long connectionCreator, const char* publicName) = 0;


	// These are the packet gatekeeper functions that control whether an incoming packet 
	// can be allowed to be processed in the current game state.  Application code
	// should register a GatekeeperFunc function that evaluates the current game state
	// and returns true if it's ready for packet processing to continue or false if
	// not.
	// If the gatekeeper returns false, then ALL incoming packet processing will be halted
	// and on every idle call the gatekeeper will invoked to see if the packet processing
	// can be resumed. Packets will accumulate on the client, so the server won't see
	// this as a block in communications. 
	// This has no impact on outgoing packets.
	// The context passed into addIncomingPacketGatekeeper() will be passed in each time
	// that the gatekeeper function is invoked
	// The gatekeepers will be invoked for all connections, it must distinguish whether
	// it is a connect it cares about by looking at the connection id in the NetData
	// pointer passed into the gatekeeper
	virtual void	addIncomingPacketGatekeeper(GatekeeperFunc func, void* context) = 0;
	
	// stop using a particular packet gatekeepr
	virtual void	removeIncomingPacketGatekeeper(GatekeeperFunc func) = 0;
	
	
	// These functions block user input while waiting for a network transaction
	// to complete. Generally this would be used by calling waitingForNetwork()
	// when you send a packet that *requires* a response, and when that response 
	// is received you call doneWaitingForNetwork. In cases were PDG_NO_GUI is
	// defined for the build, this does little more than track the flag.

	// Put up a network busy cursor and stop accepting user input
	// This will log a warning if you were already waiting for the network, since
	// there is no reference counting, so the first call to doneWaiting will
	// clear the waiting state.
	virtual void    waitingForNetwork() = 0;
	
	// clear the network busy cursor and allow user input
	virtual void    doneWaitingForNetwork() = 0;
	
	// returns true if user input is blocked waiting on completion of a network 
	// transaction, false if not
	virtual bool    isWaitingForNetwork() = 0;
	
	
// lifecycle
/// @cond C++
    virtual ~NetworkManager();
/// @endcond

protected:
/// @cond INTERNAL
	static NetworkManager* createSingletonInstance();
	NetworkManager() {} // call NetworkManager::getSingletonInstance() instead
/// @endcond

};

} // end namespace pdg

#endif // PDG_NETWORK_H_INCLUDED

