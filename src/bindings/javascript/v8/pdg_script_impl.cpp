// -----------------------------------------------
// This file automatically generated from:
//
//    work/pdg/src/bindings/common/pdg_script_impl.cpp
//    work/pdg/src/bindings/javascript/v8/pdg_script_macros.h
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// -----------------------------------------------



#include "pdg_project.h"

#define PDG_COMPILING_SCRIPT_IMPL

#include "pdg_script_impl.h"
#include "pdg_script_interface.h"

#include "internals.h"
#include "pdg-lib.h"

#include <sstream>
#include <cmath>
#include <cstdlib>

#ifndef PDG_DEBUG_SCRIPTING

#define SCRIPT_DEBUG_ONLY(_expression)
#else
#define SCRIPT_DEBUG_ONLY DEBUG_ONLY
#endif

namespace pdg
{

    bool s_HaveSavedError = false;

    bool s_MemBlock_InNewFromCpp = false;

    void MemBlockWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        MemBlockWrap* objWrapper = new MemBlockWrap(args);
        objWrapper->Wrap(args.This());
        MemBlock* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mMemBlockScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> MemBlockWrap::NewFromCpp(v8::Isolate* isolate, MemBlock* cppObj)
    {
        s_MemBlock_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(instance);

        cppObj->mMemBlockScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_MemBlock_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> MemBlockWrap::constructorTpl_;

    void MemBlockWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "MemBlock", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetData_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetData_Tpl =
            v8::FunctionTemplate::New(isolate, GetData, v8::Local<v8::Value>(), GetData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getData", v8::String::kInternalizedString), GetData_Tpl);
        v8::Local<v8::Signature> GetDataSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDataSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetDataSize, v8::Local<v8::Value>(), GetDataSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getDataSize", v8::String::kInternalizedString), GetDataSize_Tpl);
        v8::Local<v8::Signature> GetByte_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetByte_Tpl =
            v8::FunctionTemplate::New(isolate, GetByte, v8::Local<v8::Value>(), GetByte_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getByte", v8::String::kInternalizedString), GetByte_Tpl);
        v8::Local<v8::Signature> GetBytes_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetBytes_Tpl =
            v8::FunctionTemplate::New(isolate, GetBytes, v8::Local<v8::Value>(), GetBytes_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getBytes", v8::String::kInternalizedString), GetBytes_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "MemBlock", v8::String::kInternalizedString), t->GetFunction());

    }

    void MemBlockWrap::GetData(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[string Binary]" " function" "()" " - " "") ); return; };
        }
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        v8::Local<v8::Value> resultVal = EncodeBinary(self->ptr, self->bytes);
        { args.GetReturnValue().Set( resultVal ); return; };
    }

    void MemBlockWrap::GetDataSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        }
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, self->bytes) ); return; };
    }

    void MemBlockWrap::GetByte(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([number uint] i)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""i"")");
        unsigned long i = args[1 -1]->Uint32Value();
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, self->ptr[i]) ); return; };
    }

    void MemBlockWrap::GetBytes(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[string Binary]" " function" "([number uint] start, [number uint] len)" " - " "") ); return; };
        }
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""start"")");
        unsigned long start = args[1 -1]->Uint32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""len"")");
        unsigned long len = args[2 -1]->Uint32Value();
        v8::Local<v8::Value> resultVal = EncodeBinary(self->ptr + start, len);
        { args.GetReturnValue().Set( resultVal ); return; };
    }

    void CleanupMemBlockScriptObject(v8::Persistent<v8::Object> &obj) { }

    MemBlock* New_MemBlock(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_MemBlock_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new MemBlock(0, 0, false);
    }

    static bool s_ConfigManager_InNewFromCpp = false;

    void ConfigManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = new ConfigManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> ConfigManagerWrap::instance_;
    bool ConfigManagerWrap::instanced_ = false;

    v8::Local<v8::Object> ConfigManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    ConfigManager* ConfigManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(val);
        return dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> ConfigManagerWrap::constructorTpl_;

    void ConfigManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ConfigManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> UseConfig_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UseConfig_Tpl =
            v8::FunctionTemplate::New(isolate, UseConfig, v8::Local<v8::Value>(), UseConfig_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "useConfig", v8::String::kInternalizedString), UseConfig_Tpl);
        v8::Local<v8::Signature> GetConfigString_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetConfigString_Tpl =
            v8::FunctionTemplate::New(isolate, GetConfigString, v8::Local<v8::Value>(), GetConfigString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getConfigString", v8::String::kInternalizedString), GetConfigString_Tpl);
        v8::Local<v8::Signature> GetConfigLong_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetConfigLong_Tpl =
            v8::FunctionTemplate::New(isolate, GetConfigLong, v8::Local<v8::Value>(), GetConfigLong_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getConfigLong", v8::String::kInternalizedString), GetConfigLong_Tpl);
        v8::Local<v8::Signature> GetConfigFloat_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetConfigFloat_Tpl =
            v8::FunctionTemplate::New(isolate, GetConfigFloat, v8::Local<v8::Value>(), GetConfigFloat_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getConfigFloat", v8::String::kInternalizedString), GetConfigFloat_Tpl);
        v8::Local<v8::Signature> GetConfigBool_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetConfigBool_Tpl =
            v8::FunctionTemplate::New(isolate, GetConfigBool, v8::Local<v8::Value>(), GetConfigBool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getConfigBool", v8::String::kInternalizedString), GetConfigBool_Tpl);
        v8::Local<v8::Signature> SetConfigString_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetConfigString_Tpl =
            v8::FunctionTemplate::New(isolate, SetConfigString, v8::Local<v8::Value>(), SetConfigString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setConfigString", v8::String::kInternalizedString), SetConfigString_Tpl);
        v8::Local<v8::Signature> SetConfigLong_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetConfigLong_Tpl =
            v8::FunctionTemplate::New(isolate, SetConfigLong, v8::Local<v8::Value>(), SetConfigLong_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setConfigLong", v8::String::kInternalizedString), SetConfigLong_Tpl);
        v8::Local<v8::Signature> SetConfigFloat_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetConfigFloat_Tpl =
            v8::FunctionTemplate::New(isolate, SetConfigFloat, v8::Local<v8::Value>(), SetConfigFloat_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setConfigFloat", v8::String::kInternalizedString), SetConfigFloat_Tpl);
        v8::Local<v8::Signature> SetConfigBool_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetConfigBool_Tpl =
            v8::FunctionTemplate::New(isolate, SetConfigBool, v8::Local<v8::Value>(), SetConfigBool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setConfigBool", v8::String::kInternalizedString), SetConfigBool_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "ConfigManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void ConfigManagerWrap::UseConfig(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "(string inConfigName)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigName"")");
        v8::String::Utf8Value inConfigName_Str(args[1 -1]->ToString());
        const char* inConfigName = *inConfigName_Str;;
        bool result = self->useConfig(inConfigName);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void ConfigManagerWrap::GetConfigString(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "(string inConfigItemName)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        std::string outVal;
        bool found = self->getConfigString(inConfigItemName, outVal);
        if (found)
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, outVal.c_str()) ); return; };
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
    }

    void ConfigManagerWrap::GetConfigLong(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(string inConfigItemName)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        long outVal;
        bool found = self->getConfigLong(inConfigItemName, outVal);
        if (found)
        {
            { args.GetReturnValue().Set( v8::Integer::New(isolate, outVal) ); return; };
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
    }

    void ConfigManagerWrap::GetConfigFloat(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(string inConfigItemName)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        float outVal;
        bool found = self->getConfigFloat(inConfigItemName, outVal);
        if (found)
        {
            { args.GetReturnValue().Set( v8::Number::New(isolate, outVal) ); return; };
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
    }

    void ConfigManagerWrap::GetConfigBool(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "(string inConfigItemName)" " - " "") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        bool outVal;
        bool found = self->getConfigBool(inConfigItemName, outVal);
        if (found)
        {
            { args.GetReturnValue().Set( v8::Boolean::New(isolate, outVal) ); return; };
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
    }

    void ConfigManagerWrap::SetConfigString(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string inConfigItemName, string inValue)" " - " "") ); return; };
        }
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 2, "a string  (""inValue"")");
        v8::String::Utf8Value inValue_Str(args[2 -1]->ToString());
        const char* inValue = *inValue_Str;;
        std::string theString(inValue);
        self->setConfigString(inConfigItemName, theString);
        args.GetReturnValue().SetUndefined();
    }

    void ConfigManagerWrap::SetConfigLong(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string inConfigItemName, [number int] inValue)" " - " "") ); return; };
        }
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inValue"")");
        long inValue = args[2 -1]->Int32Value();
        self->setConfigLong(inConfigItemName, inValue);
        args.GetReturnValue().SetUndefined();
    }

    void ConfigManagerWrap::SetConfigFloat(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string inConfigItemName, number inValue)" " - " "") ); return; };
        }
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inValue"")");
        double inValue = args[2 -1]->NumberValue();
        self->setConfigFloat(inConfigItemName, inValue);
        args.GetReturnValue().SetUndefined();
    }

    void ConfigManagerWrap::SetConfigBool(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string inConfigItemName, boolean inValue)" " - " "") ); return; };
        }
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 2, "a boolean (""inValue"")");
        bool inValue = args[2 -1]->BooleanValue();
        self->setConfigBool(inConfigItemName, inValue);
        args.GetReturnValue().SetUndefined();
    }

    ConfigManager* New_ConfigManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_ConfigManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return ConfigManager::getSingletonInstance();
    }

    static bool s_LogManager_InNewFromCpp = false;

    void LogManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        LogManagerWrap* objWrapper = new LogManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> LogManagerWrap::instance_;
    bool LogManagerWrap::instanced_ = false;

    v8::Local<v8::Object> LogManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    LogManager* LogManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(val);
        return dynamic_cast<LogManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> LogManagerWrap::constructorTpl_;

    void LogManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "LogManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        t->InstanceTemplate()->Set(v8::String::NewFromUtf8(isolate, "init_CreateUniqueNewFile", v8::String::kInternalizedString), v8::Integer::New(isolate, pdg::LogManager::init_CreateUniqueNewFile), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewFromUtf8(isolate, "init_OverwriteExisting", v8::String::kInternalizedString), v8::Integer::New(isolate, pdg::LogManager::init_OverwriteExisting), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewFromUtf8(isolate, "init_AppendToExisting", v8::String::kInternalizedString), v8::Integer::New(isolate, pdg::LogManager::init_AppendToExisting), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewFromUtf8(isolate, "init_StdOut", v8::String::kInternalizedString), v8::Integer::New(isolate, pdg::LogManager::init_StdOut), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewFromUtf8(isolate, "init_StdErr", v8::String::kInternalizedString), v8::Integer::New(isolate, pdg::LogManager::init_StdErr), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        v8::Local<v8::Signature> GetLogLevel_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLogLevel_Tpl =
            v8::FunctionTemplate::New(isolate, GetLogLevel, v8::Local<v8::Value>(), GetLogLevel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""LogLevel", v8::String::kInternalizedString), GetLogLevel_Tpl);
        v8::Local<v8::Signature> SetLogLevel_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLogLevel_Tpl =
            v8::FunctionTemplate::New(isolate, SetLogLevel, v8::Local<v8::Value>(), SetLogLevel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""LogLevel", v8::String::kInternalizedString), SetLogLevel_Tpl);
        v8::Local<v8::Signature> Initialize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Initialize_Tpl =
            v8::FunctionTemplate::New(isolate, Initialize, v8::Local<v8::Value>(), Initialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "initialize", v8::String::kInternalizedString), Initialize_Tpl);
        v8::Local<v8::Signature> WriteLogEntry_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> WriteLogEntry_Tpl =
            v8::FunctionTemplate::New(isolate, WriteLogEntry, v8::Local<v8::Value>(), WriteLogEntry_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "writeLogEntry", v8::String::kInternalizedString), WriteLogEntry_Tpl);
        v8::Local<v8::Signature> BinaryDump_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BinaryDump_Tpl =
            v8::FunctionTemplate::New(isolate, BinaryDump, v8::Local<v8::Value>(), BinaryDump_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "binaryDump", v8::String::kInternalizedString), BinaryDump_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "LogManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void LogManagerWrap::GetLogLevel(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int32 theLogLevel = self->getLogLevel();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theLogLevel) ); return; };
    }

    void LogManagerWrap::SetLogLevel(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object LogManager]" " function" "([number int] inLogLevel)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theLogLevel"")");
        long theLogLevel = args[1 -1]->Int32Value();

        self->setLogLevel(theLogLevel);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void LogManagerWrap::Initialize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string inLogNameBase, [number int] initMode = LogManager.init_StdOut)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inLogNameBase"")");
        v8::String::Utf8Value inLogNameBase_Str(args[1 -1]->ToString());
        const char* inLogNameBase = *inLogNameBase_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""initMode"")");
        long initMode = (args.Length()<2) ? pdg::LogManager::init_StdOut : args[2 -1]->Int32Value();;
        self->initialize(inLogNameBase, initMode);
        args.GetReturnValue().SetUndefined();
    }

    void LogManagerWrap::WriteLogEntry(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] level, string category, string message)" " - " "") ); return; };
        };
        if (args.Length() != 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""level"")");
        long level = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 2, "a string  (""category"")");
        v8::String::Utf8Value category_Str(args[2 -1]->ToString());
        const char* category = *category_Str;;
        if (!args[3 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 3, "a string  (""message"")");
        v8::String::Utf8Value message_Str(args[3 -1]->ToString());
        const char* message = *message_Str;;
        self->writeLogEntry(level, category, message);
        args.GetReturnValue().SetUndefined();
    }
    void LogManagerWrap::BinaryDump(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "({[string Binary]|[object MemBlock]} inData, [number int] length = 0, [number int] bytesPerLine = 20)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""length"")");
        long length = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""bytesPerLine"")");
        long bytesPerLine = (args.Length()<3) ? 20 : args[3 -1]->Int32Value();;
        int dataSize = 0;
        char* inData = 0;
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            inData = (char*)ptr;
            dataSize = (length == 0) ? bytes : length;
        }
        else
        {
            REQUIRE_CPP_OBJECT_ARG(1, memBlock, MemBlock);
            inData = memBlock->ptr;
            dataSize = (length == 0) ? memBlock->bytes : length;
        }
        int outBufSize = (4 * dataSize) + (6 * dataSize/bytesPerLine) + (4 * bytesPerLine) + 32;
        char* outBuf = new char[outBufSize];
        OS::binaryDump(outBuf, outBufSize, inData, dataSize, bytesPerLine);
        v8::Local<v8::Value> dumpStrVal = v8::String::NewFromUtf8(isolate, outBuf);
        delete outBuf;
        { args.GetReturnValue().Set( dumpStrVal ); return; };
    }

    log& main_getDebugLog();

    LogManager* New_LogManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_LogManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        LogManager *theLogMgr = LogManager::getSingletonInstance();
        pdg::log& debugLog = main_getDebugLog();
        debugLog.setLogManager(theLogMgr);
        return theLogMgr;
    }

    bool s_IEventHandler_InNewFromCpp = false;

    void IEventHandlerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        IEventHandlerWrap* objWrapper = new IEventHandlerWrap(args);
        objWrapper->Wrap(args.This());
        IEventHandler* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mIEventHandlerScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> IEventHandlerWrap::NewFromCpp(v8::Isolate* isolate, IEventHandler* cppObj)
    {
        s_IEventHandler_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        IEventHandlerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(instance);

        cppObj->mIEventHandlerScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_IEventHandler_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> IEventHandlerWrap::constructorTpl_;

    void IEventHandlerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "IEventHandler", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        target->Set(v8::String::NewFromUtf8(isolate, "IEventHandler", v8::String::kInternalizedString), t->GetFunction());
    }

    void CleanupIEventHandlerScriptObject(v8::Persistent<v8::Object> &obj) { }

    bool s_EventEmitter_InNewFromCpp = false;

    void EventEmitterWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = new EventEmitterWrap(args);
        objWrapper->Wrap(args.This());
        EventEmitter* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mEventEmitterScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> EventEmitterWrap::NewFromCpp(v8::Isolate* isolate, EventEmitter* cppObj)
    {
        s_EventEmitter_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(instance);

        cppObj->mEventEmitterScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_EventEmitter_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> EventEmitterWrap::constructorTpl_;

    void EventEmitterWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "EventEmitter", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "EventEmitter", v8::String::kInternalizedString), t->GetFunction());

    }

    void EventEmitterWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 366 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 366 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 366 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 366 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 366 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void EventEmitterWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void EventEmitterWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void EventEmitterWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void EventEmitterWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    EventEmitter* New_EventEmitter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_EventEmitter_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new EventEmitter();
    }

    static bool s_EventManager_InNewFromCpp = false;

    void EventManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = new EventManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> EventManagerWrap::instance_;
    bool EventManagerWrap::instanced_ = false;

    v8::Local<v8::Object> EventManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    EventManager* EventManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(val);
        return dynamic_cast<EventManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> EventManagerWrap::constructorTpl_;

    void EventManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "EventManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> IsKeyDown_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsKeyDown_Tpl =
            v8::FunctionTemplate::New(isolate, IsKeyDown, v8::Local<v8::Value>(), IsKeyDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isKeyDown", v8::String::kInternalizedString), IsKeyDown_Tpl);
        v8::Local<v8::Signature> IsRawKeyDown_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsRawKeyDown_Tpl =
            v8::FunctionTemplate::New(isolate, IsRawKeyDown, v8::Local<v8::Value>(), IsRawKeyDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isRawKeyDown", v8::String::kInternalizedString), IsRawKeyDown_Tpl);
        v8::Local<v8::Signature> IsButtonDown_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsButtonDown_Tpl =
            v8::FunctionTemplate::New(isolate, IsButtonDown, v8::Local<v8::Value>(), IsButtonDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isButtonDown", v8::String::kInternalizedString), IsButtonDown_Tpl);
        v8::Local<v8::Signature> GetDeviceOrientation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDeviceOrientation_Tpl =
            v8::FunctionTemplate::New(isolate, GetDeviceOrientation, v8::Local<v8::Value>(), GetDeviceOrientation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getDeviceOrientation", v8::String::kInternalizedString), GetDeviceOrientation_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "EventManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void EventManagerWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 388 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 388 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 388 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 388 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 388 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void EventManagerWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void EventManagerWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void EventManagerWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void EventManagerWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }
    void EventManagerWrap::IsRawKeyDown(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([number int] keyCode)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""keyCode"")");
        long keyCode = args[1 -1]->Int32Value();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, OS::isRawKeyDown(keyCode)) ); return; };
    }
    void EventManagerWrap::IsButtonDown(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([number int] buttonNumber = 0)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""buttonNumber"")");
        long buttonNumber = (args.Length()<1) ? 0 : args[1 -1]->Int32Value();;
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, OS::isButtonDown(buttonNumber)) ); return; };
    }

    EventManager* New_EventManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_EventManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return EventManager::getSingletonInstance();
    }

    static bool s_ResourceManager_InNewFromCpp = false;

    void ResourceManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = new ResourceManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> ResourceManagerWrap::instance_;
    bool ResourceManagerWrap::instanced_ = false;

    v8::Local<v8::Object> ResourceManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    ResourceManager* ResourceManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(val);
        return dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> ResourceManagerWrap::constructorTpl_;

    void ResourceManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ResourceManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetLanguage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLanguage_Tpl =
            v8::FunctionTemplate::New(isolate, GetLanguage, v8::Local<v8::Value>(), GetLanguage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Language", v8::String::kInternalizedString), GetLanguage_Tpl);
        v8::Local<v8::Signature> SetLanguage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLanguage_Tpl =
            v8::FunctionTemplate::New(isolate, SetLanguage, v8::Local<v8::Value>(), SetLanguage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Language", v8::String::kInternalizedString), SetLanguage_Tpl);
        v8::Local<v8::Signature> OpenResourceFile_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> OpenResourceFile_Tpl =
            v8::FunctionTemplate::New(isolate, OpenResourceFile, v8::Local<v8::Value>(), OpenResourceFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "openResourceFile", v8::String::kInternalizedString), OpenResourceFile_Tpl);
        v8::Local<v8::Signature> CloseResourceFile_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CloseResourceFile_Tpl =
            v8::FunctionTemplate::New(isolate, CloseResourceFile, v8::Local<v8::Value>(), CloseResourceFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "closeResourceFile", v8::String::kInternalizedString), CloseResourceFile_Tpl);
        v8::Local<v8::Signature> GetImage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetImage_Tpl =
            v8::FunctionTemplate::New(isolate, GetImage, v8::Local<v8::Value>(), GetImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getImage", v8::String::kInternalizedString), GetImage_Tpl);
        v8::Local<v8::Signature> GetImageStrip_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetImageStrip_Tpl =
            v8::FunctionTemplate::New(isolate, GetImageStrip, v8::Local<v8::Value>(), GetImageStrip_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getImageStrip", v8::String::kInternalizedString), GetImageStrip_Tpl);
        v8::Local<v8::Signature> GetString_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetString_Tpl =
            v8::FunctionTemplate::New(isolate, GetString, v8::Local<v8::Value>(), GetString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getString", v8::String::kInternalizedString), GetString_Tpl);
        v8::Local<v8::Signature> GetResourceSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetResourceSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetResourceSize, v8::Local<v8::Value>(), GetResourceSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getResourceSize", v8::String::kInternalizedString), GetResourceSize_Tpl);
        v8::Local<v8::Signature> GetResource_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetResource_Tpl =
            v8::FunctionTemplate::New(isolate, GetResource, v8::Local<v8::Value>(), GetResource_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getResource", v8::String::kInternalizedString), GetResource_Tpl);
        v8::Local<v8::Signature> GetResourcePaths_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetResourcePaths_Tpl =
            v8::FunctionTemplate::New(isolate, GetResourcePaths, v8::Local<v8::Value>(), GetResourcePaths_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getResourcePaths", v8::String::kInternalizedString), GetResourcePaths_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "ResourceManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void ResourceManagerWrap::GetLanguage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        const char* theLanguage = self->getLanguage();
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, theLanguage) ); return; };
    }

    void ResourceManagerWrap::SetLanguage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object ResourceManager]" " function" "(string inLanguage)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""theLanguage"")");
        v8::String::Utf8Value theLanguage_Str(args[1 -1]->ToString());
        const char* theLanguage = *theLanguage_Str;;

        self->setLanguage(theLanguage);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void ResourceManagerWrap::OpenResourceFile(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(string filename)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""filename"")");
        v8::String::Utf8Value filename_Str(args[1 -1]->ToString());
        const char* filename = *filename_Str;;
        int refNum = self->openResourceFile(filename);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, refNum) ); return; };
    }

    void ResourceManagerWrap::CloseResourceFile(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] refNum)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""refNum"")");
        long refNum = args[1 -1]->Int32Value();
        self->closeResourceFile(refNum);
        args.GetReturnValue().SetUndefined();
    }

    void ResourceManagerWrap::GetString(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "([number int] id, [number int] substring = -1)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""substring"")");
        long substring = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        std::string ioStr;
        const char* outStr = self->getString(ioStr, id, substring);
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, outStr) ); return; };
    }

    void ResourceManagerWrap::GetResourceSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(string resourceName)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""resourceName"")");
        v8::String::Utf8Value resourceName_Str(args[1 -1]->ToString());
        const char* resourceName = *resourceName_Str;;
        unsigned long resSize = self->getResourceSize(resourceName);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, resSize) ); return; };
    }

    void ResourceManagerWrap::GetResource(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[string Binary]" " function" "(string resourceName)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""resourceName"")");
        v8::String::Utf8Value resourceName_Str(args[1 -1]->ToString());
        const char* resourceName = *resourceName_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""maxSize"")");
        long maxSize = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        unsigned long bufferSize;
        if (maxSize < 0)
        {
            bufferSize = self->getResourceSize(resourceName);
        }
        else
        {
            bufferSize = maxSize;
        }
        uint8* buffer = (uint8*) std::malloc(bufferSize);
        bool loaded = self->getResource(resourceName, buffer, bufferSize);
        if (!loaded)
        {
            std::free(buffer);
            { args.GetReturnValue().Set( v8::Boolean::New(isolate, false) ); return; };
        }
        v8::Local<v8::Value> resultVal = EncodeBinary(buffer, bufferSize);
        std::free(buffer);
        { args.GetReturnValue().Set( resultVal ); return; };
    }

    void ResourceManagerWrap::GetResourcePaths(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        std::string outStr = self->getResourcePaths();
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, outStr.c_str()) ); return; };
    }

    ResourceManager* New_ResourceManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_ResourceManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return ResourceManager::getSingletonInstance();
    }

    bool s_ISerializable_InNewFromCpp = false;

    void ISerializableWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ISerializableWrap* objWrapper = new ISerializableWrap(args);
        objWrapper->Wrap(args.This());
        ISerializable* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mISerializableScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> ISerializableWrap::NewFromCpp(v8::Isolate* isolate, ISerializable* cppObj)
    {
        s_ISerializable_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        ISerializableWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISerializableWrap>(instance);

        cppObj->mISerializableScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_ISerializable_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> ISerializableWrap::constructorTpl_;

    void ISerializableWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ISerializable", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        target->Set(v8::String::NewFromUtf8(isolate, "ISerializable", v8::String::kInternalizedString), t->GetFunction());
    }

    void CleanupISerializableScriptObject(v8::Persistent<v8::Object> &obj) { }

    bool s_Serializer_InNewFromCpp = false;

    void SerializerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = new SerializerWrap(args);
        objWrapper->Wrap(args.This());
        Serializer* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mSerializerScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> SerializerWrap::NewFromCpp(v8::Isolate* isolate, Serializer* cppObj)
    {
        s_Serializer_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(instance);

        cppObj->mSerializerScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Serializer_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> SerializerWrap::constructorTpl_;

    void SerializerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Serializer", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
#ifndef PDG_NO_64BIT
        v8::Local<v8::Signature> Serialize_8_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_8_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_8, v8::Local<v8::Value>(), Serialize_8_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_8", v8::String::kInternalizedString), Serialize_8_Tpl);
        v8::Local<v8::Signature> Serialize_8u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_8u_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_8u, v8::Local<v8::Value>(), Serialize_8u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_8u", v8::String::kInternalizedString), Serialize_8u_Tpl);
        v8::Local<v8::Signature> Sizeof_8_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_8_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_8, v8::Local<v8::Value>(), Sizeof_8_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_8", v8::String::kInternalizedString), Sizeof_8_Tpl);
        v8::Local<v8::Signature> Sizeof_8u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_8u_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_8u, v8::Local<v8::Value>(), Sizeof_8u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_8u", v8::String::kInternalizedString), Sizeof_8u_Tpl);
#endif
        v8::Local<v8::Signature> Serialize_d_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_d_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_d, v8::Local<v8::Value>(), Serialize_d_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_d", v8::String::kInternalizedString), Serialize_d_Tpl);
        v8::Local<v8::Signature> Serialize_f_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_f_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_f, v8::Local<v8::Value>(), Serialize_f_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_f", v8::String::kInternalizedString), Serialize_f_Tpl);
        v8::Local<v8::Signature> Serialize_4_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_4_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_4, v8::Local<v8::Value>(), Serialize_4_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_4", v8::String::kInternalizedString), Serialize_4_Tpl);
        v8::Local<v8::Signature> Serialize_4u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_4u_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_4u, v8::Local<v8::Value>(), Serialize_4u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_4u", v8::String::kInternalizedString), Serialize_4u_Tpl);
        v8::Local<v8::Signature> Serialize_3u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_3u_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_3u, v8::Local<v8::Value>(), Serialize_3u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_3u", v8::String::kInternalizedString), Serialize_3u_Tpl);
        v8::Local<v8::Signature> Serialize_2_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_2_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_2, v8::Local<v8::Value>(), Serialize_2_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_2", v8::String::kInternalizedString), Serialize_2_Tpl);
        v8::Local<v8::Signature> Serialize_2u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_2u_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_2u, v8::Local<v8::Value>(), Serialize_2u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_2u", v8::String::kInternalizedString), Serialize_2u_Tpl);
        v8::Local<v8::Signature> Serialize_1_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_1_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_1, v8::Local<v8::Value>(), Serialize_1_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_1", v8::String::kInternalizedString), Serialize_1_Tpl);
        v8::Local<v8::Signature> Serialize_1u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_1u_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_1u, v8::Local<v8::Value>(), Serialize_1u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_1u", v8::String::kInternalizedString), Serialize_1u_Tpl);
        v8::Local<v8::Signature> Serialize_bool_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_bool_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_bool, v8::Local<v8::Value>(), Serialize_bool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_bool", v8::String::kInternalizedString), Serialize_bool_Tpl);
        v8::Local<v8::Signature> Serialize_uint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_uint_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_uint, v8::Local<v8::Value>(), Serialize_uint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_uint", v8::String::kInternalizedString), Serialize_uint_Tpl);
        v8::Local<v8::Signature> Serialize_color_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_color_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_color, v8::Local<v8::Value>(), Serialize_color_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_color", v8::String::kInternalizedString), Serialize_color_Tpl);
        v8::Local<v8::Signature> Serialize_offset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_offset_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_offset, v8::Local<v8::Value>(), Serialize_offset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_offset", v8::String::kInternalizedString), Serialize_offset_Tpl);
        v8::Local<v8::Signature> Serialize_point_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_point_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_point, v8::Local<v8::Value>(), Serialize_point_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_point", v8::String::kInternalizedString), Serialize_point_Tpl);
        v8::Local<v8::Signature> Serialize_vector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_vector_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_vector, v8::Local<v8::Value>(), Serialize_vector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_vector", v8::String::kInternalizedString), Serialize_vector_Tpl);
        v8::Local<v8::Signature> Serialize_rect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_rect_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_rect, v8::Local<v8::Value>(), Serialize_rect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_rect", v8::String::kInternalizedString), Serialize_rect_Tpl);
        v8::Local<v8::Signature> Serialize_rotr_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_rotr_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_rotr, v8::Local<v8::Value>(), Serialize_rotr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_rotr", v8::String::kInternalizedString), Serialize_rotr_Tpl);
        v8::Local<v8::Signature> Serialize_quad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_quad_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_quad, v8::Local<v8::Value>(), Serialize_quad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_quad", v8::String::kInternalizedString), Serialize_quad_Tpl);
        v8::Local<v8::Signature> Serialize_str_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_str_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_str, v8::Local<v8::Value>(), Serialize_str_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_str", v8::String::kInternalizedString), Serialize_str_Tpl);
        v8::Local<v8::Signature> Serialize_mem_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_mem_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_mem, v8::Local<v8::Value>(), Serialize_mem_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_mem", v8::String::kInternalizedString), Serialize_mem_Tpl);
        v8::Local<v8::Signature> Serialize_obj_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_obj_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_obj, v8::Local<v8::Value>(), Serialize_obj_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_obj", v8::String::kInternalizedString), Serialize_obj_Tpl);
        v8::Local<v8::Signature> Serialize_ref_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_ref_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize_ref, v8::Local<v8::Value>(), Serialize_ref_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize_ref", v8::String::kInternalizedString), Serialize_ref_Tpl);
        v8::Local<v8::Signature> Sizeof_d_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_d_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_d, v8::Local<v8::Value>(), Sizeof_d_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_d", v8::String::kInternalizedString), Sizeof_d_Tpl);
        v8::Local<v8::Signature> Sizeof_f_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_f_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_f, v8::Local<v8::Value>(), Sizeof_f_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_f", v8::String::kInternalizedString), Sizeof_f_Tpl);
        v8::Local<v8::Signature> Sizeof_4_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_4_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_4, v8::Local<v8::Value>(), Sizeof_4_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_4", v8::String::kInternalizedString), Sizeof_4_Tpl);
        v8::Local<v8::Signature> Sizeof_4u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_4u_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_4u, v8::Local<v8::Value>(), Sizeof_4u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_4u", v8::String::kInternalizedString), Sizeof_4u_Tpl);
        v8::Local<v8::Signature> Sizeof_3u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_3u_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_3u, v8::Local<v8::Value>(), Sizeof_3u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_3u", v8::String::kInternalizedString), Sizeof_3u_Tpl);
        v8::Local<v8::Signature> Sizeof_2_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_2_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_2, v8::Local<v8::Value>(), Sizeof_2_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_2", v8::String::kInternalizedString), Sizeof_2_Tpl);
        v8::Local<v8::Signature> Sizeof_2u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_2u_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_2u, v8::Local<v8::Value>(), Sizeof_2u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_2u", v8::String::kInternalizedString), Sizeof_2u_Tpl);
        v8::Local<v8::Signature> Sizeof_1_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_1_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_1, v8::Local<v8::Value>(), Sizeof_1_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_1", v8::String::kInternalizedString), Sizeof_1_Tpl);
        v8::Local<v8::Signature> Sizeof_1u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_1u_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_1u, v8::Local<v8::Value>(), Sizeof_1u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_1u", v8::String::kInternalizedString), Sizeof_1u_Tpl);
        v8::Local<v8::Signature> Sizeof_bool_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_bool_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_bool, v8::Local<v8::Value>(), Sizeof_bool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_bool", v8::String::kInternalizedString), Sizeof_bool_Tpl);
        v8::Local<v8::Signature> Sizeof_uint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_uint_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_uint, v8::Local<v8::Value>(), Sizeof_uint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_uint", v8::String::kInternalizedString), Sizeof_uint_Tpl);
        v8::Local<v8::Signature> Sizeof_color_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_color_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_color, v8::Local<v8::Value>(), Sizeof_color_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_color", v8::String::kInternalizedString), Sizeof_color_Tpl);
        v8::Local<v8::Signature> Sizeof_offset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_offset_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_offset, v8::Local<v8::Value>(), Sizeof_offset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_offset", v8::String::kInternalizedString), Sizeof_offset_Tpl);
        v8::Local<v8::Signature> Sizeof_point_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_point_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_point, v8::Local<v8::Value>(), Sizeof_point_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_point", v8::String::kInternalizedString), Sizeof_point_Tpl);
        v8::Local<v8::Signature> Sizeof_vector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_vector_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_vector, v8::Local<v8::Value>(), Sizeof_vector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_vector", v8::String::kInternalizedString), Sizeof_vector_Tpl);
        v8::Local<v8::Signature> Sizeof_rect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_rect_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_rect, v8::Local<v8::Value>(), Sizeof_rect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_rect", v8::String::kInternalizedString), Sizeof_rect_Tpl);
        v8::Local<v8::Signature> Sizeof_rotr_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_rotr_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_rotr, v8::Local<v8::Value>(), Sizeof_rotr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_rotr", v8::String::kInternalizedString), Sizeof_rotr_Tpl);
        v8::Local<v8::Signature> Sizeof_quad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_quad_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_quad, v8::Local<v8::Value>(), Sizeof_quad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_quad", v8::String::kInternalizedString), Sizeof_quad_Tpl);
        v8::Local<v8::Signature> Sizeof_str_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_str_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_str, v8::Local<v8::Value>(), Sizeof_str_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_str", v8::String::kInternalizedString), Sizeof_str_Tpl);
        v8::Local<v8::Signature> Sizeof_mem_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_mem_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_mem, v8::Local<v8::Value>(), Sizeof_mem_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_mem", v8::String::kInternalizedString), Sizeof_mem_Tpl);
        v8::Local<v8::Signature> Sizeof_obj_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_obj_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_obj, v8::Local<v8::Value>(), Sizeof_obj_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_obj", v8::String::kInternalizedString), Sizeof_obj_Tpl);
        v8::Local<v8::Signature> Sizeof_ref_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Sizeof_ref_Tpl =
            v8::FunctionTemplate::New(isolate, Sizeof_ref, v8::Local<v8::Value>(), Sizeof_ref_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "sizeof_ref", v8::String::kInternalizedString), Sizeof_ref_Tpl);
        v8::Local<v8::Signature> GetDataSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDataSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetDataSize, v8::Local<v8::Value>(), GetDataSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getDataSize", v8::String::kInternalizedString), GetDataSize_Tpl);
        v8::Local<v8::Signature> GetDataPtr_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDataPtr_Tpl =
            v8::FunctionTemplate::New(isolate, GetDataPtr, v8::Local<v8::Value>(), GetDataPtr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getDataPtr", v8::String::kInternalizedString), GetDataPtr_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Serializer", v8::String::kInternalizedString), t->GetFunction());

    }

    void SerializerWrap::Serialize_d(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_d(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_f(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_f(val);
        args.GetReturnValue().SetUndefined();
    }
#ifndef PDG_NO_64BIT

    void SerializerWrap::Serialize_8(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_8(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_8u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_8u(val);
        args.GetReturnValue().SetUndefined();
    }
#endif

    void SerializerWrap::Serialize_4(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_4(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_4u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_4u(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_3u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_3u(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_2(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_2(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_2u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_2u(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_1(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_1(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_1u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_1u(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_bool(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""val"")");
        bool val = args[1 -1]->BooleanValue();
        self->serialize_bool(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_uint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_uint(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_color(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Color] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsColor(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Color", *args[1 -1]);
        pdg::Color val = v8_ValueToColor(isolate, args[1 -1]);
        self->serialize_color(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_offset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset val = v8_ValueToOffset(isolate, args[1 -1]);
        self->serialize_offset(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_point(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point val = v8_ValueToPoint(isolate, args[1 -1]);
        self->serialize_point(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_vector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Vector] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector val = v8_ValueToVector(isolate, args[1 -1]);
        self->serialize_vector(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_rect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Rect] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect r = v8_ValueToRect(isolate, args[1 -1]);
        self->serialize_rect(r);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_rotr(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object RotatedRect] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect val = v8_ValueToRotatedRect(isolate, args[1 -1]);
        self->serialize_rotr(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_quad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Quad] val)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad val = v8_ValueToQuad(isolate, args[1 -1]);
        self->serialize_quad(val);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_str(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string str)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""str"")");
        v8::String::Utf8Value str_Str(args[1 -1]->ToString());
        const char* str = *str_Str;;
        self->serialize_str(str);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_mem(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[string Binary]|[object MemBlock]} mem)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        bool isStr = args[0]->IsString();
        if (!isStr && !args[0]->IsObject())
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mem) must be either a binary string or an object of type MemBlock";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (isStr)
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            self->serialize_mem(ptr, bytes);
        }
        else
        {
            REQUIRE_CPP_OBJECT_ARG(1, memBlock, MemBlock);
            self->serialize_mem(memBlock->ptr, memBlock->bytes);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::Serialize_ref(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(object obj)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, obj);
        self->serialize_ref< v8::Local<v8::Object> >(&obj);
        args.GetReturnValue().SetUndefined();
    }

    void SerializerWrap::GetDataSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        uint32 dataSize = self->getDataSize();
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, dataSize) ); return; };
    }

    void SerializerWrap::GetDataPtr(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object MemBlock]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        MemBlock* memBlock = new MemBlock((char*)self->getDataPtr(), self->getDataSize(), false);
        if (!memBlock) args.GetReturnValue().SetNull();
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( MemBlockWrap::NewFromCpp(isolate, memBlock) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, memBlock->mMemBlockScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void SerializerWrap::Sizeof_1(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number int]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        size_t n = self->sizeof_1(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_1u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_1u(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_2(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number int]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        size_t n = self->sizeof_2(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_2u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_2u(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_3u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_3u(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_4(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number int]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        size_t n = self->sizeof_4(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_4u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_4u(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }
#ifndef PDG_NO_64BIT

    void SerializerWrap::Sizeof_8(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number int]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        size_t n = self->sizeof_8(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_8u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_8u(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }
#endif

    void SerializerWrap::Sizeof_f(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "number" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        size_t n = self->sizeof_f(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_d(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "number" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        size_t n = self->sizeof_d(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_uint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[number uint]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        size_t n = self->sizeof_uint(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_str(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "string" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""val"")");
        v8::String::Utf8Value val_Str(args[1 -1]->ToString());
        const char* val = *val_Str;;
        size_t n = self->sizeof_str(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_bool(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "boolean" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""val"")");
        bool val = args[1 -1]->BooleanValue();
        size_t n = self->sizeof_bool(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_point(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Point]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point val = v8_ValueToPoint(isolate, args[1 -1]);
        size_t n = self->sizeof_point(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_offset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Offset]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset val = v8_ValueToOffset(isolate, args[1 -1]);
        size_t n = self->sizeof_offset(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_vector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Vector]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector val = v8_ValueToVector(isolate, args[1 -1]);
        size_t n = self->sizeof_vector(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_rect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Rect]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect val = v8_ValueToRect(isolate, args[1 -1]);
        size_t n = self->sizeof_rect(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_rotr(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object RotatedRect]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect val = v8_ValueToRotatedRect(isolate, args[1 -1]);
        size_t n = self->sizeof_rotr(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_quad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Quad]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad val = v8_ValueToQuad(isolate, args[1 -1]);
        size_t n = self->sizeof_quad(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_color(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object Color]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsColor(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Color", *args[1 -1]);
        pdg::Color val = v8_ValueToColor(isolate, args[1 -1]);
        size_t n = self->sizeof_color(val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_ref(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "object" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, val);
        size_t n = self->sizeof_ref< v8::Local<v8::Object> >(&val);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_obj(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint] function(" "[object ISerializable]" " val) - ") ); return; };
        }
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, val);
        size_t n = 0;
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void SerializerWrap::Sizeof_mem(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number uint]" " function" "({[string Binary]|[object MemBlock]} mem)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        bool isStr = args[0]->IsString();
        if (!isStr && !args[0]->IsObject())
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mem) must be either a binary string or an object of type MemBlock";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        size_t n = 0;
        if (isStr)
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            n = self->sizeof_mem(ptr, bytes);
        }
        else
        {
            REQUIRE_CPP_OBJECT_ARG(1, memBlock, MemBlock);
            n = self->sizeof_mem(memBlock->ptr, memBlock->bytes);
        }
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, n) ); return; };
    }

    void CleanupSerializerScriptObject(v8::Persistent<v8::Object> &obj) { }

    Serializer* New_Serializer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Serializer_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new Serializer();
    }

    ;
    ;
    ;
    ;
    ;

    bool s_Deserializer_InNewFromCpp = false;

    void DeserializerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = new DeserializerWrap(args);
        objWrapper->Wrap(args.This());
        Deserializer* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mDeserializerScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> DeserializerWrap::NewFromCpp(v8::Isolate* isolate, Deserializer* cppObj)
    {
        s_Deserializer_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(instance);

        cppObj->mDeserializerScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Deserializer_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> DeserializerWrap::constructorTpl_;

    void DeserializerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Deserializer", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
#ifndef PDG_NO_64BIT
        v8::Local<v8::Signature> Deserialize_8_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_8_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_8, v8::Local<v8::Value>(), Deserialize_8_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_8", v8::String::kInternalizedString), Deserialize_8_Tpl);
        v8::Local<v8::Signature> Deserialize_8u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_8u_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_8u, v8::Local<v8::Value>(), Deserialize_8u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_8u", v8::String::kInternalizedString), Deserialize_8u_Tpl);
#endif
        v8::Local<v8::Signature> Deserialize_d_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_d_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_d, v8::Local<v8::Value>(), Deserialize_d_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_d", v8::String::kInternalizedString), Deserialize_d_Tpl);
        v8::Local<v8::Signature> Deserialize_f_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_f_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_f, v8::Local<v8::Value>(), Deserialize_f_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_f", v8::String::kInternalizedString), Deserialize_f_Tpl);
        v8::Local<v8::Signature> Deserialize_4_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_4_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_4, v8::Local<v8::Value>(), Deserialize_4_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_4", v8::String::kInternalizedString), Deserialize_4_Tpl);
        v8::Local<v8::Signature> Deserialize_4u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_4u_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_4u, v8::Local<v8::Value>(), Deserialize_4u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_4u", v8::String::kInternalizedString), Deserialize_4u_Tpl);
        v8::Local<v8::Signature> Deserialize_3u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_3u_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_3u, v8::Local<v8::Value>(), Deserialize_3u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_3u", v8::String::kInternalizedString), Deserialize_3u_Tpl);
        v8::Local<v8::Signature> Deserialize_2_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_2_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_2, v8::Local<v8::Value>(), Deserialize_2_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_2", v8::String::kInternalizedString), Deserialize_2_Tpl);
        v8::Local<v8::Signature> Deserialize_2u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_2u_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_2u, v8::Local<v8::Value>(), Deserialize_2u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_2u", v8::String::kInternalizedString), Deserialize_2u_Tpl);
        v8::Local<v8::Signature> Deserialize_1_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_1_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_1, v8::Local<v8::Value>(), Deserialize_1_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_1", v8::String::kInternalizedString), Deserialize_1_Tpl);
        v8::Local<v8::Signature> Deserialize_1u_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_1u_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_1u, v8::Local<v8::Value>(), Deserialize_1u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_1u", v8::String::kInternalizedString), Deserialize_1u_Tpl);
        v8::Local<v8::Signature> Deserialize_bool_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_bool_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_bool, v8::Local<v8::Value>(), Deserialize_bool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_bool", v8::String::kInternalizedString), Deserialize_bool_Tpl);
        v8::Local<v8::Signature> Deserialize_uint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_uint_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_uint, v8::Local<v8::Value>(), Deserialize_uint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_uint", v8::String::kInternalizedString), Deserialize_uint_Tpl);
        v8::Local<v8::Signature> Deserialize_color_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_color_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_color, v8::Local<v8::Value>(), Deserialize_color_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_color", v8::String::kInternalizedString), Deserialize_color_Tpl);
        v8::Local<v8::Signature> Deserialize_offset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_offset_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_offset, v8::Local<v8::Value>(), Deserialize_offset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_offset", v8::String::kInternalizedString), Deserialize_offset_Tpl);
        v8::Local<v8::Signature> Deserialize_point_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_point_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_point, v8::Local<v8::Value>(), Deserialize_point_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_point", v8::String::kInternalizedString), Deserialize_point_Tpl);
        v8::Local<v8::Signature> Deserialize_vector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_vector_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_vector, v8::Local<v8::Value>(), Deserialize_vector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_vector", v8::String::kInternalizedString), Deserialize_vector_Tpl);
        v8::Local<v8::Signature> Deserialize_rect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_rect_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_rect, v8::Local<v8::Value>(), Deserialize_rect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_rect", v8::String::kInternalizedString), Deserialize_rect_Tpl);
        v8::Local<v8::Signature> Deserialize_rotr_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_rotr_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_rotr, v8::Local<v8::Value>(), Deserialize_rotr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_rotr", v8::String::kInternalizedString), Deserialize_rotr_Tpl);
        v8::Local<v8::Signature> Deserialize_quad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_quad_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_quad, v8::Local<v8::Value>(), Deserialize_quad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_quad", v8::String::kInternalizedString), Deserialize_quad_Tpl);
        v8::Local<v8::Signature> Deserialize_str_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_str_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_str, v8::Local<v8::Value>(), Deserialize_str_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_str", v8::String::kInternalizedString), Deserialize_str_Tpl);
        v8::Local<v8::Signature> Deserialize_mem_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_mem_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_mem, v8::Local<v8::Value>(), Deserialize_mem_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_mem", v8::String::kInternalizedString), Deserialize_mem_Tpl);
        v8::Local<v8::Signature> Deserialize_memGetLen_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_memGetLen_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_memGetLen, v8::Local<v8::Value>(), Deserialize_memGetLen_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_memGetLen", v8::String::kInternalizedString), Deserialize_memGetLen_Tpl);
        v8::Local<v8::Signature> Deserialize_obj_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_obj_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_obj, v8::Local<v8::Value>(), Deserialize_obj_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_obj", v8::String::kInternalizedString), Deserialize_obj_Tpl);
        v8::Local<v8::Signature> Deserialize_ref_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_ref_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize_ref, v8::Local<v8::Value>(), Deserialize_ref_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize_ref", v8::String::kInternalizedString), Deserialize_ref_Tpl);
        v8::Local<v8::Signature> SetDataPtr_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetDataPtr_Tpl =
            v8::FunctionTemplate::New(isolate, SetDataPtr, v8::Local<v8::Value>(), SetDataPtr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setDataPtr", v8::String::kInternalizedString), SetDataPtr_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Deserializer", v8::String::kInternalizedString), t->GetFunction());

    }

    void DeserializerWrap::Deserialize_d(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            double val = self->deserialize_d();
            { args.GetReturnValue().Set( v8::Number::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_f(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            float val = self->deserialize_f();
            { args.GetReturnValue().Set( v8::Number::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }
#ifndef PDG_NO_64BIT

    void DeserializerWrap::Deserialize_8(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            int64 val = self->deserialize_8();
            { args.GetReturnValue().Set( v8::Number::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_8u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint64 val = self->deserialize_8u();
            { args.GetReturnValue().Set( v8::Number::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }
#endif

    void DeserializerWrap::Deserialize_4(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            int32 val = self->deserialize_4();
            { args.GetReturnValue().Set( v8::Integer::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_4u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_4u();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_3u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_3u();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_2(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            int16 val = self->deserialize_2();
            { args.GetReturnValue().Set( v8::Integer::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_2u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint16 val = self->deserialize_2u();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_1(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            int8 val = self->deserialize_1();
            { args.GetReturnValue().Set( v8::Integer::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_1u(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint8 val = self->deserialize_1u();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_bool(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            bool val = self->deserialize_bool();
            { args.GetReturnValue().Set( v8::Boolean::New(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_uint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_uint();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_color(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Color]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Color val = self->deserialize_color();
            { args.GetReturnValue().Set( v8_MakeJavascriptColor(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_offset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Offset val = self->deserialize_offset();
            { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_point(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Point val = self->deserialize_point();
            { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_vector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Vector val = self->deserialize_vector();
            { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_rect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Rect val = self->deserialize_rect();
            { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_rotr(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            RotatedRect val = self->deserialize_rotr();
            { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_quad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Quad]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            Quad val = self->deserialize_quad();
            { args.GetReturnValue().Set( v8_MakeJavascriptQuad(isolate, val) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_str(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            std::string mystr;
            self->deserialize_string(mystr);
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, mystr.c_str()) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_strGetLen(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint32 len = self->deserialize_strGetLen();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, len) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_mem(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object MemBlock]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        size_t len, len2;
        try
        {
            len = self->deserialize_memGetLen();
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        char* mem = (char*) std::malloc(len);
        try
        {
            len2 = self->deserialize_mem(mem, len);
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (len2 != len)
        {
            std::ostringstream excpt_;
            excpt_ << "Deserializer internal error, deserialized memory length mismatch " << len << " (" << (void*)len << ") != " << len2 << " (" << (void*)len2 << ")";
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));

        }

        MemBlock* memBlock = new MemBlock(mem, len, true);
        if (!memBlock) args.GetReturnValue().SetNull();
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( MemBlockWrap::NewFromCpp(isolate, memBlock) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, memBlock->mMemBlockScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void DeserializerWrap::Deserialize_memGetLen(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            uint32 len = self->deserialize_memGetLen();
            { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, len) ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::SetDataPtr(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[string Binary]|[object MemBlock]} data)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[0]->IsString() && !args[0]->IsObject())
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mem) must be either a binary string or an object of type MemBlock";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            self->setDataPtr(ptr, bytes);
        }
        else
        {
            REQUIRE_CPP_OBJECT_ARG(1, memBlock, MemBlock);
            self->setDataPtr(memBlock->ptr, memBlock->bytes);
        }
        args.GetReturnValue().SetUndefined();
    }

    void DeserializerWrap::Deserialize_obj(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        self->mDeserializerScriptObj.Reset(isolate, args.This());
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object ISerializable]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            ISerializable* obj = self->deserialize_obj();
            SCRIPT_DEBUG_ONLY( if (obj->mISerializableScriptObj.IsEmpty())
            {
                std::cerr << __func__<<":"<< 1188 << " - NIL JS Object (" "obj->mISerializableScriptObj" "|"<<*((void**)&(obj->mISerializableScriptObj))<<")\n";
            }
            else if (!obj->mISerializableScriptObj->IsObject())
            {
                std::cerr << __func__<<":"<< 1188 << " - NOT JS Object (" "obj->mISerializableScriptObj" "|"<<*((void**)&(obj->mISerializableScriptObj))<<") : " << (obj->mISerializableScriptObj.IsEmpty() ? "empty" : obj->mISerializableScriptObj->IsArray() ? "array" : obj->mISerializableScriptObj->IsFunction() ? "function" : obj->mISerializableScriptObj->IsStringObject() ? "string (object)" : obj->mISerializableScriptObj->IsString() ? "string" : obj->mISerializableScriptObj->IsNull() ? "null" : obj->mISerializableScriptObj->IsUndefined() ? "undefined" : obj->mISerializableScriptObj->IsNumberObject() ? "number (object)" : obj->mISerializableScriptObj->IsNumber() ? "number" : obj->mISerializableScriptObj->IsBoolean() ? "boolean" : obj->mISerializableScriptObj->IsDate() ? "date" : obj->mISerializableScriptObj->IsRegExp() ? "regexp" : obj->mISerializableScriptObj->IsNativeError() ? "error" : obj->mISerializableScriptObj->IsObject() ? "object" : "unknown") << "\n";
            }
            else
            {
                v8::Local<v8::Object> obj_ = obj->mISerializableScriptObj->ToObject();
                    v8::String::Utf8Value objNameStr(obj_->ToString());
                    char* objName = *objNameStr;
                    ISerializableWrap* obj__=jswrap::ObjectWrap::Unwrap< ISerializableWrap>(obj_);
                    if (!obj__)
                {
                    v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                        if (protoVal_->IsObject())
                    {
                        obj_ = protoVal_->ToObject();
                            obj__ = jswrap::ObjectWrap::Unwrap< ISerializableWrap>(obj_);
                    }
                    if (obj__)
                    {
                        std::cout << __func__<<":"<< 1188 << " - JS Object (""obj->mISerializableScriptObj""|"<<*((void**)&(obj->mISerializableScriptObj))<<"): " << objName << " - is a subclass of C++ ""ISerializable""\n";
                    }
                    else
                    {
                        std::cout << __func__<<":"<< 1188 << " - JS Object (""obj->mISerializableScriptObj""|"<<*((void**)&(obj->mISerializableScriptObj))<<"): " << objName << " - does not wrap ""ISerializable""\n";
                    }
                }
                else
                {
                    ISerializable* obj = dynamic_cast<ISerializable*>(obj__->getCppObject());
                        std::cout << __func__<<":"<< 1188 << " - JS Object (""obj->mISerializableScriptObj""|" << *((void**)&(obj->mISerializableScriptObj)) << "): " << objName<<" - wraps C++ ""ISerializable"" ("<<(void*)obj<<")\n";
                }
            } )
                if (!obj) args.GetReturnValue().SetNull();
            if (obj->mISerializableScriptObj.IsEmpty())
            {
                { args.GetReturnValue().Set( ISerializableWrap::NewFromCpp(isolate, obj) ); return; };
            }
            else
            {
                v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, obj->mISerializableScriptObj );
                { args.GetReturnValue().Set( obj__ ); return; };
            };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(sync_error& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void DeserializerWrap::Deserialize_ref(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "object" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        try
        {
            v8::Local<v8::Object> obj = *self->deserialize_ref< v8::Local<v8::Object> >();
            { args.GetReturnValue().Set( obj ); return; };
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void RegisterSerializableClass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(function klass)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_FUNCTION_ARG(1, constructorFunc);
        v8::Local<v8::Value> objVal = constructorFunc->CallAsConstructor(0, 0);
        v8::Local<v8::Object> obj = objVal->ToObject();
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< 1222 << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< 1222 << " - NOT JS Object (" "obj" "|"<<*((void**)&(obj))<<") : " << (obj.IsEmpty() ? "empty" : obj->IsArray() ? "array" : obj->IsFunction() ? "function" : obj->IsStringObject() ? "string (object)" : obj->IsString() ? "string" : obj->IsNull() ? "null" : obj->IsUndefined() ? "undefined" : obj->IsNumberObject() ? "number (object)" : obj->IsNumber() ? "number" : obj->IsBoolean() ? "boolean" : obj->IsDate() ? "date" : obj->IsRegExp() ? "regexp" : obj->IsNativeError() ? "error" : obj->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISerializableWrap* obj__=jswrap::ObjectWrap::Unwrap< ISerializableWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< ISerializableWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 1222 << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of C++ ""ISerializable""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 1222 << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""ISerializable""\n";
                }
            }
            else
            {
                ISerializable* obj = dynamic_cast<ISerializable*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 1222 << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps C++ ""ISerializable"" ("<<(void*)obj<<")\n";
            }
        } );
        v8::Local<v8::Function> func;
        if ((!obj->IsNull() && obj->Has(v8::String::NewFromUtf8(isolate, "getMyClassTag", v8::String::kInternalizedString))))
        {
            func = v8::Local<v8::Function>::Cast(obj->Get(v8::String::NewFromUtf8(isolate, "getMyClassTag", v8::String::kInternalizedString)));
        }
        else
        {
            std::ostringstream msg;
            msg << "argument 1: ISerializable subclass " << v8_GetObjectClassName(obj) << " missing getMyClassTag() Function!!";
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        uint32 classTag = func->Call(obj, 0, 0)->Uint32Value();
        Deserializer::registerScriptClass(classTag, constructorFunc);
        args.GetReturnValue().SetUndefined();
    }

    void CleanupDeserializerScriptObject(v8::Persistent<v8::Object> &obj) { }

    Deserializer* New_Deserializer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Deserializer_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new Deserializer();
    }

    bool s_Image_InNewFromCpp = false;

    void ImageWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = new ImageWrap(args);
        objWrapper->Wrap(args.This());
        Image* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mImageScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> ImageWrap::NewFromCpp(v8::Isolate* isolate, Image* cppObj)
    {
        s_Image_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(instance);

        cppObj->mImageScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Image_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> ImageWrap::constructorTpl_;

    void ImageWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Image", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> GetImageBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetImageBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetImageBounds, v8::Local<v8::Value>(), GetImageBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ImageBounds", v8::String::kInternalizedString), GetImageBounds_Tpl);
        v8::Local<v8::Signature> GetSubsection_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSubsection_Tpl =
            v8::FunctionTemplate::New(isolate, GetSubsection, v8::Local<v8::Value>(), GetSubsection_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Subsection", v8::String::kInternalizedString), GetSubsection_Tpl);
        v8::Local<v8::Signature> SetTransparentColor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetTransparentColor_Tpl =
            v8::FunctionTemplate::New(isolate, SetTransparentColor, v8::Local<v8::Value>(), SetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""TransparentColor", v8::String::kInternalizedString), SetTransparentColor_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, GetOpacity, v8::Local<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Opacity", v8::String::kInternalizedString), GetOpacity_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, SetOpacity, v8::Local<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Opacity", v8::String::kInternalizedString), SetOpacity_Tpl);
        v8::Local<v8::Signature> SetEdgeClamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetEdgeClamping_Tpl =
            v8::FunctionTemplate::New(isolate, SetEdgeClamping, v8::Local<v8::Value>(), SetEdgeClamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""EdgeClamping", v8::String::kInternalizedString), SetEdgeClamping_Tpl);
        v8::Local<v8::Signature> GetTransparentColor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTransparentColor_Tpl =
            v8::FunctionTemplate::New(isolate, GetTransparentColor, v8::Local<v8::Value>(), GetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTransparentColor", v8::String::kInternalizedString), GetTransparentColor_Tpl);
        v8::Local<v8::Signature> RetainData_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RetainData_Tpl =
            v8::FunctionTemplate::New(isolate, RetainData, v8::Local<v8::Value>(), RetainData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "retainData", v8::String::kInternalizedString), RetainData_Tpl);
        v8::Local<v8::Signature> RetainAlpha_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RetainAlpha_Tpl =
            v8::FunctionTemplate::New(isolate, RetainAlpha, v8::Local<v8::Value>(), RetainAlpha_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "retainAlpha", v8::String::kInternalizedString), RetainAlpha_Tpl);
        v8::Local<v8::Signature> PrepareToRasterize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PrepareToRasterize_Tpl =
            v8::FunctionTemplate::New(isolate, PrepareToRasterize, v8::Local<v8::Value>(), PrepareToRasterize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "prepareToRasterize", v8::String::kInternalizedString), PrepareToRasterize_Tpl);
        v8::Local<v8::Signature> GetAlphaValue_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetAlphaValue_Tpl =
            v8::FunctionTemplate::New(isolate, GetAlphaValue, v8::Local<v8::Value>(), GetAlphaValue_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""AlphaValue", v8::String::kInternalizedString), GetAlphaValue_Tpl);
        v8::Local<v8::Signature> GetPixel_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetPixel_Tpl =
            v8::FunctionTemplate::New(isolate, GetPixel, v8::Local<v8::Value>(), GetPixel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getPixel", v8::String::kInternalizedString), GetPixel_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Image", v8::String::kInternalizedString), t->GetFunction());

    }

    void ImageWrap::GetTransparentColor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Color]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Color theTransparentColor = self->getTransparentColor();
        { args.GetReturnValue().Set( v8_MakeJavascriptColor(isolate, theTransparentColor) ); return; };
    }

    void ImageWrap::SetTransparentColor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Image]" " function" "([object Color] inTransparentColor)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsColor(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Color", *args[1 -1]);
        pdg::Color theTransparentColor = v8_ValueToColor(isolate, args[1 -1]);

        self->setTransparentColor(theTransparentColor);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void ImageWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theWidth) ); return; };
    }

    void ImageWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theHeight) ); return; };
    }

    void ImageWrap::GetImageBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [object Rect]" " function" "([object Point] at)" " - " "get image boundary rect, optionally with top left at given point") ); return; };
        };
        if (args.Length() >= 1 && !v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point at = (args.Length()<1) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[1 -1]);
        Rect r = self->getImageBounds(at);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void ImageWrap::GetSubsection(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [object Image]" " function" "({[object Quad]|[object Rect]} quad)" " - " "get image that is an arbitrary subsection of this image") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        Image* image = self->getSubsection(quad);
        if (!image) args.GetReturnValue().SetNull();
        if (image->mImageScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( ImageWrap::NewFromCpp(isolate, image) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, image->mImageScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void ImageWrap::GetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR number" " function" "()" " - " "get opacity of this image: 0.0 - completely transparent to 1.0 - completely solid") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        uint8 opacity = self->getOpacity();
        double opacityFloat = (float)opacity / 255.0f;
        { args.GetReturnValue().Set( v8::Number::New(isolate, opacityFloat) ); return; };
    }

    void ImageWrap::SetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "(number opacity)" " - " "set opacity of this image as range from either (0-255) or (0.0 to 1.0)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""opacity"")");
        unsigned long opacity = (args.Length()<1) ? 0xffffffff : args[1 -1]->Uint32Value();;
        if (opacity == 0xffffffff)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""opacityFloat"")");
            double opacityFloat = args[1 -1]->NumberValue();
            opacity = std::floor(255.0f * opacityFloat);
        }
        if (opacity > 255) opacity = 255;
        self->setOpacity(opacity);
        args.GetReturnValue().SetUndefined();
    }

    void ImageWrap::SetEdgeClamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "(boolean inUseEdgeClamp)" " - " "set whether image uses edge clamping or not") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""inUseEdgeClamp"")");
        bool inUseEdgeClamp = args[1 -1]->BooleanValue();
        self->setEdgeClamping(inUseEdgeClamp);
        args.GetReturnValue().SetUndefined();
    }

    void ImageWrap::RetainData(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "()" " - " "retain pixel data for use by Image.getPixel()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->retainData();
        args.GetReturnValue().SetUndefined();
    }

    void ImageWrap::RetainAlpha(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "()" " - " "retain alpha data for use by Image.getAlphaValue() or per-pixel sprite collisions") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->retainAlpha();
        args.GetReturnValue().SetUndefined();
    }

    void ImageWrap::PrepareToRasterize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR number" " function" "()" " - " "bind the image into an OpenGL texture and free image data from main memory") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->prepareToRasterize();
        args.GetReturnValue().SetUndefined();
    }

    void ImageWrap::GetAlphaValue(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "({[object Point] p|[number int] x, [number int] y})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        uint8 a;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            a = self->getAlphaValue(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(isolate, args[1 -1]))
                v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
            a = self->getAlphaValue(p.x, p.y);
        }
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, a) ); return; };
    }

    void ImageWrap::GetPixel(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Color]" " function" "({[object Point] p|[number int] x, [number int] y})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        pdg::Color c;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            c = self->getPixel(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(isolate, args[1 -1]))
                v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
            c = self->getPixel(p.x, p.y);
        }
        { args.GetReturnValue().Set( v8_MakeJavascriptColor(isolate, c) ); return; };
    }

    void CleanupImageScriptObject(v8::Persistent<v8::Object> &obj) { }

    Image* New_Image(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Image_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 must be a string (filename)";
                v8::Isolate* isolate = v8::Isolate::GetCurrent();
                s_SavedError.Reset(isolate, v8::Exception::SyntaxError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
            };
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            Image* img = Image::createImageFromFile(filename);
            if (!img)
            {
                s_HaveSavedError = true;
                {
                    std::ostringstream excpt_;
                    excpt_ << "could not create Image from file ["<<filename<<"]";
                    v8::Isolate* isolate = v8::Isolate::GetCurrent();
                    s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
                };
                return 0;
            }
            else
            {
                return img;
            }
        }
    }

    bool s_ImageStrip_InNewFromCpp = false;

    void ImageStripWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = new ImageStripWrap(args);
        objWrapper->Wrap(args.This());
        ImageStrip* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mImageStripScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> ImageStripWrap::NewFromCpp(v8::Isolate* isolate, ImageStrip* cppObj)
    {
        s_ImageStrip_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(instance);

        cppObj->mImageStripScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_ImageStrip_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> ImageStripWrap::constructorTpl_;

    void ImageStripWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ImageStrip", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> GetImageBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetImageBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetImageBounds, v8::Local<v8::Value>(), GetImageBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ImageBounds", v8::String::kInternalizedString), GetImageBounds_Tpl);
        v8::Local<v8::Signature> GetSubsection_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSubsection_Tpl =
            v8::FunctionTemplate::New(isolate, GetSubsection, v8::Local<v8::Value>(), GetSubsection_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Subsection", v8::String::kInternalizedString), GetSubsection_Tpl);
        v8::Local<v8::Signature> SetTransparentColor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetTransparentColor_Tpl =
            v8::FunctionTemplate::New(isolate, SetTransparentColor, v8::Local<v8::Value>(), SetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""TransparentColor", v8::String::kInternalizedString), SetTransparentColor_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, GetOpacity, v8::Local<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Opacity", v8::String::kInternalizedString), GetOpacity_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, SetOpacity, v8::Local<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Opacity", v8::String::kInternalizedString), SetOpacity_Tpl);
        v8::Local<v8::Signature> SetEdgeClamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetEdgeClamping_Tpl =
            v8::FunctionTemplate::New(isolate, SetEdgeClamping, v8::Local<v8::Value>(), SetEdgeClamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""EdgeClamping", v8::String::kInternalizedString), SetEdgeClamping_Tpl);
        v8::Local<v8::Signature> GetTransparentColor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTransparentColor_Tpl =
            v8::FunctionTemplate::New(isolate, GetTransparentColor, v8::Local<v8::Value>(), GetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTransparentColor", v8::String::kInternalizedString), GetTransparentColor_Tpl);
        v8::Local<v8::Signature> RetainData_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RetainData_Tpl =
            v8::FunctionTemplate::New(isolate, RetainData, v8::Local<v8::Value>(), RetainData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "retainData", v8::String::kInternalizedString), RetainData_Tpl);
        v8::Local<v8::Signature> RetainAlpha_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RetainAlpha_Tpl =
            v8::FunctionTemplate::New(isolate, RetainAlpha, v8::Local<v8::Value>(), RetainAlpha_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "retainAlpha", v8::String::kInternalizedString), RetainAlpha_Tpl);
        v8::Local<v8::Signature> PrepareToRasterize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PrepareToRasterize_Tpl =
            v8::FunctionTemplate::New(isolate, PrepareToRasterize, v8::Local<v8::Value>(), PrepareToRasterize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "prepareToRasterize", v8::String::kInternalizedString), PrepareToRasterize_Tpl);
        v8::Local<v8::Signature> GetAlphaValue_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetAlphaValue_Tpl =
            v8::FunctionTemplate::New(isolate, GetAlphaValue, v8::Local<v8::Value>(), GetAlphaValue_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""AlphaValue", v8::String::kInternalizedString), GetAlphaValue_Tpl);
        v8::Local<v8::Signature> GetPixel_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetPixel_Tpl =
            v8::FunctionTemplate::New(isolate, GetPixel, v8::Local<v8::Value>(), GetPixel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getPixel", v8::String::kInternalizedString), GetPixel_Tpl);
        v8::Local<v8::Signature> GetFrame_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFrame_Tpl =
            v8::FunctionTemplate::New(isolate, GetFrame, v8::Local<v8::Value>(), GetFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Frame", v8::String::kInternalizedString), GetFrame_Tpl);
        v8::Local<v8::Signature> GetFrameWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFrameWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetFrameWidth, v8::Local<v8::Value>(), GetFrameWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FrameWidth", v8::String::kInternalizedString), GetFrameWidth_Tpl);
        v8::Local<v8::Signature> SetFrameWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFrameWidth_Tpl =
            v8::FunctionTemplate::New(isolate, SetFrameWidth, v8::Local<v8::Value>(), SetFrameWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""FrameWidth", v8::String::kInternalizedString), SetFrameWidth_Tpl);
        v8::Local<v8::Signature> GetNumFrames_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNumFrames_Tpl =
            v8::FunctionTemplate::New(isolate, GetNumFrames, v8::Local<v8::Value>(), GetNumFrames_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""NumFrames", v8::String::kInternalizedString), GetNumFrames_Tpl);
        v8::Local<v8::Signature> SetNumFrames_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetNumFrames_Tpl =
            v8::FunctionTemplate::New(isolate, SetNumFrames, v8::Local<v8::Value>(), SetNumFrames_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""NumFrames", v8::String::kInternalizedString), SetNumFrames_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "ImageStrip", v8::String::kInternalizedString), t->GetFunction());

    }

    void ImageStripWrap::GetTransparentColor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Color]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Color theTransparentColor = self->getTransparentColor();
        { args.GetReturnValue().Set( v8_MakeJavascriptColor(isolate, theTransparentColor) ); return; };
    }

    void ImageStripWrap::SetTransparentColor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object ImageStrip]" " function" "([object Color] inTransparentColor)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsColor(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Color", *args[1 -1]);
        pdg::Color theTransparentColor = v8_ValueToColor(isolate, args[1 -1]);

        self->setTransparentColor(theTransparentColor);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void ImageStripWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theWidth) ); return; };
    }

    void ImageStripWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theHeight) ); return; };
    }

    void ImageStripWrap::GetImageBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [object Rect]" " function" "([object Point] at)" " - " "get image boundary rect, optionally with top left at given point") ); return; };
        };
        if (args.Length() >= 1 && !v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point at = (args.Length()<1) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[1 -1]);
        Rect r = self->getImageBounds(at);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void ImageStripWrap::GetSubsection(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [object Image]" " function" "({[object Quad]|[object Rect]} quad)" " - " "get image that is an arbitrary subsection of this image") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        Image* image = self->getSubsection(quad);
        if (!image) args.GetReturnValue().SetNull();
        if (image->mImageScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( ImageWrap::NewFromCpp(isolate, image) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, image->mImageScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void ImageStripWrap::GetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR number" " function" "()" " - " "get opacity of this image: 0.0 - completely transparent to 1.0 - completely solid") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        uint8 opacity = self->getOpacity();
        double opacityFloat = (float)opacity / 255.0f;
        { args.GetReturnValue().Set( v8::Number::New(isolate, opacityFloat) ); return; };
    }

    void ImageStripWrap::SetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "(number opacity)" " - " "set opacity of this image as range from either (0-255) or (0.0 to 1.0)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""opacity"")");
        unsigned long opacity = (args.Length()<1) ? 0xffffffff : args[1 -1]->Uint32Value();;
        if (opacity == 0xffffffff)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""opacityFloat"")");
            double opacityFloat = args[1 -1]->NumberValue();
            opacity = std::floor(255.0f * opacityFloat);
        }
        if (opacity > 255) opacity = 255;
        self->setOpacity(opacity);
        args.GetReturnValue().SetUndefined();
    }

    void ImageStripWrap::SetEdgeClamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "(boolean inUseEdgeClamp)" " - " "set whether image uses edge clamping or not") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""inUseEdgeClamp"")");
        bool inUseEdgeClamp = args[1 -1]->BooleanValue();
        self->setEdgeClamping(inUseEdgeClamp);
        args.GetReturnValue().SetUndefined();
    }

    void ImageStripWrap::RetainData(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "()" " - " "retain pixel data for use by Image.getPixel()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->retainData();
        args.GetReturnValue().SetUndefined();
    }

    void ImageStripWrap::RetainAlpha(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "()" " - " "retain alpha data for use by Image.getAlphaValue() or per-pixel sprite collisions") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->retainAlpha();
        args.GetReturnValue().SetUndefined();
    }

    void ImageStripWrap::PrepareToRasterize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR number" " function" "()" " - " "bind the image into an OpenGL texture and free image data from main memory") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->prepareToRasterize();
        args.GetReturnValue().SetUndefined();
    }

    void ImageStripWrap::GetAlphaValue(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "({[object Point] p|[number int] x, [number int] y})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        uint8 a;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            a = self->getAlphaValue(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(isolate, args[1 -1]))
                v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
            a = self->getAlphaValue(p.x, p.y);
        }
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, a) ); return; };
    }

    void ImageStripWrap::GetPixel(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Color]" " function" "({[object Point] p|[number int] x, [number int] y})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        pdg::Color c;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            c = self->getPixel(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(isolate, args[1 -1]))
                v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
            c = self->getPixel(p.x, p.y);
        }
        { args.GetReturnValue().Set( v8_MakeJavascriptColor(isolate, c) ); return; };
    }

    void ImageStripWrap::GetNumFrames(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int32 theNumFrames = self->getNumFrames();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theNumFrames) ); return; };
    }

    void ImageStripWrap::SetNumFrames(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object ImageStrip]" " function" "([number int] inNumFrames)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theNumFrames"")");
        long theNumFrames = args[1 -1]->Int32Value();

        self->setNumFrames(theNumFrames);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void ImageStripWrap::GetFrameWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int32 theFrameWidth = self->getFrameWidth();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theFrameWidth) ); return; };
    }

    void ImageStripWrap::SetFrameWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object ImageStrip]" " function" "([number int] inFrameWidth)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theFrameWidth"")");
        long theFrameWidth = args[1 -1]->Int32Value();

        self->setFrameWidth(theFrameWidth);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void ImageStripWrap::GetFrame(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Image]" " function" "([number int] frameNum)" " - " "get image that is a single frame of this multi-frame image") ); return; };
        };

        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frameNum"")");
        long frameNum = args[1 -1]->Int32Value();
        Image* image = self->getFrame(frameNum);
        if (!image) args.GetReturnValue().SetNull();
        if (image->mImageScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( ImageWrap::NewFromCpp(isolate, image) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, image->mImageScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void CleanupImageStripScriptObject(v8::Persistent<v8::Object> &obj) { }

    ImageStrip* New_ImageStrip(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_ImageStrip_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 must be a string (filename)";
                v8::Isolate* isolate = v8::Isolate::GetCurrent();
                s_SavedError.Reset(isolate, v8::Exception::SyntaxError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
            };
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            ImageStrip* img = ImageStrip::createImageStripFromFile(filename);
            if (!img)
            {
                s_HaveSavedError = true;
                {
                    std::ostringstream excpt_;
                    excpt_ << "could not create ImageStrip from file ["<<filename<<"]";
                    v8::Isolate* isolate = v8::Isolate::GetCurrent();
                    s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
                };
                return 0;
            }
            else
            {
                return img;
            }
        }
    }

#ifndef PDG_NO_GUI

    static bool s_GraphicsManager_InNewFromCpp = false;

    void GraphicsManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = new GraphicsManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> GraphicsManagerWrap::instance_;
    bool GraphicsManagerWrap::instanced_ = false;

    v8::Local<v8::Object> GraphicsManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    GraphicsManager* GraphicsManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(val);
        return dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> GraphicsManagerWrap::constructorTpl_;

    void GraphicsManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "GraphicsManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetNumScreens_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNumScreens_Tpl =
            v8::FunctionTemplate::New(isolate, GetNumScreens, v8::Local<v8::Value>(), GetNumScreens_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""NumScreens", v8::String::kInternalizedString), GetNumScreens_Tpl);
        v8::Local<v8::Signature> GetFPS_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFPS_Tpl =
            v8::FunctionTemplate::New(isolate, GetFPS, v8::Local<v8::Value>(), GetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FPS", v8::String::kInternalizedString), GetFPS_Tpl);
        v8::Local<v8::Signature> GetTargetFPS_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTargetFPS_Tpl =
            v8::FunctionTemplate::New(isolate, GetTargetFPS, v8::Local<v8::Value>(), GetTargetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""TargetFPS", v8::String::kInternalizedString), GetTargetFPS_Tpl);
        v8::Local<v8::Signature> SetTargetFPS_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetTargetFPS_Tpl =
            v8::FunctionTemplate::New(isolate, SetTargetFPS, v8::Local<v8::Value>(), SetTargetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""TargetFPS", v8::String::kInternalizedString), SetTargetFPS_Tpl);
        v8::Local<v8::Signature> GetMouse_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMouse_Tpl =
            v8::FunctionTemplate::New(isolate, GetMouse, v8::Local<v8::Value>(), GetMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Mouse", v8::String::kInternalizedString), GetMouse_Tpl);
        v8::Local<v8::Signature> GetCurrentScreenMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCurrentScreenMode_Tpl =
            v8::FunctionTemplate::New(isolate, GetCurrentScreenMode, v8::Local<v8::Value>(), GetCurrentScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getCurrentScreenMode", v8::String::kInternalizedString), GetCurrentScreenMode_Tpl);
        v8::Local<v8::Signature> GetNumSupportedScreenModes_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNumSupportedScreenModes_Tpl =
            v8::FunctionTemplate::New(isolate, GetNumSupportedScreenModes, v8::Local<v8::Value>(), GetNumSupportedScreenModes_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getNumSupportedScreenModes", v8::String::kInternalizedString), GetNumSupportedScreenModes_Tpl);
        v8::Local<v8::Signature> GetNthSupportedScreenMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNthSupportedScreenMode_Tpl =
            v8::FunctionTemplate::New(isolate, GetNthSupportedScreenMode, v8::Local<v8::Value>(), GetNthSupportedScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getNthSupportedScreenMode", v8::String::kInternalizedString), GetNthSupportedScreenMode_Tpl);
        v8::Local<v8::Signature> SetScreenMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetScreenMode_Tpl =
            v8::FunctionTemplate::New(isolate, SetScreenMode, v8::Local<v8::Value>(), SetScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setScreenMode", v8::String::kInternalizedString), SetScreenMode_Tpl);
        v8::Local<v8::Signature> CreateWindowPort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateWindowPort_Tpl =
            v8::FunctionTemplate::New(isolate, CreateWindowPort, v8::Local<v8::Value>(), CreateWindowPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createWindowPort", v8::String::kInternalizedString), CreateWindowPort_Tpl);
        v8::Local<v8::Signature> CreateFullScreenPort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateFullScreenPort_Tpl =
            v8::FunctionTemplate::New(isolate, CreateFullScreenPort, v8::Local<v8::Value>(), CreateFullScreenPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createFullScreenPort", v8::String::kInternalizedString), CreateFullScreenPort_Tpl);
        v8::Local<v8::Signature> CloseGraphicsPort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CloseGraphicsPort_Tpl =
            v8::FunctionTemplate::New(isolate, CloseGraphicsPort, v8::Local<v8::Value>(), CloseGraphicsPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "closeGraphicsPort", v8::String::kInternalizedString), CloseGraphicsPort_Tpl);
        v8::Local<v8::Signature> CreateFont_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateFont_Tpl =
            v8::FunctionTemplate::New(isolate, CreateFont, v8::Local<v8::Value>(), CreateFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createFont", v8::String::kInternalizedString), CreateFont_Tpl);
        v8::Local<v8::Signature> GetMainPort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMainPort_Tpl =
            v8::FunctionTemplate::New(isolate, GetMainPort, v8::Local<v8::Value>(), GetMainPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMainPort", v8::String::kInternalizedString), GetMainPort_Tpl);
        v8::Local<v8::Signature> SwitchToFullScreenMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SwitchToFullScreenMode_Tpl =
            v8::FunctionTemplate::New(isolate, SwitchToFullScreenMode, v8::Local<v8::Value>(), SwitchToFullScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "switchToFullScreenMode", v8::String::kInternalizedString), SwitchToFullScreenMode_Tpl);
        v8::Local<v8::Signature> SwitchToWindowMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SwitchToWindowMode_Tpl =
            v8::FunctionTemplate::New(isolate, SwitchToWindowMode, v8::Local<v8::Value>(), SwitchToWindowMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "switchToWindowMode", v8::String::kInternalizedString), SwitchToWindowMode_Tpl);
        v8::Local<v8::Signature> InFullScreenMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> InFullScreenMode_Tpl =
            v8::FunctionTemplate::New(isolate, InFullScreenMode, v8::Local<v8::Value>(), InFullScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "inFullScreenMode", v8::String::kInternalizedString), InFullScreenMode_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "GraphicsManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void GraphicsManagerWrap::GetNumScreens(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theNumScreens = self->getNumScreens();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theNumScreens) ); return; };
    }

    void GraphicsManagerWrap::GetFPS(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theFPS = self->getFPS();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theFPS) ); return; };
    }

    void GraphicsManagerWrap::GetTargetFPS(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theTargetFPS = self->getTargetFPS();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theTargetFPS) ); return; };
    }

    void GraphicsManagerWrap::SetTargetFPS(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object GraphicsManager]" " function" "(number inTargetFPS)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theTargetFPS"")");
        double theTargetFPS = args[1 -1]->NumberValue();

        self->setTargetFPS(theTargetFPS);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void GraphicsManagerWrap::GetMouse(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([number int] mouseNumber = 0)") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""mouseNumber"")");
        long mouseNumber = (args.Length()<1) ? 0 : args[1 -1]->Int32Value();;

        pdg::Point theMouse = self->getMouse(mouseNumber);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, theMouse) ); return; };
    }

    void GraphicsManagerWrap::GetNumSupportedScreenModes(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([number int] screen = PRIMARY_SCREEN)") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""screenNum"")");
        long screenNum = (args.Length()<1) ? screenNum_PrimaryScreen : args[1 -1]->Int32Value();;

        int32 theNumSupportedScreenModes = self->getNumSupportedScreenModes(screenNum);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theNumSupportedScreenModes) ); return; };
    }

    void GraphicsManagerWrap::SetScreenMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] width, [number int] height, [number int] screenNum = PRIMARY_SCREEN, [number int] bpp = 0)" " - " "changes specified screen to closest matching mode") ); return; };
        };

        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        long width = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        long height = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""screenNum"")");
        long screenNum = (args.Length()<3) ? screenNum_PrimaryScreen : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""bpp"")");
        long bpp = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        self->setScreenMode(width, height, screenNum, bpp);
        args.GetReturnValue().SetUndefined();
    }

    void GraphicsManagerWrap::CreateWindowPort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "([object Rect] rect, string windName = \"\", [number int] bpp = 0)" " - " "create windowed drawing port with given dimensions, title and depth") ); return; };
        };

        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 2, "a string  (""windName"")");
        v8::String::Utf8Value _windName_String( (args.Length()<2) ? v8::String::NewFromUtf8(isolate, "", v8::String::kInternalizedString) : args[2 -1]->ToString() );
        const char* windName = (args.Length()<2) ? "" : *_windName_String;;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""bpp"")");
        long bpp = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        Port* port = self->createWindowPort(rect, windName, bpp);
        if (!port) args.GetReturnValue().SetNull();
        if (port->mPortScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( PortWrap::NewFromCpp(isolate, port) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, port->mPortScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void GraphicsManagerWrap::CreateFullScreenPort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "([object Rect] rect, [number int] screenNum = PRIMARY_SCREEN, boolean allowResChange = true, [number int] bpp = 0)" " - " "create full screen drawing port with given dimensions on given screen, optionally changing depth") ); return; };
        };

        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""screenNum"")");
        long screenNum = (args.Length()<2) ? screenNum_PrimaryScreen : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 3, "a boolean (""allowResChange"")");
        bool allowResChange = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""bpp"")");
        long bpp = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        Port* port = self->createFullScreenPort(rect, screenNum, allowResChange, bpp);
        if (!port) args.GetReturnValue().SetNull();
        if (port->mPortScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( PortWrap::NewFromCpp(isolate, port) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, port->mPortScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void GraphicsManagerWrap::CloseGraphicsPort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Port] port = MAIN_PORT)" " - " "close given port, along with its window and restore screen mode if changed") ); return; };
        };

        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        self->closeGraphicsPort(port);
        args.GetReturnValue().SetUndefined();
    }

    void GraphicsManagerWrap::CreateFont(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Font]" " function" "(string fontName, number scalingFactor = 1.0)" " - " "get a font with optional scaling adjust") ); return; };
        };

        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""fontName"")");
        v8::String::Utf8Value fontName_Str(args[1 -1]->ToString());
        const char* fontName = *fontName_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""scalingFactor"")");
        double scalingFactor = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        Font* font = self->createFont(fontName, scalingFactor);
        if (!font) args.GetReturnValue().SetNull();
        if (font->mFontScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( FontWrap::NewFromCpp(isolate, font) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, font->mFontScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void GraphicsManagerWrap::GetMainPort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "()" " - " "return the primary graphics port") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Port* port = self->getMainPort();
        if (!port) args.GetReturnValue().SetNull();
        if (port->mPortScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( PortWrap::NewFromCpp(isolate, port) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, port->mPortScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void GraphicsManagerWrap::SwitchToFullScreenMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "(boolean allowResChange = false, [object Port] port = MAIN_PORT)" " - " "change a port to fullscreen mode, return true on success") ); return; };
        };

        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""allowResChange"")");
        bool allowResChange = (args.Length()<1) ? 0 : args[1 -1]->BooleanValue();;
        Port* port = 0;
        if (args.Length() >= 2)
        {
            if (!args[2 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 2, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[2 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        bool result = self->switchToFullScreenMode(allowResChange, port);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void GraphicsManagerWrap::SwitchToWindowMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Port] port = MAIN_PORT, string windName = \"\")" " - " "change a port to window mode, return true on success") ); return; };
        };

        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        if (args.Length() >= 2 && !args[2 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 2, "a string  (""windName"")");
        v8::String::Utf8Value _windName_String( (args.Length()<2) ? v8::String::NewFromUtf8(isolate, "", v8::String::kInternalizedString) : args[2 -1]->ToString() );
        const char* windName = (args.Length()<2) ? "" : *_windName_String;;
        bool result = self->switchToWindowMode(port, windName);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void GraphicsManagerWrap::InFullScreenMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "return whether primary graphics port is fullscreen or not") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool fullscreen = self->inFullScreenMode();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, fullscreen) ); return; };
    }

    GraphicsManager* New_GraphicsManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_GraphicsManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return GraphicsManager::getSingletonInstance();
    }

    static bool s_Font_InNewFromCpp = false;

    void FontWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = new FontWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> FontWrap::NewFromCpp(v8::Isolate* isolate, Font* cppObj)
    {
        s_Font_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(instance);

        cppObj->mFontScriptObj.Reset(isolate, obj);
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Font_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> FontWrap::constructorTpl_;

    void FontWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Font", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetFontName_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFontName_Tpl =
            v8::FunctionTemplate::New(isolate, GetFontName, v8::Local<v8::Value>(), GetFontName_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FontName", v8::String::kInternalizedString), GetFontName_Tpl);
        v8::Local<v8::Signature> GetFontHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFontHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetFontHeight, v8::Local<v8::Value>(), GetFontHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FontHeight", v8::String::kInternalizedString), GetFontHeight_Tpl);
        v8::Local<v8::Signature> GetFontLeading_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFontLeading_Tpl =
            v8::FunctionTemplate::New(isolate, GetFontLeading, v8::Local<v8::Value>(), GetFontLeading_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FontLeading", v8::String::kInternalizedString), GetFontLeading_Tpl);
        v8::Local<v8::Signature> GetFontAscent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFontAscent_Tpl =
            v8::FunctionTemplate::New(isolate, GetFontAscent, v8::Local<v8::Value>(), GetFontAscent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FontAscent", v8::String::kInternalizedString), GetFontAscent_Tpl);
        v8::Local<v8::Signature> GetFontDescent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFontDescent_Tpl =
            v8::FunctionTemplate::New(isolate, GetFontDescent, v8::Local<v8::Value>(), GetFontDescent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""FontDescent", v8::String::kInternalizedString), GetFontDescent_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Font", v8::String::kInternalizedString), t->GetFunction());

    }

    void FontWrap::GetFontName(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        const char* theFontName = self->getFontName();
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, theFontName) ); return; };
    }

    void FontWrap::GetFontHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(number size, [number int] style = textStyle_Plain)") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontHeight = self->getFontHeight(size, style);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theFontHeight) ); return; };
    }

    void FontWrap::GetFontLeading(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(number size, [number int] style = textStyle_Plain)") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontLeading = self->getFontLeading(size, style);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theFontLeading) ); return; };
    }

    void FontWrap::GetFontAscent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(number size, [number int] style = textStyle_Plain)") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontAscent = self->getFontAscent(size, style);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theFontAscent) ); return; };
    }

    void FontWrap::GetFontDescent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(number size, [number int] style = textStyle_Plain)") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontDescent = self->getFontDescent(size, style);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theFontDescent) ); return; };
    }

    void CleanupFontScriptObject(v8::Persistent<v8::Object> &obj) { }

    Font* New_Font(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Font_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        s_HaveSavedError = true;
        {
            std::ostringstream excpt_;
            excpt_ << "Font cannot be created directly, use pdg.gfx.createFont()";
            v8::Isolate* isolate = v8::Isolate::GetCurrent();
            s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        };
        return 0;
    }

    static bool s_Port_InNewFromCpp = false;

    void PortWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = new PortWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> PortWrap::NewFromCpp(v8::Isolate* isolate, Port* cppObj)
    {
        s_Port_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(instance);

        cppObj->mPortScriptObj.Reset(isolate, obj);
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Port_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> PortWrap::constructorTpl_;

    void PortWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Port", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetClipRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetClipRect_Tpl =
            v8::FunctionTemplate::New(isolate, GetClipRect, v8::Local<v8::Value>(), GetClipRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ClipRect", v8::String::kInternalizedString), GetClipRect_Tpl);
        v8::Local<v8::Signature> SetClipRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetClipRect_Tpl =
            v8::FunctionTemplate::New(isolate, SetClipRect, v8::Local<v8::Value>(), SetClipRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""ClipRect", v8::String::kInternalizedString), SetClipRect_Tpl);
        v8::Local<v8::Signature> GetCursor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCursor_Tpl =
            v8::FunctionTemplate::New(isolate, GetCursor, v8::Local<v8::Value>(), GetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Cursor", v8::String::kInternalizedString), GetCursor_Tpl);
        v8::Local<v8::Signature> SetCursor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCursor_Tpl =
            v8::FunctionTemplate::New(isolate, SetCursor, v8::Local<v8::Value>(), SetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Cursor", v8::String::kInternalizedString), SetCursor_Tpl);
        v8::Local<v8::Signature> GetDrawingArea_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDrawingArea_Tpl =
            v8::FunctionTemplate::New(isolate, GetDrawingArea, v8::Local<v8::Value>(), GetDrawingArea_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""DrawingArea", v8::String::kInternalizedString), GetDrawingArea_Tpl);
        v8::Local<v8::Signature> FillRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillRect_Tpl =
            v8::FunctionTemplate::New(isolate, FillRect, v8::Local<v8::Value>(), FillRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillRect", v8::String::kInternalizedString), FillRect_Tpl);
        v8::Local<v8::Signature> FrameRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FrameRect_Tpl =
            v8::FunctionTemplate::New(isolate, FrameRect, v8::Local<v8::Value>(), FrameRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "frameRect", v8::String::kInternalizedString), FrameRect_Tpl);
        v8::Local<v8::Signature> DrawLine_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawLine_Tpl =
            v8::FunctionTemplate::New(isolate, DrawLine, v8::Local<v8::Value>(), DrawLine_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawLine", v8::String::kInternalizedString), DrawLine_Tpl);
        v8::Local<v8::Signature> FrameOval_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FrameOval_Tpl =
            v8::FunctionTemplate::New(isolate, FrameOval, v8::Local<v8::Value>(), FrameOval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "frameOval", v8::String::kInternalizedString), FrameOval_Tpl);
        v8::Local<v8::Signature> FillOval_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillOval_Tpl =
            v8::FunctionTemplate::New(isolate, FillOval, v8::Local<v8::Value>(), FillOval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillOval", v8::String::kInternalizedString), FillOval_Tpl);
        v8::Local<v8::Signature> FrameCircle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FrameCircle_Tpl =
            v8::FunctionTemplate::New(isolate, FrameCircle, v8::Local<v8::Value>(), FrameCircle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "frameCircle", v8::String::kInternalizedString), FrameCircle_Tpl);
        v8::Local<v8::Signature> FillCircle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillCircle_Tpl =
            v8::FunctionTemplate::New(isolate, FillCircle, v8::Local<v8::Value>(), FillCircle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillCircle", v8::String::kInternalizedString), FillCircle_Tpl);
        v8::Local<v8::Signature> FrameRoundRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FrameRoundRect_Tpl =
            v8::FunctionTemplate::New(isolate, FrameRoundRect, v8::Local<v8::Value>(), FrameRoundRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "frameRoundRect", v8::String::kInternalizedString), FrameRoundRect_Tpl);
        v8::Local<v8::Signature> FillRoundRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillRoundRect_Tpl =
            v8::FunctionTemplate::New(isolate, FillRoundRect, v8::Local<v8::Value>(), FillRoundRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillRoundRect", v8::String::kInternalizedString), FillRoundRect_Tpl);
        v8::Local<v8::Signature> FillRectEx_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillRectEx_Tpl =
            v8::FunctionTemplate::New(isolate, FillRectEx, v8::Local<v8::Value>(), FillRectEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillRectEx", v8::String::kInternalizedString), FillRectEx_Tpl);
        v8::Local<v8::Signature> FrameRectEx_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FrameRectEx_Tpl =
            v8::FunctionTemplate::New(isolate, FrameRectEx, v8::Local<v8::Value>(), FrameRectEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "frameRectEx", v8::String::kInternalizedString), FrameRectEx_Tpl);
        v8::Local<v8::Signature> DrawLineEx_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawLineEx_Tpl =
            v8::FunctionTemplate::New(isolate, DrawLineEx, v8::Local<v8::Value>(), DrawLineEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawLineEx", v8::String::kInternalizedString), DrawLineEx_Tpl);
        v8::Local<v8::Signature> FillRectWithGradient_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FillRectWithGradient_Tpl =
            v8::FunctionTemplate::New(isolate, FillRectWithGradient, v8::Local<v8::Value>(), FillRectWithGradient_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fillRectWithGradient", v8::String::kInternalizedString), FillRectWithGradient_Tpl);
        v8::Local<v8::Signature> DrawText_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawText_Tpl =
            v8::FunctionTemplate::New(isolate, DrawText, v8::Local<v8::Value>(), DrawText_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawText", v8::String::kInternalizedString), DrawText_Tpl);
        v8::Local<v8::Signature> DrawImage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawImage_Tpl =
            v8::FunctionTemplate::New(isolate, DrawImage, v8::Local<v8::Value>(), DrawImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawImage", v8::String::kInternalizedString), DrawImage_Tpl);
        v8::Local<v8::Signature> DrawTexture_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawTexture_Tpl =
            v8::FunctionTemplate::New(isolate, DrawTexture, v8::Local<v8::Value>(), DrawTexture_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawTexture", v8::String::kInternalizedString), DrawTexture_Tpl);
        v8::Local<v8::Signature> DrawTexturedSphere_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DrawTexturedSphere_Tpl =
            v8::FunctionTemplate::New(isolate, DrawTexturedSphere, v8::Local<v8::Value>(), DrawTexturedSphere_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "drawTexturedSphere", v8::String::kInternalizedString), DrawTexturedSphere_Tpl);
        v8::Local<v8::Signature> GetTextWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTextWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetTextWidth, v8::Local<v8::Value>(), GetTextWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTextWidth", v8::String::kInternalizedString), GetTextWidth_Tpl);
        v8::Local<v8::Signature> GetCurrentFont_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCurrentFont_Tpl =
            v8::FunctionTemplate::New(isolate, GetCurrentFont, v8::Local<v8::Value>(), GetCurrentFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getCurrentFont", v8::String::kInternalizedString), GetCurrentFont_Tpl);
        v8::Local<v8::Signature> SetFont_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFont_Tpl =
            v8::FunctionTemplate::New(isolate, SetFont, v8::Local<v8::Value>(), SetFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFont", v8::String::kInternalizedString), SetFont_Tpl);
        v8::Local<v8::Signature> SetFontForStyle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFontForStyle_Tpl =
            v8::FunctionTemplate::New(isolate, SetFontForStyle, v8::Local<v8::Value>(), SetFontForStyle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFontForStyle", v8::String::kInternalizedString), SetFontForStyle_Tpl);
        v8::Local<v8::Signature> SetFontScalingFactor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFontScalingFactor_Tpl =
            v8::FunctionTemplate::New(isolate, SetFontScalingFactor, v8::Local<v8::Value>(), SetFontScalingFactor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFontScalingFactor", v8::String::kInternalizedString), SetFontScalingFactor_Tpl);
        v8::Local<v8::Signature> StartTrackingMouse_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartTrackingMouse_Tpl =
            v8::FunctionTemplate::New(isolate, StartTrackingMouse, v8::Local<v8::Value>(), StartTrackingMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startTrackingMouse", v8::String::kInternalizedString), StartTrackingMouse_Tpl);
        v8::Local<v8::Signature> StopTrackingMouse_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopTrackingMouse_Tpl =
            v8::FunctionTemplate::New(isolate, StopTrackingMouse, v8::Local<v8::Value>(), StopTrackingMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopTrackingMouse", v8::String::kInternalizedString), StopTrackingMouse_Tpl);
        v8::Local<v8::Signature> ResetCursor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ResetCursor_Tpl =
            v8::FunctionTemplate::New(isolate, ResetCursor, v8::Local<v8::Value>(), ResetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resetCursor", v8::String::kInternalizedString), ResetCursor_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Port", v8::String::kInternalizedString), t->GetFunction());

    }

    void PortWrap::GetDrawingArea(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Rect theDrawingArea = self->getDrawingArea();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, theDrawingArea) ); return; };
    }

    void PortWrap::GetClipRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Rect theClipRect = self->getClipRect();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, theClipRect) ); return; };
    }

    void PortWrap::SetClipRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "([object Rect] inClipRect)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect theClipRect = v8_ValueToRect(isolate, args[1 -1]);

        self->setClipRect(theClipRect);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void PortWrap::FillRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        if (args.Length() >= 2 && !v8_ValueIsColor(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Color", *args[2 -1]);
        pdg::Color rgba = (args.Length()<2) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[2 -1]);
        self->fillRect(quad, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FrameRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        if (args.Length() >= 2 && !v8_ValueIsColor(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Color", *args[2 -1]);
        pdg::Color rgba = (args.Length()<2) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[2 -1]);
        self->frameRect(quad, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawLine(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] from, [object Point] to, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point from = v8_ValueToPoint(isolate, args[1 -1]);
        if (!v8_ValueIsPoint(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Point", *args[2 -1]);
        pdg::Point to = v8_ValueToPoint(isolate, args[2 -1]);
        if (args.Length() >= 3 && !v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[3 -1]);
        self->drawLine(from, to, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FrameOval(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] centerPt, number xRadius, number yRadius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""xRadius"")");
        double xRadius = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""yRadius"")");
        double yRadius = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !v8_ValueIsColor(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Color", *args[4 -1]);
        pdg::Color rgba = (args.Length()<4) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[4 -1]);
        self->frameOval(centerPt, xRadius, yRadius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FillOval(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] centerPt, number xRadius, number yRadius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""xRadius"")");
        double xRadius = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""yRadius"")");
        double yRadius = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !v8_ValueIsColor(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Color", *args[4 -1]);
        pdg::Color rgba = (args.Length()<4) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[4 -1]);
        self->fillOval(centerPt, xRadius, yRadius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FrameCircle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] centerPt, number radius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[3 -1]);
        self->frameCircle(centerPt, radius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FillCircle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] centerPt, number radius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[3 -1]);
        self->fillCircle(centerPt, radius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FrameRoundRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Rect] rect, number radius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[3 -1]);
        self->frameRoundRect(rect, radius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FillRoundRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Rect] rect, number radius, [object Color] rgba = \"black\")" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[3 -1]);
        self->fillRoundRect(rect, radius, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FillRectEx(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Quad]|[object Rect]} quad, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") ); return; };
        };
        if (args.Length() != 4)
            v8_ThrowArgCountException(isolate, args.Length(), 4);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""pattern"")");
        unsigned long pattern = args[2 -1]->Uint32Value();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""patternShift"")");
        unsigned long patternShift = args[3 -1]->Uint32Value();
        if (!v8_ValueIsColor(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Color", *args[4 -1]);
        pdg::Color rgba = v8_ValueToColor(isolate, args[4 -1]);
        self->fillRectEx(quad, pattern, patternShift, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FrameRectEx(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Quad]|[object Rect]} quad, [number uint] thickness, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") ); return; };
        };
        if (args.Length() != 5)
            v8_ThrowArgCountException(isolate, args.Length(), 5);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""thickness"")");
        unsigned long thickness = args[2 -1]->Uint32Value();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""pattern"")");
        unsigned long pattern = args[3 -1]->Uint32Value();
        if (!args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""patternShift"")");
        unsigned long patternShift = args[4 -1]->Uint32Value();
        if (!v8_ValueIsColor(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Color", *args[5 -1]);
        pdg::Color rgba = v8_ValueToColor(isolate, args[5 -1]);
        self->frameRectEx(quad, thickness, pattern, patternShift, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawLineEx(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] from, [object Point] to, [number uint] thickness, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") ); return; };
        };
        if (args.Length() != 6)
            v8_ThrowArgCountException(isolate, args.Length(), 6);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point from = v8_ValueToPoint(isolate, args[1 -1]);
        if (!v8_ValueIsPoint(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Point", *args[2 -1]);
        pdg::Point to = v8_ValueToPoint(isolate, args[2 -1]);
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""thickness"")");
        unsigned long thickness = args[3 -1]->Uint32Value();
        if (!args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""pattern"")");
        unsigned long pattern = args[4 -1]->Uint32Value();
        if (!args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""patternShift"")");
        unsigned long patternShift = args[5 -1]->Uint32Value();
        if (!v8_ValueIsColor(isolate, args[6 -1]))
            v8_ThrowArgTypeException(isolate, 6, "Color", *args[6 -1]);
        pdg::Color rgba = v8_ValueToColor(isolate, args[6 -1]);
        self->drawLineEx(from, to, thickness, pattern, patternShift, rgba);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::FillRectWithGradient(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] startColor, [object Color] endColor)" " - " "") ); return; };
        };
        if (args.Length() != 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(isolate, args[1 -1]);
        if (!v8_ValueIsColor(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Color", *args[2 -1]);
        pdg::Color startColor = v8_ValueToColor(isolate, args[2 -1]);
        if (!v8_ValueIsColor(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Color", *args[3 -1]);
        pdg::Color endColor = v8_ValueToColor(isolate, args[3 -1]);
        self->fillRectWithGradient(quad, startColor, endColor);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawText(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(string text, {[object Point] location|[object Quad] quad|[object Rect] rect}, [number int] size, [number uint] style = textStyle_Plain, [object Color] rgba = 'black')" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""text"")");
        v8::String::Utf8Value text_Str(args[1 -1]->ToString());
        const char* text = *text_Str;;

        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""size"")");
        long size = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""style"")");
        unsigned long style = (args.Length()<4) ? textStyle_Plain : args[4 -1]->Uint32Value();;
        if (args.Length() >= 5 && !v8_ValueIsColor(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Color", *args[5 -1]);
        pdg::Color rgba = (args.Length()<5) ? PDG_BLACK_COLOR : v8_ValueToColor(isolate, args[5 -1]);
        if (v8_ValueIsPoint(isolate, args[1]))
        {

            pdg::Point loc = v8_ValueToPoint(isolate, args[1]);
            self->drawText(text, loc, size, style, rgba);
        }
        else
        {

            if (!v8_ValueIsQuad(isolate, args[2 -1]))
                v8_ThrowArgTypeException(isolate, 2, "Quad", *args[2 -1]);
            pdg::Quad quad = v8_ValueToQuad(isolate, args[2 -1]);
            self->drawText(text, quad, size, style, rgba);
        }
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawImage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Image] img, [object Point] loc|[object Image] img, [object Quad] quad|[object Image] img, [object Rect] rect, [number int] fitType = fit_Fill, boolean clipOverflow = false})" " - " "") ); return; };
        };
        REQUIRE_CPP_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 2 + argAdd)
            v8_ThrowArgCountException(isolate, args.Length(), 2 + argAdd, true);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (v8_ValueIsPoint(isolate, args[1 + argAdd]))
        {
            pdg::Point loc = v8_ValueToPoint(isolate, args[1 + argAdd]);

            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, loc);
            }
            else
            {
                self->drawImage(img, loc);
            }
        }
        else if (args.Length() > 2 + argAdd)
        {
            if (!v8_ValueIsRect(isolate, args[2 + argAdd-1]))
                v8_ThrowArgTypeException(isolate, 2 + argAdd, "Rect", *args[2 + argAdd-1]);
            pdg::Rect rect = v8_ValueToRect(isolate, args[2 + argAdd-1]);
            if (args.Length() >= 3 + argAdd && !args[3 + argAdd-1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3 + argAdd, "a number (""fitType"")");
            long fitType = (args.Length()<3 + argAdd) ? fit_Fill : args[3 + argAdd-1]->Int32Value();;
            if (args.Length() >= 4 + argAdd && !args[4 + argAdd-1]->IsBoolean())
                v8_ThrowArgTypeException(isolate, 4 + argAdd, "a boolean (""clipOverflow"")");
            bool clipOverflow = (args.Length()<4 + argAdd) ? false : args[4 + argAdd-1]->BooleanValue();;
            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, rect, (FitType)fitType, clipOverflow);
            }
            else
            {
                self->drawImage(img, rect, (FitType)fitType, clipOverflow);
            }
        }
        else
        {

            if (!v8_ValueIsQuad(isolate, args[2 + argAdd-1]))
                v8_ThrowArgTypeException(isolate, 2 + argAdd, "Quad", *args[2 + argAdd-1]);
            pdg::Quad quad = v8_ValueToQuad(isolate, args[2 + argAdd-1]);
            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, quad);
            }
            else
            {
                self->drawImage(img, quad);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawTexture(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Image] img, [object Rect] r)" " - " "") ); return; };
        };
        REQUIRE_CPP_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 2 + argAdd)
            v8_ThrowArgCountException(isolate, args.Length(), 2 + argAdd, true);
        if (!v8_ValueIsRect(isolate, args[2 + argAdd-1]))
            v8_ThrowArgTypeException(isolate, 2 + argAdd, "Rect", *args[2 + argAdd-1]);
        pdg::Rect r = v8_ValueToRect(isolate, args[2 + argAdd-1]);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (imgStrip->frames)
        {
            self->drawTexture(imgStrip, frameNum, r);
        }
        else
        {
            self->drawTexture(img, r);
        }
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::DrawTexturedSphere(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[object Image] img|[object ImageStrip] imgStrip, [number int] frameNum}, [object Point] loc, number radius, number rotation = 0, [object Offset] polarOffsetRadians = Offset(0,0), [object Offset] lightOffsetRadians = Offset(0,0))" " - " "") ); return; };
        };
        REQUIRE_CPP_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 3 + argAdd)
            v8_ThrowArgCountException(isolate, args.Length(), 3 + argAdd, true);
        if (!v8_ValueIsPoint(isolate, args[2 + argAdd-1]))
            v8_ThrowArgTypeException(isolate, 2 + argAdd, "Point", *args[2 + argAdd-1]);
        pdg::Point loc = v8_ValueToPoint(isolate, args[2 + argAdd-1]);
        if (!args[3 + argAdd-1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3 + argAdd, "a number (""radius"")");
        double radius = args[3 + argAdd-1]->NumberValue();
        if (args.Length() >= 4 + argAdd && !args[4 + argAdd-1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4 + argAdd, "a number (""rotation"")");
        double rotation = (args.Length()<4 + argAdd) ? 0.0f : args[4 + argAdd-1]->NumberValue();;
        if (args.Length() >= 5 + argAdd && !v8_ValueIsOffset(isolate, args[5 + argAdd-1]))
            v8_ThrowArgTypeException(isolate, 5 + argAdd, "Offset", *args[5 + argAdd-1]);
        pdg::Offset polarOffsetRadians = (args.Length()<5 + argAdd) ? Offset() : v8_ValueToOffset(isolate, args[5 + argAdd-1]);
        if (args.Length() >= 6 + argAdd && !v8_ValueIsOffset(isolate, args[6 + argAdd-1]))
            v8_ThrowArgTypeException(isolate, 6 + argAdd, "Offset", *args[6 + argAdd-1]);
        pdg::Offset lightOffsetRadians = (args.Length()<6 + argAdd) ? Offset() : v8_ValueToOffset(isolate, args[6 + argAdd-1]);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (imgStrip->frames)
        {
            self->drawTexturedSphere(imgStrip, frameNum, loc, radius, rotation, polarOffsetRadians, lightOffsetRadians);
        }
        else
        {
            self->drawTexturedSphere(img, loc, radius, rotation, polarOffsetRadians, lightOffsetRadians);
        }
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::GetTextWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "(string text, [number int] size, [number uint] style = textStyle_Plain, [number int] len = -1)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""text"")");
        v8::String::Utf8Value text_Str(args[1 -1]->ToString());
        const char* text = *text_Str;;
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""size"")");
        long size = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""style"")");
        unsigned long style = (args.Length()<3) ? textStyle_Plain : args[3 -1]->Uint32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""len"")");
        long len = (args.Length()<4) ? -1 : args[4 -1]->Int32Value();;
        int width = self->getTextWidth(text, size, style, len);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, width) ); return; };
    }

    void PortWrap::GetCurrentFont(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Font]" " function" "([number uint] style = textStyle_Plain)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""style"")");
        unsigned long style = (args.Length()<1) ? textStyle_Plain : args[1 -1]->Uint32Value();;
        Font* font = self->getCurrentFont(style);
        if (!font) args.GetReturnValue().SetNull();
        if (font->mFontScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( FontWrap::NewFromCpp(isolate, font) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, font->mFontScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void PortWrap::SetFont(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Font] font = DEFAULT_FONT)" " - " "") ); return; };
        };
        Font* font = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Font"" (""font"")");
            }
            else
            {
                v8::Local<v8::Object> font_ = args[1 -1]->ToObject();
                FontWrap* font__ = jswrap::ObjectWrap::Unwrap< FontWrap>( font_);
                font = font__->getCppObject();
            }
        };
        self->setFont(font);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::SetFontForStyle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] style, [object Font] font = DEFAULT_FONT)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""style"")");
        unsigned long style = args[1 -1]->Uint32Value();
        Font* font = 0;
        if (args.Length() >= 2)
        {
            if (!args[2 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 2, "an object of type ""Font"" (""font"")");
            }
            else
            {
                v8::Local<v8::Object> font_ = args[2 -1]->ToObject();
                FontWrap* font__ = jswrap::ObjectWrap::Unwrap< FontWrap>( font_);
                font = font__->getCppObject();
            }
        };
        self->setFontForStyle(font, style);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::SetFontScalingFactor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number scaleBy)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""scaleBy"")");
        double scaleBy = args[1 -1]->NumberValue();
        self->setFontScalingFactor(scaleBy);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::StartTrackingMouse(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([object Rect] rect)" " - " "NOT IMPLEMENTED") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(isolate, args[1 -1]);
        int trackingRef = self->startTrackingMouse(rect);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, trackingRef) ); return; };
    }

    void PortWrap::StopTrackingMouse(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] trackingRef)" " - " "NOT IMPLEMENTED") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""trackingRef"")");
        long trackingRef = args[1 -1]->Int32Value();
        self->stopTrackingMouse(trackingRef);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::SetCursor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Image] cursorImage, [object Point] hotSpot)" " - " "NOT IMPLEMENTED") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, cursorImage, Image);
        if (!v8_ValueIsPoint(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Point", *args[2 -1]);
        pdg::Point hotSpot = v8_ValueToPoint(isolate, args[2 -1]);
        self->setCursor(cursorImage, hotSpot);
        args.GetReturnValue().SetUndefined();
    }

    void PortWrap::GetCursor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Image]" " function" "()" " - " "NOT IMPLEMENTED: get the Image that is being used as the cursor") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Image* cursorImage = self->getCursor();
        if (!cursorImage) args.GetReturnValue().SetNull();
        if (cursorImage->mImageScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( ImageWrap::NewFromCpp(isolate, cursorImage) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, cursorImage->mImageScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void PortWrap::ResetCursor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "NOT IMPLEMENTED: restore the default system cursor") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->resetCursor();
        args.GetReturnValue().SetUndefined();
    }

    void CleanupPortScriptObject(v8::Persistent<v8::Object> &obj) { }

    Port* New_Port(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Port_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        s_HaveSavedError = true;
        {
            std::ostringstream excpt_;
            excpt_ << "Port cannot be created directly, use pdg.gfx.createWindowPort() or pdg.gfx.createFullScreenPort()";
            v8::Isolate* isolate = v8::Isolate::GetCurrent();
            s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        };
        return 0;
    }
#endif

#ifndef PDG_NO_SOUND

    static bool s_SoundManager_InNewFromCpp = false;

    void SoundManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundManagerWrap* objWrapper = new SoundManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> SoundManagerWrap::instance_;
    bool SoundManagerWrap::instanced_ = false;

    v8::Local<v8::Object> SoundManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    SoundManager* SoundManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(val);
        return dynamic_cast<SoundManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> SoundManagerWrap::constructorTpl_;

    void SoundManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "SoundManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> SetVolume_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVolume_Tpl =
            v8::FunctionTemplate::New(isolate, SetVolume, v8::Local<v8::Value>(), SetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setVolume", v8::String::kInternalizedString), SetVolume_Tpl);
        v8::Local<v8::Signature> SetMute_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMute_Tpl =
            v8::FunctionTemplate::New(isolate, SetMute, v8::Local<v8::Value>(), SetMute_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setMute", v8::String::kInternalizedString), SetMute_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "SoundManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void SoundManagerWrap::SetVolume(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(args.This());
        SoundManager* self = dynamic_cast<SoundManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number level)" " - " "0.0 - silent to 1.0 - full volume") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""level"")");
        double level = args[1 -1]->NumberValue();
        self->setVolume(level);
        args.GetReturnValue().SetUndefined();
    }

    void SoundManagerWrap::SetMute(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(args.This());
        SoundManager* self = dynamic_cast<SoundManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean muted)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""muted"")");
        bool muted = args[1 -1]->BooleanValue();
        self->setMute(muted);
        args.GetReturnValue().SetUndefined();
    }

    SoundManager* New_SoundManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_SoundManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return SoundManager::getSingletonInstance();
    }

    static bool s_Sound_InNewFromCpp = false;

    void SoundWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = new SoundWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> SoundWrap::NewFromCpp(v8::Isolate* isolate, Sound* cppObj)
    {
        s_Sound_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(instance);

        cppObj->mEventEmitterScriptObj.Reset(isolate, obj); cppObj->mSoundScriptObj.Reset(isolate, obj); cppObj->addRef();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Sound_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> SoundWrap::constructorTpl_;

    void SoundWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Sound", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetVolume_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetVolume_Tpl =
            v8::FunctionTemplate::New(isolate, GetVolume, v8::Local<v8::Value>(), GetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Volume", v8::String::kInternalizedString), GetVolume_Tpl);
        v8::Local<v8::Signature> SetVolume_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVolume_Tpl =
            v8::FunctionTemplate::New(isolate, SetVolume, v8::Local<v8::Value>(), SetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Volume", v8::String::kInternalizedString), SetVolume_Tpl);
        v8::Local<v8::Signature> Play_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Play_Tpl =
            v8::FunctionTemplate::New(isolate, Play, v8::Local<v8::Value>(), Play_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "play", v8::String::kInternalizedString), Play_Tpl);
        v8::Local<v8::Signature> Start_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Start_Tpl =
            v8::FunctionTemplate::New(isolate, Start, v8::Local<v8::Value>(), Start_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "start", v8::String::kInternalizedString), Start_Tpl);
        v8::Local<v8::Signature> Stop_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Stop_Tpl =
            v8::FunctionTemplate::New(isolate, Stop, v8::Local<v8::Value>(), Stop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stop", v8::String::kInternalizedString), Stop_Tpl);
        v8::Local<v8::Signature> Pause_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Pause_Tpl =
            v8::FunctionTemplate::New(isolate, Pause, v8::Local<v8::Value>(), Pause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "pause", v8::String::kInternalizedString), Pause_Tpl);
        v8::Local<v8::Signature> Resume_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Resume_Tpl =
            v8::FunctionTemplate::New(isolate, Resume, v8::Local<v8::Value>(), Resume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resume", v8::String::kInternalizedString), Resume_Tpl);
        v8::Local<v8::Signature> IsPaused_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsPaused_Tpl =
            v8::FunctionTemplate::New(isolate, IsPaused, v8::Local<v8::Value>(), IsPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isPaused", v8::String::kInternalizedString), IsPaused_Tpl);
        v8::Local<v8::Signature> SetLooping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLooping_Tpl =
            v8::FunctionTemplate::New(isolate, SetLooping, v8::Local<v8::Value>(), SetLooping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setLooping", v8::String::kInternalizedString), SetLooping_Tpl);
        v8::Local<v8::Signature> IsLooping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsLooping_Tpl =
            v8::FunctionTemplate::New(isolate, IsLooping, v8::Local<v8::Value>(), IsLooping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isLooping", v8::String::kInternalizedString), IsLooping_Tpl);
        v8::Local<v8::Signature> SetPitch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetPitch_Tpl =
            v8::FunctionTemplate::New(isolate, SetPitch, v8::Local<v8::Value>(), SetPitch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setPitch", v8::String::kInternalizedString), SetPitch_Tpl);
        v8::Local<v8::Signature> ChangePitch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangePitch_Tpl =
            v8::FunctionTemplate::New(isolate, ChangePitch, v8::Local<v8::Value>(), ChangePitch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changePitch", v8::String::kInternalizedString), ChangePitch_Tpl);
        v8::Local<v8::Signature> SetOffsetX_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOffsetX_Tpl =
            v8::FunctionTemplate::New(isolate, SetOffsetX, v8::Local<v8::Value>(), SetOffsetX_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setOffsetX", v8::String::kInternalizedString), SetOffsetX_Tpl);
        v8::Local<v8::Signature> ChangeOffsetX_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeOffsetX_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeOffsetX, v8::Local<v8::Value>(), ChangeOffsetX_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeOffsetX", v8::String::kInternalizedString), ChangeOffsetX_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(isolate, FadeOut, v8::Local<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeOut", v8::String::kInternalizedString), FadeOut_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(isolate, FadeIn, v8::Local<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeIn", v8::String::kInternalizedString), FadeIn_Tpl);
        v8::Local<v8::Signature> ChangeVolume_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeVolume_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeVolume, v8::Local<v8::Value>(), ChangeVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeVolume", v8::String::kInternalizedString), ChangeVolume_Tpl);
        v8::Local<v8::Signature> Skip_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Skip_Tpl =
            v8::FunctionTemplate::New(isolate, Skip, v8::Local<v8::Value>(), Skip_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "skip", v8::String::kInternalizedString), Skip_Tpl);
        v8::Local<v8::Signature> SkipTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SkipTo_Tpl =
            v8::FunctionTemplate::New(isolate, SkipTo, v8::Local<v8::Value>(), SkipTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "skipTo", v8::String::kInternalizedString), SkipTo_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Sound", v8::String::kInternalizedString), t->GetFunction());

    }

    void SoundWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 2006 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 2006 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 2006 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 2006 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 2006 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::GetVolume(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theVolume = self->getVolume();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theVolume) ); return; };
    }

    void SoundWrap::SetVolume(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sound]" " function" "(number inVolume)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theVolume"")");
        double theVolume = args[1 -1]->NumberValue();

        self->setVolume(theVolume);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SoundWrap::Play(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number vol = 1.0, [number int] offsetX = 0, number pitch = 0, [number uint] fromMs = 0, [number int] lenMs = ENTIRE_LENGTH)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""vol"")");
        double vol = (args.Length()<1) ? 1.0 : args[1 -1]->NumberValue();;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""offsetX"")");
        long offsetX = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""pitch"")");
        double pitch = (args.Length()<3) ? 0.0 : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""fromMs"")");
        unsigned long fromMs = (args.Length()<4) ? 0 : args[4 -1]->Uint32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""lenMs"")");
        long lenMs = (args.Length()<5) ? -1 : args[5 -1]->Int32Value();;
        self->play(vol, offsetX, pitch, fromMs, lenMs);
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Start(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->start();
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Stop(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stop();
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Pause(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->pause();
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Resume(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->resume();
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::IsPaused(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool result = self->isPaused();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void SoundWrap::SetLooping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "Sound" " function" "(boolean loopingOn)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""loopingOn"")");
        bool loopingOn = args[1 -1]->BooleanValue();
        self->setLooping(loopingOn);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SoundWrap::IsLooping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool result = self->isLooping();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void SoundWrap::SetPitch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "Sound" " function" "(number pitchOffset)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""pitchOffset"")");
        double pitchOffset = args[1 -1]->NumberValue();
        self->setPitch(pitchOffset);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SoundWrap::ChangePitch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number targetOffset, [number int] msDuration, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""targetOffset"")");
        double targetOffset = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changePitch(targetOffset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changePitch(targetOffset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::SetOffsetX(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "Sound" " function" "([number int] offsetX)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""offsetX"")");
        long offsetX = args[1 -1]->Int32Value();
        self->setOffsetX(offsetX);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SoundWrap::ChangeOffsetX(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] targetOffset, [number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""targetOffset"")");
        long targetOffset = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changePitch(targetOffset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changePitch(targetOffset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::FadeOut(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] fadeMs, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""fadeMs"")");
        unsigned long fadeMs = args[1 -1]->Uint32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(fadeMs);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::FadeIn(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] fadeMs, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""fadeMs"")");
        unsigned long fadeMs = args[1 -1]->Uint32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(fadeMs);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::ChangeVolume(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number level, [number uint] fadeMs, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""level"")");
        double level = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""fadeMs"")");
        unsigned long fadeMs = args[2 -1]->Uint32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeVolume(level, fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->changeVolume(level, fadeMs);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SoundWrap::Skip(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "Sound" " function" "([number int] skipMilliseconds)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""skipMilliseconds"")");
        long skipMilliseconds = args[1 -1]->Int32Value();
        self->skip(skipMilliseconds);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SoundWrap::SkipTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "Sound" " function" "([number uint] timeMs)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""timeMs"")");
        unsigned long timeMs = args[1 -1]->Uint32Value();
        self->skipTo(timeMs);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void CleanupSoundScriptObject(v8::Persistent<v8::Object> &obj) { }

    Sound* New_Sound(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Sound_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 must be a string (filename)";
                v8::Isolate* isolate = v8::Isolate::GetCurrent();
                s_SavedError.Reset(isolate, v8::Exception::SyntaxError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
            };
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            Sound* snd = Sound::createSoundFromFile(filename);
            if (!snd)
            {
                s_HaveSavedError = true;
                {
                    std::ostringstream excpt_;
                    excpt_ << "could not create Sound from file ["<<filename<<"]";
                    v8::Isolate* isolate = v8::Isolate::GetCurrent();
                    s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
                };
                return 0;
            }
            else
            {
                return snd;
            }
        }
    }
#endif

    ;
    ;
    ;

    void FileManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        FileManagerWrap* objWrapper = new FileManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> FileManagerWrap::instance_;
    bool FileManagerWrap::instanced_ = false;

    v8::Local<v8::Object> FileManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    v8::Persistent<v8::FunctionTemplate> FileManagerWrap::constructorTpl_;

    void FileManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "FileManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> FindFirst_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FindFirst_Tpl =
            v8::FunctionTemplate::New(isolate, FindFirst, v8::Local<v8::Value>(), FindFirst_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "findFirst", v8::String::kInternalizedString), FindFirst_Tpl);
        v8::Local<v8::Signature> FindNext_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FindNext_Tpl =
            v8::FunctionTemplate::New(isolate, FindNext, v8::Local<v8::Value>(), FindNext_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "findNext", v8::String::kInternalizedString), FindNext_Tpl);
        v8::Local<v8::Signature> FindClose_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FindClose_Tpl =
            v8::FunctionTemplate::New(isolate, FindClose, v8::Local<v8::Value>(), FindClose_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "findClose", v8::String::kInternalizedString), FindClose_Tpl);
        v8::Local<v8::Signature> GetApplicationDataDirectory_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetApplicationDataDirectory_Tpl =
            v8::FunctionTemplate::New(isolate, GetApplicationDataDirectory, v8::Local<v8::Value>(), GetApplicationDataDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ApplicationDataDirectory", v8::String::kInternalizedString), GetApplicationDataDirectory_Tpl);
        v8::Local<v8::Signature> GetApplicationDirectory_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetApplicationDirectory_Tpl =
            v8::FunctionTemplate::New(isolate, GetApplicationDirectory, v8::Local<v8::Value>(), GetApplicationDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ApplicationDirectory", v8::String::kInternalizedString), GetApplicationDirectory_Tpl);
        v8::Local<v8::Signature> GetApplicationResourceDirectory_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetApplicationResourceDirectory_Tpl =
            v8::FunctionTemplate::New(isolate, GetApplicationResourceDirectory, v8::Local<v8::Value>(), GetApplicationResourceDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ApplicationResourceDirectory", v8::String::kInternalizedString), GetApplicationResourceDirectory_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "FileManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void FileManagerWrap::FindFirst(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "object" " function" "(string inFindName)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inFindName"")");
        v8::String::Utf8Value inFindName_Str(args[1 -1]->ToString());
        const char* inFindName = *inFindName_Str;;
        FindDataT* ioFindDataPtr = new FindDataT;
        bool found = OS::findFirst(inFindName, *ioFindDataPtr);
        v8::Local<v8::Object> jsFindData = v8_ObjectCreateEmpty(isolate, ioFindDataPtr);
        v8::Local<v8::Value> nodeName = v8::String::NewFromUtf8(isolate, ioFindDataPtr->nodeName);
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "nodeName", v8::String::kInternalizedString), nodeName);
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "isDirectory", v8::String::kInternalizedString), v8::Boolean::New(isolate, ioFindDataPtr->isDirectory));
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "found", v8::String::kInternalizedString), v8::Boolean::New(isolate, found));
        { args.GetReturnValue().Set( jsFindData ); return; };
    }
    void FileManagerWrap::FindNext(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "object" " function" "(object inFindData)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, jsFindData);
        FindDataT* ioFindDataPtr = static_cast<FindDataT*>(jsFindData->GetAlignedPointerFromInternalField(0));
        if (!ioFindDataPtr)
        {
            std::ostringstream excpt_;
            excpt_ << "findNext must only be called with the object returned by findFirst";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        bool found = OS::findNext(*ioFindDataPtr);
        v8::Local<v8::Value> nodeName = v8::String::NewFromUtf8(isolate, ioFindDataPtr->nodeName);
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "nodeName", v8::String::kInternalizedString), nodeName);
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "isDirectory", v8::String::kInternalizedString), v8::Boolean::New(isolate, ioFindDataPtr->isDirectory));
        jsFindData->Set(v8::String::NewFromUtf8(isolate, "found", v8::String::kInternalizedString), v8::Boolean::New(isolate, found));
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, found) ); return; };
    }
    void FileManagerWrap::FindClose(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(object inFindData)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, jsFindData);
        FindDataT* ioFindDataPtr = static_cast<FindDataT*>(jsFindData->GetAlignedPointerFromInternalField(0));
        if (!ioFindDataPtr)
        {
            std::ostringstream excpt_;
            excpt_ << "findClose must only be called with the object returned by findFirst";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        OS::findClose(*ioFindDataPtr);
        delete ioFindDataPtr;
        args.GetReturnValue().SetUndefined();
    }
    void FileManagerWrap::GetApplicationDataDirectory(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, OS::getApplicationDataDirectory()) ); return; };
    }
    void FileManagerWrap::GetApplicationDirectory(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, OS::getApplicationDirectory()) ); return; };
    }
    void FileManagerWrap::GetApplicationResourceDirectory(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, OS::getApplicationResourceDirectory()) ); return; };
    }

    static bool s_TimerManager_InNewFromCpp = false;

    void TimerManagerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = new TimerManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Persistent<v8::Object> TimerManagerWrap::instance_;
    bool TimerManagerWrap::instanced_ = false;

    v8::Local<v8::Object> TimerManagerWrap::GetScriptSingletonInstance(v8::Isolate* isolate)
    {
        v8::EscapableHandleScope scope(isolate);
        if (!instanced_)
        {
            v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
            v8::Local<v8::Object> instance = constructor->GetFunction()->NewInstance();
            instance_.Reset(isolate, instance);
            instanced_ = true;
        }
        v8::Local<v8::Object> inst_ = v8::Local<v8::Object>::New(isolate, instance_);
        return scope.Escape(inst_);
    }

    TimerManager* TimerManagerWrap::getSingletonInstance()
    {
        v8::Isolate* isolate = v8::Isolate::GetCurrent();
        v8::Local<v8::Object> val = GetScriptSingletonInstance(isolate)->ToObject();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(val);
        return dynamic_cast<TimerManager*>(objWrapper->cppPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> TimerManagerWrap::constructorTpl_;

    void TimerManagerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "TimerManager", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> StartTimer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartTimer_Tpl =
            v8::FunctionTemplate::New(isolate, StartTimer, v8::Local<v8::Value>(), StartTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startTimer", v8::String::kInternalizedString), StartTimer_Tpl);
        v8::Local<v8::Signature> CancelTimer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CancelTimer_Tpl =
            v8::FunctionTemplate::New(isolate, CancelTimer, v8::Local<v8::Value>(), CancelTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "cancelTimer", v8::String::kInternalizedString), CancelTimer_Tpl);
        v8::Local<v8::Signature> CancelAllTimers_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CancelAllTimers_Tpl =
            v8::FunctionTemplate::New(isolate, CancelAllTimers, v8::Local<v8::Value>(), CancelAllTimers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "cancelAllTimers", v8::String::kInternalizedString), CancelAllTimers_Tpl);
        v8::Local<v8::Signature> DelayTimer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DelayTimer_Tpl =
            v8::FunctionTemplate::New(isolate, DelayTimer, v8::Local<v8::Value>(), DelayTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "delayTimer", v8::String::kInternalizedString), DelayTimer_Tpl);
        v8::Local<v8::Signature> DelayTimerUntil_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DelayTimerUntil_Tpl =
            v8::FunctionTemplate::New(isolate, DelayTimerUntil, v8::Local<v8::Value>(), DelayTimerUntil_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "delayTimerUntil", v8::String::kInternalizedString), DelayTimerUntil_Tpl);
        v8::Local<v8::Signature> Pause_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Pause_Tpl =
            v8::FunctionTemplate::New(isolate, Pause, v8::Local<v8::Value>(), Pause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "pause", v8::String::kInternalizedString), Pause_Tpl);
        v8::Local<v8::Signature> Unpause_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Unpause_Tpl =
            v8::FunctionTemplate::New(isolate, Unpause, v8::Local<v8::Value>(), Unpause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unpause", v8::String::kInternalizedString), Unpause_Tpl);
        v8::Local<v8::Signature> IsPaused_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsPaused_Tpl =
            v8::FunctionTemplate::New(isolate, IsPaused, v8::Local<v8::Value>(), IsPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isPaused", v8::String::kInternalizedString), IsPaused_Tpl);
        v8::Local<v8::Signature> PauseTimer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PauseTimer_Tpl =
            v8::FunctionTemplate::New(isolate, PauseTimer, v8::Local<v8::Value>(), PauseTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "pauseTimer", v8::String::kInternalizedString), PauseTimer_Tpl);
        v8::Local<v8::Signature> UnpauseTimer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnpauseTimer_Tpl =
            v8::FunctionTemplate::New(isolate, UnpauseTimer, v8::Local<v8::Value>(), UnpauseTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unpauseTimer", v8::String::kInternalizedString), UnpauseTimer_Tpl);
        v8::Local<v8::Signature> IsTimerPaused_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsTimerPaused_Tpl =
            v8::FunctionTemplate::New(isolate, IsTimerPaused, v8::Local<v8::Value>(), IsTimerPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isTimerPaused", v8::String::kInternalizedString), IsTimerPaused_Tpl);
        v8::Local<v8::Signature> GetWhenTimerFiresNext_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWhenTimerFiresNext_Tpl =
            v8::FunctionTemplate::New(isolate, GetWhenTimerFiresNext, v8::Local<v8::Value>(), GetWhenTimerFiresNext_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getWhenTimerFiresNext", v8::String::kInternalizedString), GetWhenTimerFiresNext_Tpl);
        v8::Local<v8::Signature> GetMilliseconds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMilliseconds_Tpl =
            v8::FunctionTemplate::New(isolate, GetMilliseconds, v8::Local<v8::Value>(), GetMilliseconds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMilliseconds", v8::String::kInternalizedString), GetMilliseconds_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "TimerManager", v8::String::kInternalizedString), t->GetFunction());

    }

    void TimerManagerWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 2280 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 2280 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 2280 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 2280 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 2280 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::StartTimer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id, [number uint] delay, boolean oneShot = true)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""delay"")");
        unsigned long delay = args[2 -1]->Uint32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 3, "a boolean (""oneShot"")");
        bool oneShot = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        self->startTimer(id, delay, oneShot);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::CancelTimer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->cancelTimer(id);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::CancelAllTimers(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->cancelAllTimers();
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::DelayTimer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id, [number uint] delay)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""delay"")");
        unsigned long delay = args[2 -1]->Uint32Value();
        self->delayTimer(id, delay);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::DelayTimerUntil(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id, [number uint] msTime)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msTime"")");
        unsigned long msTime = args[2 -1]->Uint32Value();
        self->delayTimerUntil(id, msTime);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::Pause(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->pause();
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::Unpause(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->unpause();
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::IsPaused(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool isPaused = self->isPaused();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, isPaused) ); return; };
    }

    void TimerManagerWrap::PauseTimer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->pauseTimer(id);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::UnpauseTimer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->unpauseTimer(id);
        args.GetReturnValue().SetUndefined();
    }

    void TimerManagerWrap::IsTimerPaused(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        bool isPaused = self->isTimerPaused(id);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, isPaused) ); return; };
    }

    void TimerManagerWrap::GetWhenTimerFiresNext(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        uint32 when = self->getWhenTimerFiresNext(id);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, when) ); return; };
    }
    void TimerManagerWrap::GetMilliseconds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, OS::getMilliseconds()) ); return; };
    }

    TimerManager* New_TimerManager(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_TimerManager_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return TimerManager::getSingletonInstance();
    }

    float customEasing0(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(0, ut, b, c, ud);
    }

    float customEasing1(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(1, ut, b, c, ud);
    }

    float customEasing2(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(2, ut, b, c, ud);
    }

    float customEasing3(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(3, ut, b, c, ud);
    }

    float customEasing4(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(4, ut, b, c, ud);
    }

    float customEasing5(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(5, ut, b, c, ud);
    }

    float customEasing6(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(6, ut, b, c, ud);
    }

    float customEasing7(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(7, ut, b, c, ud);
    }

    float customEasing8(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(8, ut, b, c, ud);
    }

    float customEasing9(ms_delta ut, float b, float c, ms_delta ud)
    {
        return CallScriptEasingFunc(9, ut, b, c, ud);
    }

    bool s_IAnimationHelper_InNewFromCpp = false;

    void IAnimationHelperWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        IAnimationHelperWrap* objWrapper = new IAnimationHelperWrap(args);
        objWrapper->Wrap(args.This());
        IAnimationHelper* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mIAnimationHelperScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> IAnimationHelperWrap::NewFromCpp(v8::Isolate* isolate, IAnimationHelper* cppObj)
    {
        s_IAnimationHelper_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        IAnimationHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(instance);

        cppObj->mIAnimationHelperScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_IAnimationHelper_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> IAnimationHelperWrap::constructorTpl_;

    void IAnimationHelperWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "IAnimationHelper", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        target->Set(v8::String::NewFromUtf8(isolate, "IAnimationHelper", v8::String::kInternalizedString), t->GetFunction());
    }

    void CleanupIAnimationHelperScriptObject(v8::Persistent<v8::Object> &obj) { }

    static bool s_Animated_InNewFromCpp = false;

    void AnimatedWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = new AnimatedWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> AnimatedWrap::NewFromCpp(v8::Isolate* isolate, Animated* cppObj)
    {
        s_Animated_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(instance);

        cppObj->mAnimatedScriptObj.Reset(isolate, obj);
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Animated_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> AnimatedWrap::constructorTpl_;

    void AnimatedWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Animated", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(isolate, GetBoundingBox, v8::Local<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""BoundingBox", v8::String::kInternalizedString), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotatedBounds, v8::Local<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RotatedBounds", v8::String::kInternalizedString), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, GetLocation, v8::Local<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Location", v8::String::kInternalizedString), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, SetLocation, v8::Local<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Location", v8::String::kInternalizedString), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpeed, v8::Local<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Speed", v8::String::kInternalizedString), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpeed, v8::Local<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Speed", v8::String::kInternalizedString), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, GetVelocity, v8::Local<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Velocity", v8::String::kInternalizedString), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocity, v8::Local<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Velocity", v8::String::kInternalizedString), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, SetWidth, v8::Local<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Width", v8::String::kInternalizedString), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, SetHeight, v8::Local<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Height", v8::String::kInternalizedString), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotation, v8::Local<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Rotation", v8::String::kInternalizedString), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, SetRotation, v8::Local<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Rotation", v8::String::kInternalizedString), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, GetCenterOffset, v8::Local<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CenterOffset", v8::String::kInternalizedString), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, SetCenterOffset, v8::Local<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CenterOffset", v8::String::kInternalizedString), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpin, v8::Local<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Spin", v8::String::kInternalizedString), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpin, v8::Local<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Spin", v8::String::kInternalizedString), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(isolate, GetMass, v8::Local<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Mass", v8::String::kInternalizedString), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(isolate, SetMass, v8::Local<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Mass", v8::String::kInternalizedString), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetMoveFriction, v8::Local<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MoveFriction", v8::String::kInternalizedString), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetMoveFriction, v8::Local<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MoveFriction", v8::String::kInternalizedString), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpinFriction, v8::Local<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpinFriction", v8::String::kInternalizedString), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpinFriction, v8::Local<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpinFriction", v8::String::kInternalizedString), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSizeFriction, v8::Local<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SizeFriction", v8::String::kInternalizedString), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSizeFriction, v8::Local<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SizeFriction", v8::String::kInternalizedString), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(isolate, Move, v8::Local<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "move", v8::String::kInternalizedString), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(isolate, MoveTo, v8::Local<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveTo", v8::String::kInternalizedString), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocityInRadians, v8::Local<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setVelocityInRadians", v8::String::kInternalizedString), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, GetMovementDirectionInRadians, v8::Local<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMovementDirectionInRadians", v8::String::kInternalizedString), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(isolate, StopMoving, v8::Local<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopMoving", v8::String::kInternalizedString), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(isolate, Accelerate, v8::Local<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerate", v8::String::kInternalizedString), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(isolate, AccelerateTo, v8::Local<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerateTo", v8::String::kInternalizedString), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(isolate, SetSize, v8::Local<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSize", v8::String::kInternalizedString), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(isolate, Grow, v8::Local<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "grow", v8::String::kInternalizedString), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(isolate, Stretch, v8::Local<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stretch", v8::String::kInternalizedString), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StartGrowing, v8::Local<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startGrowing", v8::String::kInternalizedString), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StopGrowing, v8::Local<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopGrowing", v8::String::kInternalizedString), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StartStretching, v8::Local<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startStretching", v8::String::kInternalizedString), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StopStretching, v8::Local<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopStretching", v8::String::kInternalizedString), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(isolate, Resize, v8::Local<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resize", v8::String::kInternalizedString), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(isolate, ResizeTo, v8::Local<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resizeTo", v8::String::kInternalizedString), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(isolate, Rotate, v8::Local<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotate", v8::String::kInternalizedString), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(isolate, RotateTo, v8::Local<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotateTo", v8::String::kInternalizedString), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(isolate, StopSpinning, v8::Local<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopSpinning", v8::String::kInternalizedString), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenter, v8::Local<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenter", v8::String::kInternalizedString), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenterTo, v8::Local<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenterTo", v8::String::kInternalizedString), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(isolate, Wait, v8::Local<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "wait", v8::String::kInternalizedString), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetFriction, v8::Local<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFriction", v8::String::kInternalizedString), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyForce, v8::Local<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyForce", v8::String::kInternalizedString), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyTorque, v8::Local<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyTorque", v8::String::kInternalizedString), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(isolate, StopAllForces, v8::Local<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAllForces", v8::String::kInternalizedString), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, AddAnimationHelper, v8::Local<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addAnimationHelper", v8::String::kInternalizedString), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAnimationHelper, v8::Local<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAnimationHelper", v8::String::kInternalizedString), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(isolate, ClearAnimationHelpers, v8::Local<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clearAnimationHelpers", v8::String::kInternalizedString), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> Animate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Animate_Tpl =
            v8::FunctionTemplate::New(isolate, Animate, v8::Local<v8::Value>(), Animate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "animate", v8::String::kInternalizedString), Animate_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "Animated", v8::String::kInternalizedString), t->GetFunction());

    }

    void AnimatedWrap::GetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, theLocation) ); return; };
    }

    void AnimatedWrap::SetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([object Point] inLocation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(isolate, args[1 -1]);

        self->setLocation(theLocation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpeed = self->getSpeed();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpeed) ); return; };
    }

    void AnimatedWrap::SetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inSpeed)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theWidth) ); return; };
    }

    void AnimatedWrap::SetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inWidth)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theHeight) ); return; };
    }

    void AnimatedWrap::SetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inHeight)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theRotation = self->getRotation();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRotation) ); return; };
    }

    void AnimatedWrap::SetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inRotation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theCenterOffset) ); return; };
    }

    void AnimatedWrap::SetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([object Offset] inCenterOffset)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(isolate, args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpin = self->getSpin();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpin) ); return; };
    }

    void AnimatedWrap::SetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inSpin)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMass = self->getMass();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMass) ); return; };
    }

    void AnimatedWrap::SetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inMass)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMoveFriction) ); return; };
    }

    void AnimatedWrap::SetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inMoveFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpinFriction) ); return; };
    }

    void AnimatedWrap::SetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inSpinFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSizeFriction) ); return; };
    }

    void AnimatedWrap::SetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number inSizeFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetBoundingBox(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void AnimatedWrap::GetRotatedBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void AnimatedWrap::Move(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            delta = v8_ValueToOffset(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::MoveTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(isolate, args[0]))
        {
            where = v8_ValueToPoint(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::SetVelocityInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number speed, number direction)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetMovementDirectionInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        { args.GetReturnValue().Set( v8::Number::New(isolate, dir) ); return; };
    }

    void AnimatedWrap::SetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "({[object Vector] deltaPerSec|number deltaXPerSec, number deltaYPerSec})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(isolate, args[0]))
        {
            deltaPerSec = v8_ValueToVector(isolate, args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::GetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, theVelocity) ); return; };
    }

    void AnimatedWrap::StopMoving(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopMoving();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Accelerate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::AccelerateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::SetSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number width, number height)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::Grow(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Stretch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StartGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number amountPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StopGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopGrowing();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StartStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StopStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopStretching();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Resize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::ResizeTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Rotate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::RotateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StopSpinning(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopSpinning();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::ChangeCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::ChangeCenterTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Wait(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([number int] msDuration)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::SetFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number frictionCoefficient)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void AnimatedWrap::ApplyForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::ApplyTorque(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::StopAllForces(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAllForces();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::AddAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        self->mAnimatedScriptObj.Reset(isolate, args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 2877 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 2877 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 2877 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 2877 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 2877 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::RemoveAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::ClearAnimationHelpers(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clearAnimationHelpers();
        args.GetReturnValue().SetUndefined();
    }

    void AnimatedWrap::Animate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([number int] msElapsed)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msElapsed"")");
        long msElapsed = args[1 -1]->Int32Value();
        bool result = self->animate(msElapsed);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, result) ); return; };
    }

    void CleanupAnimatedScriptObject(v8::Persistent<v8::Object> &obj) { }

    Animated* New_Animated(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Animated_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new Animated();
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    static bool s_cpArbiter_InNewFromCpp = false;

    void cpArbiterWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = new cpArbiterWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> cpArbiterWrap::NewFromCpp(v8::Isolate* isolate, cpArbiter* cppObj)
    {
        s_cpArbiter_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(instance);

        ;
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_cpArbiter_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> cpArbiterWrap::constructorTpl_;

    void cpArbiterWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "CpArbiter", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> IsFirstContact_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsFirstContact_Tpl =
            v8::FunctionTemplate::New(isolate, IsFirstContact, v8::Local<v8::Value>(), IsFirstContact_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isFirstContact", v8::String::kInternalizedString), IsFirstContact_Tpl);
        v8::Local<v8::Signature> GetCount_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCount_Tpl =
            v8::FunctionTemplate::New(isolate, GetCount, v8::Local<v8::Value>(), GetCount_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Count", v8::String::kInternalizedString), GetCount_Tpl);
        v8::Local<v8::Signature> GetNormal_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNormal_Tpl =
            v8::FunctionTemplate::New(isolate, GetNormal, v8::Local<v8::Value>(), GetNormal_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Normal", v8::String::kInternalizedString), GetNormal_Tpl);
        v8::Local<v8::Signature> GetPointA_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetPointA_Tpl =
            v8::FunctionTemplate::New(isolate, GetPointA, v8::Local<v8::Value>(), GetPointA_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""PointA", v8::String::kInternalizedString), GetPointA_Tpl);
        v8::Local<v8::Signature> GetPointB_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetPointB_Tpl =
            v8::FunctionTemplate::New(isolate, GetPointB, v8::Local<v8::Value>(), GetPointB_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""PointB", v8::String::kInternalizedString), GetPointB_Tpl);
        v8::Local<v8::Signature> GetDepth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetDepth_Tpl =
            v8::FunctionTemplate::New(isolate, GetDepth, v8::Local<v8::Value>(), GetDepth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Depth", v8::String::kInternalizedString), GetDepth_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "CpArbiter", v8::String::kInternalizedString), t->GetFunction());

    }

    void cpArbiterWrap::IsFirstContact(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "true if this is the first moment of contact between the objects, false if part of an ongoing collison") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpBool isFirst = cpArbiterIsFirstContact(self);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, isFirst) ); return; };
    }

    void cpArbiterWrap::GetCount(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theCount = cpArbiterGetCount(self);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theCount) ); return; };
    }

    void cpArbiterWrap::GetNormal(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        cpVect nv = cpArbiterGetNormal(self);
        pdg::Vector theNormal(nv.x, nv.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, theNormal) ); return; };
    }

    void cpArbiterWrap::GetPointA(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([number int] i)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpVect pt = cpArbiterGetPointA(self, i);
        pdg::Point thePointA(pt.x, pt.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, thePointA) ); return; };
    }

    void cpArbiterWrap::GetPointB(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([number int] i)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpVect pt = cpArbiterGetPointB(self, i);
        pdg::Point thePointB(pt.x, pt.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, thePointB) ); return; };
    }

    void cpArbiterWrap::GetDepth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([number int] i)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpFloat theDepth = cpArbiterGetDepth(self, i);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theDepth) ); return; };
    }

    cpArbiter* New_cpArbiter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_cpArbiter_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        s_HaveSavedError = true;
        {
            std::ostringstream excpt_;
            excpt_ << "CpArbiter cannot be created directly, it is only returned from certain Sprite calls.";
            v8::Isolate* isolate = v8::Isolate::GetCurrent();
            s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        };
        return 0;
    }

    static bool s_cpConstraint_InNewFromCpp = false;

    void cpConstraintWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = new cpConstraintWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> cpConstraintWrap::NewFromCpp(v8::Isolate* isolate, cpConstraint* cppObj)
    {
        s_cpConstraint_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(instance);

        ;
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_cpConstraint_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> cpConstraintWrap::constructorTpl_;

    void cpConstraintWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "CpConstraint", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> GetType_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetType_Tpl =
            v8::FunctionTemplate::New(isolate, GetType, v8::Local<v8::Value>(), GetType_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Type", v8::String::kInternalizedString), GetType_Tpl);
        v8::Local<v8::Signature> ActivateBodies_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ActivateBodies_Tpl =
            v8::FunctionTemplate::New(isolate, ActivateBodies, v8::Local<v8::Value>(), ActivateBodies_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "activateBodies", v8::String::kInternalizedString), ActivateBodies_Tpl);
        v8::Local<v8::Signature> GetImpulse_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetImpulse_Tpl =
            v8::FunctionTemplate::New(isolate, GetImpulse, v8::Local<v8::Value>(), GetImpulse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Impulse", v8::String::kInternalizedString), GetImpulse_Tpl);
        v8::Local<v8::Signature> GetMaxForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMaxForce_Tpl =
            v8::FunctionTemplate::New(isolate, GetMaxForce, v8::Local<v8::Value>(), GetMaxForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MaxForce", v8::String::kInternalizedString), GetMaxForce_Tpl);
        v8::Local<v8::Signature> SetMaxForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMaxForce_Tpl =
            v8::FunctionTemplate::New(isolate, SetMaxForce, v8::Local<v8::Value>(), SetMaxForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MaxForce", v8::String::kInternalizedString), SetMaxForce_Tpl);
        v8::Local<v8::Signature> GetErrorBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetErrorBias_Tpl =
            v8::FunctionTemplate::New(isolate, GetErrorBias, v8::Local<v8::Value>(), GetErrorBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""ErrorBias", v8::String::kInternalizedString), GetErrorBias_Tpl);
        v8::Local<v8::Signature> SetErrorBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetErrorBias_Tpl =
            v8::FunctionTemplate::New(isolate, SetErrorBias, v8::Local<v8::Value>(), SetErrorBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""ErrorBias", v8::String::kInternalizedString), SetErrorBias_Tpl);
        v8::Local<v8::Signature> GetMaxBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMaxBias_Tpl =
            v8::FunctionTemplate::New(isolate, GetMaxBias, v8::Local<v8::Value>(), GetMaxBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MaxBias", v8::String::kInternalizedString), GetMaxBias_Tpl);
        v8::Local<v8::Signature> SetMaxBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMaxBias_Tpl =
            v8::FunctionTemplate::New(isolate, SetMaxBias, v8::Local<v8::Value>(), SetMaxBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MaxBias", v8::String::kInternalizedString), SetMaxBias_Tpl);
        v8::Local<v8::Signature> GetSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSprite_Tpl =
            v8::FunctionTemplate::New(isolate, GetSprite, v8::Local<v8::Value>(), GetSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Sprite", v8::String::kInternalizedString), GetSprite_Tpl);
        v8::Local<v8::Signature> GetOtherSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOtherSprite_Tpl =
            v8::FunctionTemplate::New(isolate, GetOtherSprite, v8::Local<v8::Value>(), GetOtherSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""OtherSprite", v8::String::kInternalizedString), GetOtherSprite_Tpl);
        v8::Local<v8::Signature> GetAnchor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetAnchor_Tpl =
            v8::FunctionTemplate::New(isolate, GetAnchor, v8::Local<v8::Value>(), GetAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Anchor", v8::String::kInternalizedString), GetAnchor_Tpl);
        v8::Local<v8::Signature> SetAnchor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetAnchor_Tpl =
            v8::FunctionTemplate::New(isolate, SetAnchor, v8::Local<v8::Value>(), SetAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Anchor", v8::String::kInternalizedString), SetAnchor_Tpl);
        v8::Local<v8::Signature> GetOtherAnchor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOtherAnchor_Tpl =
            v8::FunctionTemplate::New(isolate, GetOtherAnchor, v8::Local<v8::Value>(), GetOtherAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""OtherAnchor", v8::String::kInternalizedString), GetOtherAnchor_Tpl);
        v8::Local<v8::Signature> SetOtherAnchor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOtherAnchor_Tpl =
            v8::FunctionTemplate::New(isolate, SetOtherAnchor, v8::Local<v8::Value>(), SetOtherAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""OtherAnchor", v8::String::kInternalizedString), SetOtherAnchor_Tpl);
        v8::Local<v8::Signature> GetPinDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetPinDist_Tpl =
            v8::FunctionTemplate::New(isolate, GetPinDist, v8::Local<v8::Value>(), GetPinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""PinDist", v8::String::kInternalizedString), GetPinDist_Tpl);
        v8::Local<v8::Signature> SetPinDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetPinDist_Tpl =
            v8::FunctionTemplate::New(isolate, SetPinDist, v8::Local<v8::Value>(), SetPinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""PinDist", v8::String::kInternalizedString), SetPinDist_Tpl);
        v8::Local<v8::Signature> GetSpringStiffness_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpringStiffness_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpringStiffness, v8::Local<v8::Value>(), GetSpringStiffness_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpringStiffness", v8::String::kInternalizedString), GetSpringStiffness_Tpl);
        v8::Local<v8::Signature> SetSpringStiffness_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpringStiffness_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpringStiffness, v8::Local<v8::Value>(), SetSpringStiffness_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpringStiffness", v8::String::kInternalizedString), SetSpringStiffness_Tpl);
        v8::Local<v8::Signature> GetSpringDamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpringDamping_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpringDamping, v8::Local<v8::Value>(), GetSpringDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpringDamping", v8::String::kInternalizedString), GetSpringDamping_Tpl);
        v8::Local<v8::Signature> SetSpringDamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpringDamping_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpringDamping, v8::Local<v8::Value>(), SetSpringDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpringDamping", v8::String::kInternalizedString), SetSpringDamping_Tpl);
        v8::Local<v8::Signature> GetSlideMinDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSlideMinDist_Tpl =
            v8::FunctionTemplate::New(isolate, GetSlideMinDist, v8::Local<v8::Value>(), GetSlideMinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SlideMinDist", v8::String::kInternalizedString), GetSlideMinDist_Tpl);
        v8::Local<v8::Signature> SetSlideMinDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSlideMinDist_Tpl =
            v8::FunctionTemplate::New(isolate, SetSlideMinDist, v8::Local<v8::Value>(), SetSlideMinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SlideMinDist", v8::String::kInternalizedString), SetSlideMinDist_Tpl);
        v8::Local<v8::Signature> GetSlideMaxDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSlideMaxDist_Tpl =
            v8::FunctionTemplate::New(isolate, GetSlideMaxDist, v8::Local<v8::Value>(), GetSlideMaxDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SlideMaxDist", v8::String::kInternalizedString), GetSlideMaxDist_Tpl);
        v8::Local<v8::Signature> SetSlideMaxDist_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSlideMaxDist_Tpl =
            v8::FunctionTemplate::New(isolate, SetSlideMaxDist, v8::Local<v8::Value>(), SetSlideMaxDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SlideMaxDist", v8::String::kInternalizedString), SetSlideMaxDist_Tpl);
        v8::Local<v8::Signature> GetGrooveStart_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetGrooveStart_Tpl =
            v8::FunctionTemplate::New(isolate, GetGrooveStart, v8::Local<v8::Value>(), GetGrooveStart_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""GrooveStart", v8::String::kInternalizedString), GetGrooveStart_Tpl);
        v8::Local<v8::Signature> SetGrooveStart_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGrooveStart_Tpl =
            v8::FunctionTemplate::New(isolate, SetGrooveStart, v8::Local<v8::Value>(), SetGrooveStart_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""GrooveStart", v8::String::kInternalizedString), SetGrooveStart_Tpl);
        v8::Local<v8::Signature> GetGrooveEnd_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetGrooveEnd_Tpl =
            v8::FunctionTemplate::New(isolate, GetGrooveEnd, v8::Local<v8::Value>(), GetGrooveEnd_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""GrooveEnd", v8::String::kInternalizedString), GetGrooveEnd_Tpl);
        v8::Local<v8::Signature> SetGrooveEnd_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGrooveEnd_Tpl =
            v8::FunctionTemplate::New(isolate, SetGrooveEnd, v8::Local<v8::Value>(), SetGrooveEnd_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""GrooveEnd", v8::String::kInternalizedString), SetGrooveEnd_Tpl);
        v8::Local<v8::Signature> GetSpringRestLength_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpringRestLength_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpringRestLength, v8::Local<v8::Value>(), GetSpringRestLength_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpringRestLength", v8::String::kInternalizedString), GetSpringRestLength_Tpl);
        v8::Local<v8::Signature> SetSpringRestLength_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpringRestLength_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpringRestLength, v8::Local<v8::Value>(), SetSpringRestLength_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpringRestLength", v8::String::kInternalizedString), SetSpringRestLength_Tpl);
        v8::Local<v8::Signature> GetRotarySpringRestAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotarySpringRestAngle_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotarySpringRestAngle, v8::Local<v8::Value>(), GetRotarySpringRestAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RotarySpringRestAngle", v8::String::kInternalizedString), GetRotarySpringRestAngle_Tpl);
        v8::Local<v8::Signature> SetRotarySpringRestAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRotarySpringRestAngle_Tpl =
            v8::FunctionTemplate::New(isolate, SetRotarySpringRestAngle, v8::Local<v8::Value>(), SetRotarySpringRestAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""RotarySpringRestAngle", v8::String::kInternalizedString), SetRotarySpringRestAngle_Tpl);
        v8::Local<v8::Signature> GetMinAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMinAngle_Tpl =
            v8::FunctionTemplate::New(isolate, GetMinAngle, v8::Local<v8::Value>(), GetMinAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MinAngle", v8::String::kInternalizedString), GetMinAngle_Tpl);
        v8::Local<v8::Signature> SetMinAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMinAngle_Tpl =
            v8::FunctionTemplate::New(isolate, SetMinAngle, v8::Local<v8::Value>(), SetMinAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MinAngle", v8::String::kInternalizedString), SetMinAngle_Tpl);
        v8::Local<v8::Signature> GetMaxAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMaxAngle_Tpl =
            v8::FunctionTemplate::New(isolate, GetMaxAngle, v8::Local<v8::Value>(), GetMaxAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MaxAngle", v8::String::kInternalizedString), GetMaxAngle_Tpl);
        v8::Local<v8::Signature> SetMaxAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMaxAngle_Tpl =
            v8::FunctionTemplate::New(isolate, SetMaxAngle, v8::Local<v8::Value>(), SetMaxAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MaxAngle", v8::String::kInternalizedString), SetMaxAngle_Tpl);
        v8::Local<v8::Signature> GetRatchetAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRatchetAngle_Tpl =
            v8::FunctionTemplate::New(isolate, GetRatchetAngle, v8::Local<v8::Value>(), GetRatchetAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RatchetAngle", v8::String::kInternalizedString), GetRatchetAngle_Tpl);
        v8::Local<v8::Signature> SetRatchetAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRatchetAngle_Tpl =
            v8::FunctionTemplate::New(isolate, SetRatchetAngle, v8::Local<v8::Value>(), SetRatchetAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""RatchetAngle", v8::String::kInternalizedString), SetRatchetAngle_Tpl);
        v8::Local<v8::Signature> GetRatchetPhase_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRatchetPhase_Tpl =
            v8::FunctionTemplate::New(isolate, GetRatchetPhase, v8::Local<v8::Value>(), GetRatchetPhase_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RatchetPhase", v8::String::kInternalizedString), GetRatchetPhase_Tpl);
        v8::Local<v8::Signature> SetRatchetPhase_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRatchetPhase_Tpl =
            v8::FunctionTemplate::New(isolate, SetRatchetPhase, v8::Local<v8::Value>(), SetRatchetPhase_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""RatchetPhase", v8::String::kInternalizedString), SetRatchetPhase_Tpl);
        v8::Local<v8::Signature> GetRatchetInterval_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRatchetInterval_Tpl =
            v8::FunctionTemplate::New(isolate, GetRatchetInterval, v8::Local<v8::Value>(), GetRatchetInterval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RatchetInterval", v8::String::kInternalizedString), GetRatchetInterval_Tpl);
        v8::Local<v8::Signature> SetRatchetInterval_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRatchetInterval_Tpl =
            v8::FunctionTemplate::New(isolate, SetRatchetInterval, v8::Local<v8::Value>(), SetRatchetInterval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""RatchetInterval", v8::String::kInternalizedString), SetRatchetInterval_Tpl);
        v8::Local<v8::Signature> GetGearRatio_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetGearRatio_Tpl =
            v8::FunctionTemplate::New(isolate, GetGearRatio, v8::Local<v8::Value>(), GetGearRatio_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""GearRatio", v8::String::kInternalizedString), GetGearRatio_Tpl);
        v8::Local<v8::Signature> SetGearRatio_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGearRatio_Tpl =
            v8::FunctionTemplate::New(isolate, SetGearRatio, v8::Local<v8::Value>(), SetGearRatio_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""GearRatio", v8::String::kInternalizedString), SetGearRatio_Tpl);
        v8::Local<v8::Signature> GetGearInitialAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetGearInitialAngle_Tpl =
            v8::FunctionTemplate::New(isolate, GetGearInitialAngle, v8::Local<v8::Value>(), GetGearInitialAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""GearInitialAngle", v8::String::kInternalizedString), GetGearInitialAngle_Tpl);
        v8::Local<v8::Signature> SetGearInitialAngle_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGearInitialAngle_Tpl =
            v8::FunctionTemplate::New(isolate, SetGearInitialAngle, v8::Local<v8::Value>(), SetGearInitialAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""GearInitialAngle", v8::String::kInternalizedString), SetGearInitialAngle_Tpl);
        v8::Local<v8::Signature> GetMotorSpinRate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMotorSpinRate_Tpl =
            v8::FunctionTemplate::New(isolate, GetMotorSpinRate, v8::Local<v8::Value>(), GetMotorSpinRate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MotorSpinRate", v8::String::kInternalizedString), GetMotorSpinRate_Tpl);
        v8::Local<v8::Signature> SetMotorSpinRate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMotorSpinRate_Tpl =
            v8::FunctionTemplate::New(isolate, SetMotorSpinRate, v8::Local<v8::Value>(), SetMotorSpinRate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MotorSpinRate", v8::String::kInternalizedString), SetMotorSpinRate_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "CpConstraint", v8::String::kInternalizedString), t->GetFunction());

    }

    void cpConstraintWrap::GetType(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "string" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        const char* theType = (const char*)cpConstraintGetUserData(self);
        { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, theType) ); return; };
    };

    void cpConstraintWrap::GetImpulse(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theImpulse = cpConstraintGetImpulse(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theImpulse) ); return; };
    }

    void cpConstraintWrap::GetMaxForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMaxForce = cpConstraintGetMaxForce(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMaxForce) ); return; };
    }

    void cpConstraintWrap::SetMaxForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inMaxForce)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMaxForce"")");
        double theMaxForce = args[1 -1]->NumberValue();

        cpConstraintSetMaxForce(self, theMaxForce);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetErrorBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theErrorBias = cpConstraintGetErrorBias(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theErrorBias) ); return; };
    }

    void cpConstraintWrap::SetErrorBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inErrorBias)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theErrorBias"")");
        double theErrorBias = args[1 -1]->NumberValue();

        cpConstraintSetErrorBias(self, theErrorBias);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetMaxBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMaxBias = cpConstraintGetMaxBias(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMaxBias) ); return; };
    }

    void cpConstraintWrap::SetMaxBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inMaxBias)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMaxBias"")");
        double theMaxBias = args[1 -1]->NumberValue();

        cpConstraintSetMaxBias(self, theMaxBias);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::ActivateBodies(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpConstraintActivateBodies(self);
        args.GetReturnValue().SetUndefined();
    }

    void cpConstraintWrap::GetSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpBody* body = cpConstraintGetBodyA(self);
        Sprite* sprite = (Sprite*) cpBodyGetUserData(body);
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void cpConstraintWrap::GetOtherSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpBody* body = cpConstraintGetBodyB(self);
        Sprite* otherSprite = (Sprite*) cpBodyGetUserData(body);
        if (!otherSprite) args.GetReturnValue().SetNull();
        if (otherSprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, otherSprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, otherSprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void cpConstraintWrap::GetAnchor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        cpVect anchor;
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            anchor = cpPinJointGetAnchorA(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            anchor = cpSlideJointGetAnchorA(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            anchor = cpPivotJointGetAnchorA(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            anchor = cpDampedSpringGetAnchorA(self);
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
        pdg::Offset theAnchor(anchor.x, anchor.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theAnchor) ); return; };
    }

    void cpConstraintWrap::SetAnchor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "([object Offset] inAnchor)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theAnchor = v8_ValueToOffset(isolate, args[1 -1]);

        cpVect anchor = cpv(theAnchor.x, theAnchor.y);
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            cpPinJointSetAnchorA(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            cpSlideJointSetAnchorA(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            cpPivotJointSetAnchorA(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetAnchorA(self, anchor);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setAnchor() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetOtherAnchor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        cpVect anchor;
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            anchor = cpPinJointGetAnchorB(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            anchor = cpSlideJointGetAnchorB(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            anchor = cpPivotJointGetAnchorB(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") == 0)
        {
            anchor = cpGrooveJointGetAnchorB(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            anchor = cpDampedSpringGetAnchorB(self);
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        }
        pdg::Offset theOtherAnchor(anchor.x, anchor.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theOtherAnchor) ); return; };
    }

    void cpConstraintWrap::SetOtherAnchor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "([object Offset] inOtherAnchor)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theOtherAnchor = v8_ValueToOffset(isolate, args[1 -1]);

        cpVect anchor = cpv(theOtherAnchor.x, theOtherAnchor.y);
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            cpPinJointSetAnchorB(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            cpSlideJointSetAnchorB(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            cpPivotJointSetAnchorB(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") == 0)
        {
            cpGrooveJointSetAnchorB(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetAnchorB(self, anchor);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setOtherAnchor() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetPinDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat thePinDist = cpPinJointGetDist(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, thePinDist) ); return; };
    }

    void cpConstraintWrap::SetPinDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inPinDist)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""thePinDist"")");
        double thePinDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "PinDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpPinJointSetDist(self, thePinDist);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetSlideMinDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theSlideMinDist = cpSlideJointGetMin(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSlideMinDist) ); return; };
    }

    void cpConstraintWrap::SetSlideMinDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inSlideMinDist)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSlideMinDist"")");
        double theSlideMinDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SlideMinDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpSlideJointSetMin(self, theSlideMinDist);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetSlideMaxDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theSlideMaxDist = cpSlideJointGetMax(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSlideMaxDist) ); return; };
    }

    void cpConstraintWrap::SetSlideMaxDist(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inSlideMaxDist)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSlideMaxDist"")");
        double theSlideMaxDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SlideMaxDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpSlideJointSetMax(self, theSlideMaxDist);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetGrooveStart(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpVect v = cpGrooveJointGetGrooveA(self);
        pdg::Offset theGrooveStart(v.x, v.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theGrooveStart) ); return; };
    }

    void cpConstraintWrap::SetGrooveStart(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "([object Offset] inGrooveStart)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theGrooveStart = v8_ValueToOffset(isolate, args[1 -1]);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GrooveStart" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpGrooveJointSetGrooveA(self, cpv(theGrooveStart.x, theGrooveStart.y));
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetGrooveEnd(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpVect v = cpGrooveJointGetGrooveB(self);
        pdg::Offset theGrooveEnd(v.x, v.y);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theGrooveEnd) ); return; };
    }

    void cpConstraintWrap::SetGrooveEnd(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "([object Offset] inGrooveEnd)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theGrooveEnd = v8_ValueToOffset(isolate, args[1 -1]);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GrooveEnd" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpGrooveJointSetGrooveB(self, cpv(theGrooveEnd.x, theGrooveEnd.y));
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetSpringRestLength(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theSpringRestLength = cpDampedSpringGetRestLength(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpringRestLength) ); return; };
    }

    void cpConstraintWrap::SetSpringRestLength(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inSpringRestLength)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpringRestLength"")");
        double theSpringRestLength = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SpringRestLength" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpDampedSpringSetRestLength(self, theSpringRestLength);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetRotarySpringRestAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theRotarySpringRestAngle = cpDampedRotarySpringGetRestAngle(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRotarySpringRestAngle) ); return; };
    }

    void cpConstraintWrap::SetRotarySpringRestAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inRotarySpringRestAngle)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRotarySpringRestAngle"")");
        double theRotarySpringRestAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RotarySpringRestAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpDampedRotarySpringSetRestAngle(self, theRotarySpringRestAngle);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetMinAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theMinAngle = cpRotaryLimitJointGetMin(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMinAngle) ); return; };
    }

    void cpConstraintWrap::SetMinAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inMinAngle)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMinAngle"")");
        double theMinAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MinAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpRotaryLimitJointSetMin(self, theMinAngle);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetMaxAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theMaxAngle = cpRotaryLimitJointGetMax(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMaxAngle) ); return; };
    }

    void cpConstraintWrap::SetMaxAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inMaxAngle)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMaxAngle"")");
        double theMaxAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MaxAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpRotaryLimitJointSetMax(self, theMaxAngle);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetRatchetAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theRatchetAngle = cpRatchetJointGetAngle(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRatchetAngle) ); return; };
    }

    void cpConstraintWrap::SetRatchetAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inRatchetAngle)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRatchetAngle"")");
        double theRatchetAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetAngle(self, theRatchetAngle);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetRatchetPhase(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theRatchetPhase = cpRatchetJointGetPhase(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRatchetPhase) ); return; };
    }

    void cpConstraintWrap::SetRatchetPhase(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inRatchetPhase)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRatchetPhase"")");
        double theRatchetPhase = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetPhase" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetPhase(self, theRatchetPhase);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetRatchetInterval(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theRatchetInterval = cpRatchetJointGetRatchet(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRatchetInterval) ); return; };
    }

    void cpConstraintWrap::SetRatchetInterval(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inRatchetInterval)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRatchetInterval"")");
        double theRatchetInterval = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetInterval" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetRatchet(self, theRatchetInterval);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetGearRatio(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theGearRatio = cpGearJointGetRatio(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theGearRatio) ); return; };
    }

    void cpConstraintWrap::SetGearRatio(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inGearRatio)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theGearRatio"")");
        double theGearRatio = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GearRatio" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpGearJointSetRatio(self, theGearRatio);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetGearInitialAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theGearInitialAngle = cpGearJointGetPhase(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theGearInitialAngle) ); return; };
    }

    void cpConstraintWrap::SetGearInitialAngle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inGearInitialAngle)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theGearInitialAngle"")");
        double theGearInitialAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GearInitialAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpGearJointSetPhase(self, theGearInitialAngle);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetMotorSpinRate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Motor") != 0)
        {
            args.GetReturnValue().SetUndefined();
        };
        cpFloat theMotorSpinRate = cpSimpleMotorGetRate(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMotorSpinRate) ); return; };
    }

    void cpConstraintWrap::SetMotorSpinRate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inMotorSpinRate)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMotorSpinRate"")");
        double theMotorSpinRate = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Motor") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MotorSpinRate" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        cpSimpleMotorSetRate(self, theMotorSpinRate);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetSpringStiffness(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        cpFloat theSpringStiffness;
        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            theSpringStiffness = cpDampedSpringGetStiffness(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            theSpringStiffness = cpDampedRotarySpringGetStiffness(self);
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        };
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpringStiffness) ); return; };
    }

    void cpConstraintWrap::SetSpringStiffness(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inSpringStiffness)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpringStiffness"")");
        double theSpringStiffness = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetStiffness(self, theSpringStiffness);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            cpDampedRotarySpringSetStiffness(self, theSpringStiffness);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setSpringStiffness() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpConstraintWrap::GetSpringDamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        cpFloat theSpringDamping;
        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            theSpringDamping = cpDampedSpringGetDamping(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            theSpringDamping = cpDampedRotarySpringGetDamping(self);
        }
        else
        {
            args.GetReturnValue().SetUndefined();
        };
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpringDamping) ); return; };
    }

    void cpConstraintWrap::SetSpringDamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpConstraint]" " function" "(number inSpringDamping)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpringDamping"")");
        double theSpringDamping = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetDamping(self, theSpringDamping);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            cpDampedRotarySpringSetDamping(self, theSpringDamping);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setSpringDamping() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str()))) ;
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    cpConstraint* New_cpConstraint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_cpConstraint_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        s_HaveSavedError = true;
        {
            std::ostringstream excpt_;
            excpt_ << "CpConstraint cannot be created directly, it is only returned from certain Sprite calls.";
            v8::Isolate* isolate = v8::Isolate::GetCurrent();
            s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        };
        return 0;
    }

    static bool s_cpSpace_InNewFromCpp = false;

    void cpSpaceWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = new cpSpaceWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> cpSpaceWrap::NewFromCpp(v8::Isolate* isolate, cpSpace* cppObj)
    {
        s_cpSpace_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(instance);

        ;
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_cpSpace_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> cpSpaceWrap::constructorTpl_;

    void cpSpaceWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "CpSpace", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> UseSpatialHash_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UseSpatialHash_Tpl =
            v8::FunctionTemplate::New(isolate, UseSpatialHash, v8::Local<v8::Value>(), UseSpatialHash_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "useSpatialHash", v8::String::kInternalizedString), UseSpatialHash_Tpl);
        v8::Local<v8::Signature> ReindexStatic_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ReindexStatic_Tpl =
            v8::FunctionTemplate::New(isolate, ReindexStatic, v8::Local<v8::Value>(), ReindexStatic_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "reindexStatic", v8::String::kInternalizedString), ReindexStatic_Tpl);
        v8::Local<v8::Signature> Step_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Step_Tpl =
            v8::FunctionTemplate::New(isolate, Step, v8::Local<v8::Value>(), Step_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "step", v8::String::kInternalizedString), Step_Tpl);
        v8::Local<v8::Signature> GetIdleSpeedThreshold_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetIdleSpeedThreshold_Tpl =
            v8::FunctionTemplate::New(isolate, GetIdleSpeedThreshold, v8::Local<v8::Value>(), GetIdleSpeedThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""IdleSpeedThreshold", v8::String::kInternalizedString), GetIdleSpeedThreshold_Tpl);
        v8::Local<v8::Signature> SetIdleSpeedThreshold_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetIdleSpeedThreshold_Tpl =
            v8::FunctionTemplate::New(isolate, SetIdleSpeedThreshold, v8::Local<v8::Value>(), SetIdleSpeedThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""IdleSpeedThreshold", v8::String::kInternalizedString), SetIdleSpeedThreshold_Tpl);
        v8::Local<v8::Signature> GetSleepTimeThreshold_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSleepTimeThreshold_Tpl =
            v8::FunctionTemplate::New(isolate, GetSleepTimeThreshold, v8::Local<v8::Value>(), GetSleepTimeThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SleepTimeThreshold", v8::String::kInternalizedString), GetSleepTimeThreshold_Tpl);
        v8::Local<v8::Signature> SetSleepTimeThreshold_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSleepTimeThreshold_Tpl =
            v8::FunctionTemplate::New(isolate, SetSleepTimeThreshold, v8::Local<v8::Value>(), SetSleepTimeThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SleepTimeThreshold", v8::String::kInternalizedString), SetSleepTimeThreshold_Tpl);
        v8::Local<v8::Signature> GetCollisionSlop_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCollisionSlop_Tpl =
            v8::FunctionTemplate::New(isolate, GetCollisionSlop, v8::Local<v8::Value>(), GetCollisionSlop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CollisionSlop", v8::String::kInternalizedString), GetCollisionSlop_Tpl);
        v8::Local<v8::Signature> SetCollisionSlop_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollisionSlop_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollisionSlop, v8::Local<v8::Value>(), SetCollisionSlop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CollisionSlop", v8::String::kInternalizedString), SetCollisionSlop_Tpl);
        v8::Local<v8::Signature> GetCollisionBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCollisionBias_Tpl =
            v8::FunctionTemplate::New(isolate, GetCollisionBias, v8::Local<v8::Value>(), GetCollisionBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CollisionBias", v8::String::kInternalizedString), GetCollisionBias_Tpl);
        v8::Local<v8::Signature> SetCollisionBias_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollisionBias_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollisionBias, v8::Local<v8::Value>(), SetCollisionBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CollisionBias", v8::String::kInternalizedString), SetCollisionBias_Tpl);
        v8::Local<v8::Signature> GetCollisionPersistence_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCollisionPersistence_Tpl =
            v8::FunctionTemplate::New(isolate, GetCollisionPersistence, v8::Local<v8::Value>(), GetCollisionPersistence_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CollisionPersistence", v8::String::kInternalizedString), GetCollisionPersistence_Tpl);
        v8::Local<v8::Signature> SetCollisionPersistence_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollisionPersistence_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollisionPersistence, v8::Local<v8::Value>(), SetCollisionPersistence_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CollisionPersistence", v8::String::kInternalizedString), SetCollisionPersistence_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "CpSpace", v8::String::kInternalizedString), t->GetFunction());

    }

    void cpSpaceWrap::UseSpatialHash(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number dim, [number int] count)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""dim"")");
        double dim = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""count"")");
        long count = args[2 -1]->Int32Value();
        cpSpaceUseSpatialHash(self, dim, count);
        args.GetReturnValue().SetUndefined();
    }

    void cpSpaceWrap::ReindexStatic(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpSpaceReindexStatic(self);
        args.GetReturnValue().SetUndefined();
    }

    void cpSpaceWrap::Step(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number dt)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""dt"")");
        double dt = args[1 -1]->NumberValue();
        cpSpaceStep(self, dt);
        args.GetReturnValue().SetUndefined();
    }

    void cpSpaceWrap::GetIdleSpeedThreshold(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theIdleSpeedThreshold = cpSpaceGetIdleSpeedThreshold(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theIdleSpeedThreshold) ); return; };
    }

    void cpSpaceWrap::SetIdleSpeedThreshold(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpSpace]" " function" "(number inIdleSpeedThreshold)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theIdleSpeedThreshold"")");
        double theIdleSpeedThreshold = args[1 -1]->NumberValue();

        cpSpaceSetIdleSpeedThreshold(self, theIdleSpeedThreshold);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpSpaceWrap::GetSleepTimeThreshold(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSleepTimeThreshold = cpSpaceGetSleepTimeThreshold(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSleepTimeThreshold) ); return; };
    }

    void cpSpaceWrap::SetSleepTimeThreshold(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpSpace]" " function" "(number inSleepTimeThreshold)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSleepTimeThreshold"")");
        double theSleepTimeThreshold = args[1 -1]->NumberValue();

        cpSpaceSetSleepTimeThreshold(self, theSleepTimeThreshold);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpSpaceWrap::GetCollisionSlop(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theCollisionSlop = cpSpaceGetCollisionSlop(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theCollisionSlop) ); return; };
    }

    void cpSpaceWrap::SetCollisionSlop(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpSpace]" " function" "(number inCollisionSlop)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theCollisionSlop"")");
        double theCollisionSlop = args[1 -1]->NumberValue();

        cpSpaceSetCollisionSlop(self, theCollisionSlop);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpSpaceWrap::GetCollisionBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theCollisionBias = cpSpaceGetCollisionBias(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theCollisionBias) ); return; };
    }

    void cpSpaceWrap::SetCollisionBias(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpSpace]" " function" "(number inCollisionBias)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theCollisionBias"")");
        double theCollisionBias = args[1 -1]->NumberValue();

        cpSpaceSetCollisionBias(self, theCollisionBias);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void cpSpaceWrap::GetCollisionPersistence(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theCollisionPersistence = cpSpaceGetCollisionPersistence(self);
        { args.GetReturnValue().Set( v8::Number::New(isolate, theCollisionPersistence) ); return; };
    }

    void cpSpaceWrap::SetCollisionPersistence(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object cpSpace]" " function" "(number inCollisionPersistence)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theCollisionPersistence"")");
        double theCollisionPersistence = args[1 -1]->NumberValue();

        cpSpaceSetCollisionPersistence(self, theCollisionPersistence);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    cpSpace* New_cpSpace(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_cpSpace_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        s_HaveSavedError = true;
        {
            std::ostringstream excpt_;
            excpt_ << "CpSpace cannot be created directly, it is only returned from certain Sprite calls.";
            v8::Isolate* isolate = v8::Isolate::GetCurrent();
            s_SavedError.Reset(isolate, v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        };
        return 0;
    }
#endif

    bool s_ISpriteCollideHelper_InNewFromCpp = false;

    void ISpriteCollideHelperWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ISpriteCollideHelperWrap* objWrapper = new ISpriteCollideHelperWrap(args);
        objWrapper->Wrap(args.This());
        ISpriteCollideHelper* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mISpriteCollideHelperScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> ISpriteCollideHelperWrap::NewFromCpp(v8::Isolate* isolate, ISpriteCollideHelper* cppObj)
    {
        s_ISpriteCollideHelper_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        ISpriteCollideHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(instance);

        cppObj->mISpriteCollideHelperScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_ISpriteCollideHelper_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> ISpriteCollideHelperWrap::constructorTpl_;

    void ISpriteCollideHelperWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ISpriteCollideHelper", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        target->Set(v8::String::NewFromUtf8(isolate, "ISpriteCollideHelper", v8::String::kInternalizedString), t->GetFunction());
    }

    void CleanupISpriteCollideHelperScriptObject(v8::Persistent<v8::Object> &obj) { }

#ifndef PDG_NO_GUI

    bool s_ISpriteDrawHelper_InNewFromCpp = false;

    void ISpriteDrawHelperWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        ISpriteDrawHelperWrap* objWrapper = new ISpriteDrawHelperWrap(args);
        objWrapper->Wrap(args.This());
        ISpriteDrawHelper* cppObj = objWrapper->getCppObject();
        if (cppObj)
        {
            cppObj->mISpriteDrawHelperScriptObj.Reset(isolate, args.This());
        }
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> ISpriteDrawHelperWrap::NewFromCpp(v8::Isolate* isolate, ISpriteDrawHelper* cppObj)
    {
        s_ISpriteDrawHelper_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        ISpriteDrawHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(instance);

        cppObj->mISpriteDrawHelperScriptObj.Reset(isolate, obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_ISpriteDrawHelper_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> ISpriteDrawHelperWrap::constructorTpl_;

    void ISpriteDrawHelperWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "ISpriteDrawHelper", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        target->Set(v8::String::NewFromUtf8(isolate, "ISpriteDrawHelper", v8::String::kInternalizedString), t->GetFunction());
    }

    void CleanupISpriteDrawHelperScriptObject(v8::Persistent<v8::Object> &obj) { }
#endif

    static const char* sPinJointStr = "PinJoint";
    static const char* sSlideJointStr = "SlideJoint";
    static const char* sPivotJointStr = "PivotJoint";
    static const char* sGrooveJointStr = "GrooveJoint";
    static const char* sSpringJointStr = "SpringJoint";
    static const char* sRotarySpringStr = "RotarySpring";
    static const char* sRotaryLimitStr = "RotaryLimit";
    static const char* sRatchetStr = "Ratchet";
    static const char* sGearStr = "Gear";
    static const char* sMotorStr = "Motor";

    static bool s_Sprite_InNewFromCpp = false;

    void SpriteWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = new SpriteWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> SpriteWrap::NewFromCpp(v8::Isolate* isolate, Sprite* cppObj)
    {
        s_Sprite_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(instance);

        cppObj->mEventEmitterScriptObj.Reset(isolate, obj); cppObj->mAnimatedScriptObj.Reset(isolate, obj); cppObj->mSpriteScriptObj.Reset(isolate, obj); cppObj->mISerializableScriptObj.Reset(isolate, obj); cppObj->addRef();
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_Sprite_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> SpriteWrap::constructorTpl_;

    void SpriteWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "Sprite", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(isolate, GetBoundingBox, v8::Local<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""BoundingBox", v8::String::kInternalizedString), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotatedBounds, v8::Local<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RotatedBounds", v8::String::kInternalizedString), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, GetLocation, v8::Local<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Location", v8::String::kInternalizedString), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, SetLocation, v8::Local<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Location", v8::String::kInternalizedString), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpeed, v8::Local<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Speed", v8::String::kInternalizedString), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpeed, v8::Local<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Speed", v8::String::kInternalizedString), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, GetVelocity, v8::Local<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Velocity", v8::String::kInternalizedString), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocity, v8::Local<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Velocity", v8::String::kInternalizedString), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, SetWidth, v8::Local<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Width", v8::String::kInternalizedString), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, SetHeight, v8::Local<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Height", v8::String::kInternalizedString), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotation, v8::Local<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Rotation", v8::String::kInternalizedString), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, SetRotation, v8::Local<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Rotation", v8::String::kInternalizedString), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, GetCenterOffset, v8::Local<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CenterOffset", v8::String::kInternalizedString), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, SetCenterOffset, v8::Local<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CenterOffset", v8::String::kInternalizedString), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpin, v8::Local<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Spin", v8::String::kInternalizedString), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpin, v8::Local<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Spin", v8::String::kInternalizedString), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(isolate, GetMass, v8::Local<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Mass", v8::String::kInternalizedString), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(isolate, SetMass, v8::Local<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Mass", v8::String::kInternalizedString), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetMoveFriction, v8::Local<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MoveFriction", v8::String::kInternalizedString), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetMoveFriction, v8::Local<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MoveFriction", v8::String::kInternalizedString), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpinFriction, v8::Local<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpinFriction", v8::String::kInternalizedString), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpinFriction, v8::Local<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpinFriction", v8::String::kInternalizedString), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSizeFriction, v8::Local<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SizeFriction", v8::String::kInternalizedString), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSizeFriction, v8::Local<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SizeFriction", v8::String::kInternalizedString), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(isolate, Move, v8::Local<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "move", v8::String::kInternalizedString), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(isolate, MoveTo, v8::Local<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveTo", v8::String::kInternalizedString), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocityInRadians, v8::Local<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setVelocityInRadians", v8::String::kInternalizedString), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, GetMovementDirectionInRadians, v8::Local<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMovementDirectionInRadians", v8::String::kInternalizedString), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(isolate, StopMoving, v8::Local<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopMoving", v8::String::kInternalizedString), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(isolate, Accelerate, v8::Local<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerate", v8::String::kInternalizedString), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(isolate, AccelerateTo, v8::Local<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerateTo", v8::String::kInternalizedString), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(isolate, SetSize, v8::Local<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSize", v8::String::kInternalizedString), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(isolate, Grow, v8::Local<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "grow", v8::String::kInternalizedString), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(isolate, Stretch, v8::Local<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stretch", v8::String::kInternalizedString), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StartGrowing, v8::Local<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startGrowing", v8::String::kInternalizedString), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StopGrowing, v8::Local<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopGrowing", v8::String::kInternalizedString), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StartStretching, v8::Local<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startStretching", v8::String::kInternalizedString), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StopStretching, v8::Local<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopStretching", v8::String::kInternalizedString), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(isolate, Resize, v8::Local<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resize", v8::String::kInternalizedString), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(isolate, ResizeTo, v8::Local<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resizeTo", v8::String::kInternalizedString), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(isolate, Rotate, v8::Local<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotate", v8::String::kInternalizedString), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(isolate, RotateTo, v8::Local<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotateTo", v8::String::kInternalizedString), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(isolate, StopSpinning, v8::Local<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopSpinning", v8::String::kInternalizedString), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenter, v8::Local<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenter", v8::String::kInternalizedString), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenterTo, v8::Local<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenterTo", v8::String::kInternalizedString), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(isolate, Wait, v8::Local<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "wait", v8::String::kInternalizedString), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetFriction, v8::Local<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFriction", v8::String::kInternalizedString), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyForce, v8::Local<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyForce", v8::String::kInternalizedString), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyTorque, v8::Local<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyTorque", v8::String::kInternalizedString), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(isolate, StopAllForces, v8::Local<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAllForces", v8::String::kInternalizedString), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, AddAnimationHelper, v8::Local<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addAnimationHelper", v8::String::kInternalizedString), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAnimationHelper, v8::Local<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAnimationHelper", v8::String::kInternalizedString), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(isolate, ClearAnimationHelpers, v8::Local<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clearAnimationHelpers", v8::String::kInternalizedString), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> GetMyClassTag_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMyClassTag_Tpl =
            v8::FunctionTemplate::New(isolate, GetMyClassTag, v8::Local<v8::Value>(), GetMyClassTag_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MyClassTag", v8::String::kInternalizedString), GetMyClassTag_Tpl);
        v8::Local<v8::Signature> GetSerializedSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSerializedSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetSerializedSize, v8::Local<v8::Value>(), GetSerializedSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SerializedSize", v8::String::kInternalizedString), GetSerializedSize_Tpl);
        v8::Local<v8::Signature> Serialize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize, v8::Local<v8::Value>(), Serialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize", v8::String::kInternalizedString), Serialize_Tpl);
        v8::Local<v8::Signature> Deserialize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize, v8::Local<v8::Value>(), Deserialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize", v8::String::kInternalizedString), Deserialize_Tpl);
        v8::Local<v8::Signature> GetFrameRotatedBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFrameRotatedBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetFrameRotatedBounds, v8::Local<v8::Value>(), GetFrameRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getFrameRotatedBounds", v8::String::kInternalizedString), GetFrameRotatedBounds_Tpl);
        v8::Local<v8::Signature> SetFrame_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFrame_Tpl =
            v8::FunctionTemplate::New(isolate, SetFrame, v8::Local<v8::Value>(), SetFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFrame", v8::String::kInternalizedString), SetFrame_Tpl);
        v8::Local<v8::Signature> GetCurrentFrame_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCurrentFrame_Tpl =
            v8::FunctionTemplate::New(isolate, GetCurrentFrame, v8::Local<v8::Value>(), GetCurrentFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getCurrentFrame", v8::String::kInternalizedString), GetCurrentFrame_Tpl);
        v8::Local<v8::Signature> GetFrameCount_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFrameCount_Tpl =
            v8::FunctionTemplate::New(isolate, GetFrameCount, v8::Local<v8::Value>(), GetFrameCount_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getFrameCount", v8::String::kInternalizedString), GetFrameCount_Tpl);
        v8::Local<v8::Signature> StartFrameAnimation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartFrameAnimation_Tpl =
            v8::FunctionTemplate::New(isolate, StartFrameAnimation, v8::Local<v8::Value>(), StartFrameAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startFrameAnimation", v8::String::kInternalizedString), StartFrameAnimation_Tpl);
        v8::Local<v8::Signature> StopFrameAnimation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopFrameAnimation_Tpl =
            v8::FunctionTemplate::New(isolate, StopFrameAnimation, v8::Local<v8::Value>(), StopFrameAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopFrameAnimation", v8::String::kInternalizedString), StopFrameAnimation_Tpl);
        v8::Local<v8::Signature> GetWantsAnimLoopEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsAnimLoopEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsAnimLoopEvents, v8::Local<v8::Value>(), GetWantsAnimLoopEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsAnimLoopEvents", v8::String::kInternalizedString), GetWantsAnimLoopEvents_Tpl);
        v8::Local<v8::Signature> SetWantsAnimLoopEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsAnimLoopEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsAnimLoopEvents, v8::Local<v8::Value>(), SetWantsAnimLoopEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsAnimLoopEvents", v8::String::kInternalizedString), SetWantsAnimLoopEvents_Tpl);
        v8::Local<v8::Signature> GetWantsAnimEndEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsAnimEndEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsAnimEndEvents, v8::Local<v8::Value>(), GetWantsAnimEndEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsAnimEndEvents", v8::String::kInternalizedString), GetWantsAnimEndEvents_Tpl);
        v8::Local<v8::Signature> SetWantsAnimEndEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsAnimEndEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsAnimEndEvents, v8::Local<v8::Value>(), SetWantsAnimEndEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsAnimEndEvents", v8::String::kInternalizedString), SetWantsAnimEndEvents_Tpl);
        v8::Local<v8::Signature> GetWantsCollideWallEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsCollideWallEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsCollideWallEvents, v8::Local<v8::Value>(), GetWantsCollideWallEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsCollideWallEvents", v8::String::kInternalizedString), GetWantsCollideWallEvents_Tpl);
        v8::Local<v8::Signature> SetWantsCollideWallEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsCollideWallEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsCollideWallEvents, v8::Local<v8::Value>(), SetWantsCollideWallEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsCollideWallEvents", v8::String::kInternalizedString), SetWantsCollideWallEvents_Tpl);
        v8::Local<v8::Signature> AddFramesImage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddFramesImage_Tpl =
            v8::FunctionTemplate::New(isolate, AddFramesImage, v8::Local<v8::Value>(), AddFramesImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addFramesImage", v8::String::kInternalizedString), AddFramesImage_Tpl);
#ifdef PDG_SCML_SUPPORT
        v8::Local<v8::Signature> HasAnimation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> HasAnimation_Tpl =
            v8::FunctionTemplate::New(isolate, HasAnimation, v8::Local<v8::Value>(), HasAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "hasAnimation", v8::String::kInternalizedString), HasAnimation_Tpl);
        v8::Local<v8::Signature> StartAnimation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartAnimation_Tpl =
            v8::FunctionTemplate::New(isolate, StartAnimation, v8::Local<v8::Value>(), StartAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startAnimation", v8::String::kInternalizedString), StartAnimation_Tpl);
        v8::Local<v8::Signature> SetEntityScale_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetEntityScale_Tpl =
            v8::FunctionTemplate::New(isolate, SetEntityScale, v8::Local<v8::Value>(), SetEntityScale_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setEntityScale", v8::String::kInternalizedString), SetEntityScale_Tpl);
#endif
        v8::Local<v8::Signature> ChangeFramesImage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeFramesImage_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeFramesImage, v8::Local<v8::Value>(), ChangeFramesImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeFramesImage", v8::String::kInternalizedString), ChangeFramesImage_Tpl);
        v8::Local<v8::Signature> OffsetFrameCenters_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> OffsetFrameCenters_Tpl =
            v8::FunctionTemplate::New(isolate, OffsetFrameCenters, v8::Local<v8::Value>(), OffsetFrameCenters_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "offsetFrameCenters", v8::String::kInternalizedString), OffsetFrameCenters_Tpl);
        v8::Local<v8::Signature> GetFrameCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFrameCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, GetFrameCenterOffset, v8::Local<v8::Value>(), GetFrameCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getFrameCenterOffset", v8::String::kInternalizedString), GetFrameCenterOffset_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, GetOpacity, v8::Local<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Opacity", v8::String::kInternalizedString), GetOpacity_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(isolate, SetOpacity, v8::Local<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Opacity", v8::String::kInternalizedString), SetOpacity_Tpl);
        v8::Local<v8::Signature> FadeTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeTo_Tpl =
            v8::FunctionTemplate::New(isolate, FadeTo, v8::Local<v8::Value>(), FadeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeTo", v8::String::kInternalizedString), FadeTo_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(isolate, FadeIn, v8::Local<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeIn", v8::String::kInternalizedString), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(isolate, FadeOut, v8::Local<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeOut", v8::String::kInternalizedString), FadeOut_Tpl);
        v8::Local<v8::Signature> IsBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsBehind_Tpl =
            v8::FunctionTemplate::New(isolate, IsBehind, v8::Local<v8::Value>(), IsBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isBehind", v8::String::kInternalizedString), IsBehind_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(isolate, GetZOrder, v8::Local<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getZOrder", v8::String::kInternalizedString), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(isolate, MoveBehind, v8::Local<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveBehind", v8::String::kInternalizedString), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(isolate, MoveInFrontOf, v8::Local<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveInFrontOf", v8::String::kInternalizedString), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToFront, v8::Local<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToFront", v8::String::kInternalizedString), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToBack, v8::Local<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToBack", v8::String::kInternalizedString), MoveToBack_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, EnableCollisions, v8::Local<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "enableCollisions", v8::String::kInternalizedString), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, DisableCollisions, v8::Local<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disableCollisions", v8::String::kInternalizedString), DisableCollisions_Tpl);
        v8::Local<v8::Signature> GetCollisionRadius_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCollisionRadius_Tpl =
            v8::FunctionTemplate::New(isolate, GetCollisionRadius, v8::Local<v8::Value>(), GetCollisionRadius_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CollisionRadius", v8::String::kInternalizedString), GetCollisionRadius_Tpl);
        v8::Local<v8::Signature> SetCollisionRadius_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollisionRadius_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollisionRadius, v8::Local<v8::Value>(), SetCollisionRadius_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CollisionRadius", v8::String::kInternalizedString), SetCollisionRadius_Tpl);
        v8::Local<v8::Signature> UseCollisionMask_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UseCollisionMask_Tpl =
            v8::FunctionTemplate::New(isolate, UseCollisionMask, v8::Local<v8::Value>(), UseCollisionMask_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "useCollisionMask", v8::String::kInternalizedString), UseCollisionMask_Tpl);
        v8::Local<v8::Signature> SetCollisionHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollisionHelper_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollisionHelper, v8::Local<v8::Value>(), SetCollisionHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setCollisionHelper", v8::String::kInternalizedString), SetCollisionHelper_Tpl);
        v8::Local<v8::Signature> GetElasticity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetElasticity_Tpl =
            v8::FunctionTemplate::New(isolate, GetElasticity, v8::Local<v8::Value>(), GetElasticity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Elasticity", v8::String::kInternalizedString), GetElasticity_Tpl);
        v8::Local<v8::Signature> SetElasticity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetElasticity_Tpl =
            v8::FunctionTemplate::New(isolate, SetElasticity, v8::Local<v8::Value>(), SetElasticity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Elasticity", v8::String::kInternalizedString), SetElasticity_Tpl);
        v8::Local<v8::Signature> GetLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLayer_Tpl =
            v8::FunctionTemplate::New(isolate, GetLayer, v8::Local<v8::Value>(), GetLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getLayer", v8::String::kInternalizedString), GetLayer_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> SetDrawHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetDrawHelper_Tpl =
            v8::FunctionTemplate::New(isolate, SetDrawHelper, v8::Local<v8::Value>(), SetDrawHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setDrawHelper", v8::String::kInternalizedString), SetDrawHelper_Tpl);
        v8::Local<v8::Signature> SetPostDrawHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetPostDrawHelper_Tpl =
            v8::FunctionTemplate::New(isolate, SetPostDrawHelper, v8::Local<v8::Value>(), SetPostDrawHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setPostDrawHelper", v8::String::kInternalizedString), SetPostDrawHelper_Tpl);
        v8::Local<v8::Signature> GetWantsMouseOverEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsMouseOverEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsMouseOverEvents, v8::Local<v8::Value>(), GetWantsMouseOverEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsMouseOverEvents", v8::String::kInternalizedString), GetWantsMouseOverEvents_Tpl);
        v8::Local<v8::Signature> SetWantsMouseOverEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsMouseOverEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsMouseOverEvents, v8::Local<v8::Value>(), SetWantsMouseOverEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsMouseOverEvents", v8::String::kInternalizedString), SetWantsMouseOverEvents_Tpl);
        v8::Local<v8::Signature> GetWantsClickEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsClickEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsClickEvents, v8::Local<v8::Value>(), GetWantsClickEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsClickEvents", v8::String::kInternalizedString), GetWantsClickEvents_Tpl);
        v8::Local<v8::Signature> SetWantsClickEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsClickEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsClickEvents, v8::Local<v8::Value>(), SetWantsClickEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsClickEvents", v8::String::kInternalizedString), SetWantsClickEvents_Tpl);
        v8::Local<v8::Signature> GetMouseDetectMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMouseDetectMode_Tpl =
            v8::FunctionTemplate::New(isolate, GetMouseDetectMode, v8::Local<v8::Value>(), GetMouseDetectMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MouseDetectMode", v8::String::kInternalizedString), GetMouseDetectMode_Tpl);
        v8::Local<v8::Signature> SetMouseDetectMode_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMouseDetectMode_Tpl =
            v8::FunctionTemplate::New(isolate, SetMouseDetectMode, v8::Local<v8::Value>(), SetMouseDetectMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MouseDetectMode", v8::String::kInternalizedString), SetMouseDetectMode_Tpl);
        v8::Local<v8::Signature> GetWantsOffscreenEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWantsOffscreenEvents_Tpl =
            v8::FunctionTemplate::New(isolate, GetWantsOffscreenEvents, v8::Local<v8::Value>(), GetWantsOffscreenEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""WantsOffscreenEvents", v8::String::kInternalizedString), GetWantsOffscreenEvents_Tpl);
        v8::Local<v8::Signature> SetWantsOffscreenEvents_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWantsOffscreenEvents_Tpl =
            v8::FunctionTemplate::New(isolate, SetWantsOffscreenEvents, v8::Local<v8::Value>(), SetWantsOffscreenEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""WantsOffscreenEvents", v8::String::kInternalizedString), SetWantsOffscreenEvents_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> MakeStatic_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MakeStatic_Tpl =
            v8::FunctionTemplate::New(isolate, MakeStatic, v8::Local<v8::Value>(), MakeStatic_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "makeStatic", v8::String::kInternalizedString), MakeStatic_Tpl);
        v8::Local<v8::Signature> GetFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetFriction, v8::Local<v8::Value>(), GetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getFriction", v8::String::kInternalizedString), GetFriction_Tpl);
        v8::Local<v8::Signature> SetCollideGroup_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCollideGroup_Tpl =
            v8::FunctionTemplate::New(isolate, SetCollideGroup, v8::Local<v8::Value>(), SetCollideGroup_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setCollideGroup", v8::String::kInternalizedString), SetCollideGroup_Tpl);
        v8::Local<v8::Signature> GetCollideGroup_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCollideGroup_Tpl =
            v8::FunctionTemplate::New(isolate, GetCollideGroup, v8::Local<v8::Value>(), GetCollideGroup_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getCollideGroup", v8::String::kInternalizedString), GetCollideGroup_Tpl);
        v8::Local<v8::Signature> PinJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PinJoint_Tpl =
            v8::FunctionTemplate::New(isolate, PinJoint, v8::Local<v8::Value>(), PinJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "pinJoint", v8::String::kInternalizedString), PinJoint_Tpl);
        v8::Local<v8::Signature> SlideJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SlideJoint_Tpl =
            v8::FunctionTemplate::New(isolate, SlideJoint, v8::Local<v8::Value>(), SlideJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "slideJoint", v8::String::kInternalizedString), SlideJoint_Tpl);
        v8::Local<v8::Signature> PivotJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PivotJoint_Tpl =
            v8::FunctionTemplate::New(isolate, PivotJoint, v8::Local<v8::Value>(), PivotJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "pivotJoint", v8::String::kInternalizedString), PivotJoint_Tpl);
        v8::Local<v8::Signature> GrooveJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GrooveJoint_Tpl =
            v8::FunctionTemplate::New(isolate, GrooveJoint, v8::Local<v8::Value>(), GrooveJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "grooveJoint", v8::String::kInternalizedString), GrooveJoint_Tpl);
        v8::Local<v8::Signature> SpringJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SpringJoint_Tpl =
            v8::FunctionTemplate::New(isolate, SpringJoint, v8::Local<v8::Value>(), SpringJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "springJoint", v8::String::kInternalizedString), SpringJoint_Tpl);
        v8::Local<v8::Signature> RotarySpring_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotarySpring_Tpl =
            v8::FunctionTemplate::New(isolate, RotarySpring, v8::Local<v8::Value>(), RotarySpring_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotarySpring", v8::String::kInternalizedString), RotarySpring_Tpl);
        v8::Local<v8::Signature> RotaryLimit_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotaryLimit_Tpl =
            v8::FunctionTemplate::New(isolate, RotaryLimit, v8::Local<v8::Value>(), RotaryLimit_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotaryLimit", v8::String::kInternalizedString), RotaryLimit_Tpl);
        v8::Local<v8::Signature> Ratchet_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Ratchet_Tpl =
            v8::FunctionTemplate::New(isolate, Ratchet, v8::Local<v8::Value>(), Ratchet_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "ratchet", v8::String::kInternalizedString), Ratchet_Tpl);
        v8::Local<v8::Signature> Gear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Gear_Tpl =
            v8::FunctionTemplate::New(isolate, Gear, v8::Local<v8::Value>(), Gear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "gear", v8::String::kInternalizedString), Gear_Tpl);
        v8::Local<v8::Signature> Motor_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Motor_Tpl =
            v8::FunctionTemplate::New(isolate, Motor, v8::Local<v8::Value>(), Motor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "motor", v8::String::kInternalizedString), Motor_Tpl);
        v8::Local<v8::Signature> RemoveJoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveJoint_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveJoint, v8::Local<v8::Value>(), RemoveJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeJoint", v8::String::kInternalizedString), RemoveJoint_Tpl);
        v8::Local<v8::Signature> Disconnect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Disconnect_Tpl =
            v8::FunctionTemplate::New(isolate, Disconnect, v8::Local<v8::Value>(), Disconnect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disconnect", v8::String::kInternalizedString), Disconnect_Tpl);
        v8::Local<v8::Signature> MakeJointBreakable_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MakeJointBreakable_Tpl =
            v8::FunctionTemplate::New(isolate, MakeJointBreakable, v8::Local<v8::Value>(), MakeJointBreakable_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "makeJointBreakable", v8::String::kInternalizedString), MakeJointBreakable_Tpl);
        v8::Local<v8::Signature> MakeJointUnbreakable_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MakeJointUnbreakable_Tpl =
            v8::FunctionTemplate::New(isolate, MakeJointUnbreakable, v8::Local<v8::Value>(), MakeJointUnbreakable_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "makeJointUnbreakable", v8::String::kInternalizedString), MakeJointUnbreakable_Tpl);
#endif
        target->Set(v8::String::NewFromUtf8(isolate, "Sprite", v8::String::kInternalizedString), t->GetFunction());

    }

    void SpriteWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 3328 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 3328 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 3328 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 3328 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 3328 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::GetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, theLocation) ); return; };
    }

    void SpriteWrap::SetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([object Point] inLocation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(isolate, args[1 -1]);

        self->setLocation(theLocation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpeed = self->getSpeed();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpeed) ); return; };
    }

    void SpriteWrap::SetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inSpeed)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theWidth) ); return; };
    }

    void SpriteWrap::SetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inWidth)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theHeight) ); return; };
    }

    void SpriteWrap::SetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inHeight)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theRotation = self->getRotation();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRotation) ); return; };
    }

    void SpriteWrap::SetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inRotation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theCenterOffset) ); return; };
    }

    void SpriteWrap::SetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([object Offset] inCenterOffset)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(isolate, args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpin = self->getSpin();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpin) ); return; };
    }

    void SpriteWrap::SetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inSpin)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMass = self->getMass();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMass) ); return; };
    }

    void SpriteWrap::SetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inMass)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMoveFriction) ); return; };
    }

    void SpriteWrap::SetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inMoveFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpinFriction) ); return; };
    }

    void SpriteWrap::SetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inSpinFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSizeFriction) ); return; };
    }

    void SpriteWrap::SetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number inSizeFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetBoundingBox(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void SpriteWrap::GetRotatedBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void SpriteWrap::Move(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            delta = v8_ValueToOffset(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::MoveTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(isolate, args[0]))
        {
            where = v8_ValueToPoint(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetVelocityInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number speed, number direction)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetMovementDirectionInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        { args.GetReturnValue().Set( v8::Number::New(isolate, dir) ); return; };
    }

    void SpriteWrap::SetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "({[object Vector] deltaPerSec|number deltaXPerSec, number deltaYPerSec})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(isolate, args[0]))
        {
            deltaPerSec = v8_ValueToVector(isolate, args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, theVelocity) ); return; };
    }

    void SpriteWrap::StopMoving(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopMoving();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Accelerate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::AccelerateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number width, number height)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::Grow(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Stretch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StartGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number amountPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StopGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopGrowing();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StartStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StopStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopStretching();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Resize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::ResizeTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Rotate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::RotateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StopSpinning(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopSpinning();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::ChangeCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::ChangeCenterTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Wait(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([number int] msDuration)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number frictionCoefficient)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::ApplyForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::ApplyTorque(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StopAllForces(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAllForces();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::AddAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        self->mAnimatedScriptObj.Reset(isolate, args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 3329 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 3329 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 3329 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 3329 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 3329 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::RemoveAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::ClearAnimationHelpers(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clearAnimationHelpers();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::GetMyClassTag(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        uint32 theMyClassTag = self->getMyClassTag();
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, theMyClassTag) ); return; };
    }

    void SpriteWrap::GetSerializedSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [number uint]" " function" "([object Serializer] serializer)" " - " "get size of this object's data for the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, serializer, Serializer);
        uint32 dataSize = self->getSerializedSize(serializer);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, dataSize) ); return; };
    }

    void SpriteWrap::Serialize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "([object Serializer] serializer)" " - " "write this object's data into the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, serializer, Serializer);
        self->serialize(serializer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Deserialize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "([object Deserializer] deserializer)" " - " "read this object's data from the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, deserializer, Deserializer);
        try
        {
            self->deserialize(deserializer);
            args.GetReturnValue().SetUndefined();
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(sync_error& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

    void SpriteWrap::GetWantsAnimLoopEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsAnimLoopEvents = self->getWantsAnimLoopEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsAnimLoopEvents) ); return; };
    }

    void SpriteWrap::GetWantsAnimEndEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsAnimEndEvents = self->getWantsAnimEndEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsAnimEndEvents) ); return; };
    }

    void SpriteWrap::GetWantsCollideWallEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsCollideWallEvents = self->getWantsCollideWallEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsCollideWallEvents) ); return; };
    }
#ifndef PDG_NO_GUI

    void SpriteWrap::GetWantsMouseOverEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsMouseOverEvents = self->getWantsMouseOverEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsMouseOverEvents) ); return; };
    }

    void SpriteWrap::GetWantsClickEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsClickEvents = self->getWantsClickEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsClickEvents) ); return; };
    }

    void SpriteWrap::GetMouseDetectMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        int theMouseDetectMode = self->getMouseDetectMode();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, theMouseDetectMode) ); return; };
    }

    void SpriteWrap::GetWantsOffscreenEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        bool theWantsOffscreenEvents = self->getWantsOffscreenEvents();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, theWantsOffscreenEvents) ); return; };
    }
#endif

    void SpriteWrap::GetFrameRotatedBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "([number int] frameNum = -1)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frameNum"")");
        long frameNum = (args.Length()<1) ? -1 : args[1 -1]->Int32Value();;
        pdg::RotatedRect r = self->getFrameRotatedBounds(frameNum);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void SpriteWrap::SetFrame(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] frame)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frame"")");
        long frame = args[1 -1]->Int32Value();
        self->setFrame(frame);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetCurrentFrame(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "which frame of animation the sprite is currently showing") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        int frame = self->getCurrentFrame();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, frame) ); return; };
    }

    void SpriteWrap::GetFrameCount(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "total number of frames of animation for this sprite") ); return; };
        };

        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        int count = self->getFrameCount();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, count) ); return; };
    }

    void SpriteWrap::StartFrameAnimation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number fps, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames, [number int] animateFlags = animate_Looping)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""fps"")");
        double fps = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<2) ? Sprite::start_FromFirstFrame : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""numFrames"")");
        long numFrames = (args.Length()<3) ? Sprite::all_Frames : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""animateFlags"")");
        long animateFlags = (args.Length()<4) ? Sprite::animate_Looping : args[4 -1]->Int32Value();;
        self->startFrameAnimation(fps, startingFrame, numFrames, animateFlags);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::StopFrameAnimation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopFrameAnimation();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetWantsAnimLoopEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsAnimLoopEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetWantsAnimEndEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsAnimEndEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetWantsCollideWallEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsCollideWallEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::AddFramesImage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Image] image, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, image, Image);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<2) ? Sprite::start_FromFirstFrame : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""numFrames"")");
        long numFrames = (args.Length()<3) ? Sprite::all_Frames : args[3 -1]->Int32Value();;
        self->addFramesImage(image, startingFrame, numFrames);
        args.GetReturnValue().SetUndefined();
    }
#ifdef PDG_SCML_SUPPORT

    void SpriteWrap::HasAnimation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "({ [number int] animationId | string animationName })" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        bool hasIt = false;
        if (args[0]->IsString())
        {
            if (!args[1 -1]->IsString())
                v8_ThrowArgTypeException(isolate, 1, "a string  (""animationName"")");
            v8::String::Utf8Value animationName_Str(args[1 -1]->ToString());
            const char* animationName = *animationName_Str;;
            hasIt = self->hasAnimation(animationName);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""animationId"")");
            unsigned long animationId = args[1 -1]->Uint32Value();
            hasIt = self->hasAnimation(animationId);
        }
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, hasIt) ); return; };
    }

    void SpriteWrap::StartAnimation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({ [number int] animationId | string animationName })" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (args[0]->IsString())
        {
            if (!args[1 -1]->IsString())
                v8_ThrowArgTypeException(isolate, 1, "a string  (""animationName"")");
            v8::String::Utf8Value animationName_Str(args[1 -1]->ToString());
            const char* animationName = *animationName_Str;;
            self->startAnimation(animationName);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""animationId"")");
            unsigned long animationId = args[1 -1]->Uint32Value();
            self->startAnimation(animationId);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetEntityScale(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number xScale, number yScale)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""xScale"")");
        double xScale = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""yScale"")");
        double yScale = args[2 -1]->NumberValue();
        self->setEntityScale(xScale, yScale);
        { args.GetReturnValue().Set( args.This() ); return; };
    }
#endif
#ifndef PDG_NO_GUI

    void SpriteWrap::SetWantsOffscreenEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsOffscreenEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetDrawHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object ISpriteDrawHelper] helper)" " - " "") ); return; };
        };
        self->mSpriteScriptObj.Reset(isolate, args.This());
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_OR_NULL_ARG(1, helper, ISpriteDrawHelper);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 3457 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 3457 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteDrawHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< ISpriteDrawHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< ISpriteDrawHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 3457 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""ISpriteDrawHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 3457 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteDrawHelper""\n";
                }
            }
            else
            {
                ISpriteDrawHelper* obj = dynamic_cast<ISpriteDrawHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 3457 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""ISpriteDrawHelper"" ("<<(void*)obj<<")\n";
            }
        } )
            self->setDrawHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetPostDrawHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object ISpriteDrawHelper] helper)" " - " "") ); return; };
        };
        self->mSpriteScriptObj.Reset(isolate, args.This());
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_OR_NULL_ARG(1, helper, ISpriteDrawHelper);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 3466 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 3466 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteDrawHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< ISpriteDrawHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< ISpriteDrawHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 3466 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""ISpriteDrawHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 3466 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteDrawHelper""\n";
                }
            }
            else
            {
                ISpriteDrawHelper* obj = dynamic_cast<ISpriteDrawHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 3466 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""ISpriteDrawHelper"" ("<<(void*)obj<<")\n";
            }
        } )
            self->setPostDrawHelper(helper);
        args.GetReturnValue().SetUndefined();
    }
#endif

    void SpriteWrap::ChangeFramesImage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Image] oldImage, [object Image] newImage)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, oldImage, Image);
        REQUIRE_CPP_OBJECT_ARG(2, newImage, Image);
        self->changeFramesImage(oldImage, newImage);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::OffsetFrameCenters(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] offsetX, [number int] offsetY, [object Image] image = null, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""offsetX"")");
        long offsetX = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""offsetY"")");
        long offsetY = args[2 -1]->Int32Value();
        Image* image = 0;
        if (args.Length() >= 3)
        {
            if (!args[3 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 3, "an object of type ""Image"" (""image"")");
            }
            else
            {
                v8::Local<v8::Object> image_ = args[3 -1]->ToObject();
                ImageWrap* image__ = jswrap::ObjectWrap::Unwrap< ImageWrap>( image_);
                image = image__->getCppObject();
            }
        };
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<4) ? Sprite::start_FromFirstFrame : args[4 -1]->Int32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""numFrames"")");
        long numFrames = (args.Length()<5) ? Sprite::all_Frames : args[5 -1]->Int32Value();;
        self->offsetFrameCenters(offsetX, offsetY, image, startingFrame, numFrames);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::GetFrameCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "([object Image] image = null, [number int] frameNum = 0)" " - " "") ); return; };
        };
        Image* image = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Image"" (""image"")");
            }
            else
            {
                v8::Local<v8::Object> image_ = args[1 -1]->ToObject();
                ImageWrap* image__ = jswrap::ObjectWrap::Unwrap< ImageWrap>( image_);
                image = image__->getCppObject();
            }
        };
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""frameNum"")");
        long frameNum = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        pdg::Offset offset = self->getFrameCenterOffset(image, frameNum);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, offset) ); return; };
    }

    void SpriteWrap::SetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number opacity)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""opacity"")");
        double opacity = args[1 -1]->NumberValue();
        self->setOpacity(opacity);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetOpacity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float opacity = self->getOpacity();
        { args.GetReturnValue().Set( v8::Number::New(isolate, opacity) ); return; };
    }

    void SpriteWrap::FadeTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number targetOpacity, [number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""targetOpacity"")");
        double targetOpacity = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeTo(targetOpacity, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeTo(targetOpacity, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::FadeIn(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::FadeOut(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::IsBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        bool behind = self->isBehind(sprite);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, behind) ); return; };
    }

    void SpriteWrap::GetZOrder(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number int]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        int zorder = self->getZOrder();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, zorder) ); return; };
    }

    void SpriteWrap::MoveBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        self->moveBehind(sprite);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::MoveInFrontOf(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        self->moveInFrontOf(sprite);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::MoveToFront(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "put this sprite in front of all others in its layer") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToFront();
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::MoveToBack(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "put this sprite behind all others in its layer") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToBack();
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::EnableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] collisionType = collide_AlphaChannel)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""collisionType"")");
        long collisionType = (args.Length()<1) ? Sprite::collide_AlphaChannel : args[1 -1]->Int32Value();;
        self->enableCollisions(collisionType);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::DisableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->disableCollisions();
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetCollisionRadius(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number pixelRadius)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""pixelRadius"")");
        double pixelRadius = args[1 -1]->NumberValue();
        self->setCollisionRadius(pixelRadius);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetCollisionRadius(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float radius = self->getCollisionRadius();
        { args.GetReturnValue().Set( v8::Number::New(isolate, radius) ); return; };
    }

    void SpriteWrap::UseCollisionMask(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Image] frameImage, [object Image] maskImage)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, frameImage, Image);
        REQUIRE_CPP_OBJECT_ARG(2, maskImage, Image);
        self->useCollisionMask(frameImage, maskImage);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetCollisionHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object ISpriteCollideHelper] helper)" " - " "") ); return; };
        };
        self->mSpriteScriptObj.Reset(isolate, args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 3622 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 3622 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteCollideHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< ISpriteCollideHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< ISpriteCollideHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 3622 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""ISpriteCollideHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 3622 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteCollideHelper""\n";
                }
            }
            else
            {
                ISpriteCollideHelper* obj = dynamic_cast<ISpriteCollideHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 3622 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""ISpriteCollideHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, helper, ISpriteCollideHelper);
        self->setCollisionHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::SetElasticity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(number elasticity)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""elasticity"")");
        double elasticity = args[1 -1]->NumberValue();
        self->setElasticity(elasticity);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetElasticity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float elasticity = self->getElasticity();
        { args.GetReturnValue().Set( v8::Number::New(isolate, elasticity) ); return; };
    }
#ifndef PDG_NO_GUI

    void SpriteWrap::SetWantsMouseOverEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsMouseOverEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetWantsClickEvents(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsClickEvents(wantsThem);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::SetMouseDetectMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] collisionType = collide_BoundingBox)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""collisionType"")");
        long collisionType = (args.Length()<1) ? Sprite::collide_BoundingBox : args[1 -1]->Int32Value();;
        self->setMouseDetectMode(collisionType);
        { args.GetReturnValue().Set( args.This() ); return; };
    }
#endif

    void SpriteWrap::GetLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "()" " - " "get the layer that contains this sprite") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        SpriteLayer* layer = self->getLayer();
        if (!layer) args.GetReturnValue().SetNull();
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteLayerWrap::NewFromCpp(isolate, layer) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, layer->mSpriteLayerScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }
#ifdef PDG_USE_CHIPMUNK_PHYSICS

    void SpriteWrap::MakeStatic(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->makeStatic();
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float friction = self->getFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, friction) ); return; };
    }

    void SpriteWrap::SetCollideGroup(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] group)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""group"")");
        long group = args[1 -1]->Int32Value();
        self->setCollideGroup(group);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteWrap::GetCollideGroup(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        long group = self->getCollideGroup();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, group) ); return; };
    }

    void SpriteWrap::PinJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(isolate, args[1 -1]);
        REQUIRE_CPP_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(isolate, args[3 -1]);
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->pinJoint(anchor, otherSprite, otherAnchor, breakingForce);
        cpConstraintSetUserData(joint, (void*)sPinJointStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::SlideJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number minDist, number maxDist, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 5)
            v8_ThrowArgCountException(isolate, args.Length(), 5, true);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(isolate, args[1 -1]);
        REQUIRE_CPP_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(isolate, args[3 -1]);
        if (!args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""minDist"")");
        double minDist = args[4 -1]->NumberValue();
        if (!args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""maxDist"")");
        double maxDist = args[5 -1]->NumberValue();
        if (args.Length() >= 6 && !args[6 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 6, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<6) ? 0.0f : args[6 -1]->NumberValue();;
        cpConstraint* joint = self->slideJoint(anchor, otherSprite, otherAnchor, minDist, maxDist, breakingForce);
        cpConstraintSetUserData(joint, (void*)sSlideJointStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::PivotJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, [object Point] pivot, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!v8_ValueIsPoint(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Point", *args[2 -1]);
        pdg::Point pivot = v8_ValueToPoint(isolate, args[2 -1]);
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        cpConstraint* joint = self->pivotJoint(otherSprite, pivot, breakingForce);
        cpConstraintSetUserData(joint, (void*)sPivotJointStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::GrooveJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Offset] grooveStart, [object Offset] grooveEnd, [object Sprite] otherSprite, [object Offset] otherAnchor, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 4)
            v8_ThrowArgCountException(isolate, args.Length(), 4, true);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset grooveStart = v8_ValueToOffset(isolate, args[1 -1]);
        if (!v8_ValueIsOffset(isolate, args[2 -1]))
            v8_ThrowArgTypeException(isolate, 2, "Offset", *args[2 -1]);
        pdg::Offset grooveEnd = v8_ValueToOffset(isolate, args[2 -1]);
        REQUIRE_CPP_OBJECT_ARG(3, otherSprite, Sprite);
        if (!v8_ValueIsOffset(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Offset", *args[4 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(isolate, args[4 -1]);
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<5) ? 0.0f : args[5 -1]->NumberValue();;
        cpConstraint* joint = self->grooveJoint(grooveStart, grooveEnd, otherSprite, otherAnchor, breakingForce);
        cpConstraintSetUserData(joint, (void*)sGrooveJointStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::SpringJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number restLength, number stiffness, number damping, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 6)
            v8_ThrowArgCountException(isolate, args.Length(), 6, true);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(isolate, args[1 -1]);
        REQUIRE_CPP_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(isolate, args[3 -1]))
            v8_ThrowArgTypeException(isolate, 3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(isolate, args[3 -1]);
        if (!args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""restLength"")");
        double restLength = args[4 -1]->NumberValue();
        if (!args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""stiffness"")");
        double stiffness = args[5 -1]->NumberValue();
        if (!args[6 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 6, "a number (""damping"")");
        double damping = args[6 -1]->NumberValue();
        if (args.Length() >= 7 && !args[7 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 7, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<7) ? 0.0f : args[7 -1]->NumberValue();;
        cpConstraint* joint = self->springJoint(anchor, otherSprite, otherAnchor, restLength, stiffness, damping, breakingForce);
        cpConstraintSetUserData(joint, (void*)sSpringJointStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::RotarySpring(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, number restAngle, number stiffness, number damping, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 4)
            v8_ThrowArgCountException(isolate, args.Length(), 4, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""restAngle"")");
        double restAngle = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""stiffness"")");
        double stiffness = args[3 -1]->NumberValue();
        if (!args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""damping"")");
        double damping = args[4 -1]->NumberValue();
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<5) ? 0.0f : args[5 -1]->NumberValue();;
        cpConstraint* joint = self->rotarySpring(otherSprite, restAngle, stiffness, damping, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRotarySpringStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::RotaryLimit(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, number minAngle, number maxAngle, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""minAngle"")");
        double minAngle = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""maxAngle"")");
        double maxAngle = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->rotaryLimit(otherSprite, minAngle, maxAngle, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRotaryLimitStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::Ratchet(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, number rachetInterval, number phase, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""rachetInterval"")");
        double rachetInterval = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""phase"")");
        double phase = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->ratchet(otherSprite, rachetInterval, phase, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRatchetStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::Gear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, number gearRatio, number initialAngle = 0, number breakingForce = 0)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""gearRatio"")");
        double gearRatio = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""initialAngle"")");
        double initialAngle = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->gear(otherSprite, gearRatio, initialAngle, breakingForce);
        cpConstraintSetUserData(joint, (void*)sGearStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::Motor(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpConstraint]" " function" "([object Sprite] otherSprite, number spin, number maxTorque = INFINITY)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        REQUIRE_CPP_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""spin"")");
        double spin = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""maxTorque"")");
        double maxTorque = (args.Length()<3) ? std::numeric_limits<float>::infinity() : args[3 -1]->NumberValue();;
        cpConstraint* joint = self->motor(otherSprite, spin, maxTorque);
        cpConstraintSetUserData(joint, (void*)sMotorStr);
        if (!joint) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpConstraintWrap::NewFromCpp(isolate, joint) ); return; };
        ;
    }

    void SpriteWrap::RemoveJoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object CpConstraint] joint)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, joint, cpConstraint);
        self->removeJoint(joint);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::Disconnect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Sprite] otherSprite = ALL_SPRITES)" " - " "") ); return; };
        };
        Sprite* otherSprite = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Sprite"" (""otherSprite"")");
            }
            else
            {
                v8::Local<v8::Object> otherSprite_ = args[1 -1]->ToObject();
                SpriteWrap* otherSprite__ = jswrap::ObjectWrap::Unwrap< SpriteWrap>( otherSprite_);
                otherSprite = otherSprite__->getCppObject();
            }
        };
        self->disconnect(otherSprite);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::MakeJointBreakable(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object CpConstraint] joint, number breakingForce)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, joint, cpConstraint);
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""breakingForce"")");
        double breakingForce = args[2 -1]->NumberValue();
        self->makeJointBreakable(joint, breakingForce);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteWrap::MakeJointUnbreakable(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object CpConstraint] joint)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, joint, cpConstraint);
        self->makeJointUnbreakable(joint);
        args.GetReturnValue().SetUndefined();
    }
#endif

    void CleanupSpriteScriptObject(v8::Persistent<v8::Object> &obj) { }

    Sprite* New_Sprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_Sprite_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return new Sprite();
    }

    static bool s_SpriteLayer_InNewFromCpp = false;

    void SpriteLayerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = new SpriteLayerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> SpriteLayerWrap::NewFromCpp(v8::Isolate* isolate, SpriteLayer* cppObj)
    {
        s_SpriteLayer_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(instance);

        cppObj->mEventEmitterScriptObj.Reset(isolate, obj); cppObj->mAnimatedScriptObj.Reset(isolate, obj); cppObj->mSpriteLayerScriptObj.Reset(isolate, obj);
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_SpriteLayer_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> SpriteLayerWrap::constructorTpl_;

    void SpriteLayerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "SpriteLayer", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(isolate, GetBoundingBox, v8::Local<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""BoundingBox", v8::String::kInternalizedString), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotatedBounds, v8::Local<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RotatedBounds", v8::String::kInternalizedString), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, GetLocation, v8::Local<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Location", v8::String::kInternalizedString), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, SetLocation, v8::Local<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Location", v8::String::kInternalizedString), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpeed, v8::Local<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Speed", v8::String::kInternalizedString), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpeed, v8::Local<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Speed", v8::String::kInternalizedString), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, GetVelocity, v8::Local<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Velocity", v8::String::kInternalizedString), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocity, v8::Local<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Velocity", v8::String::kInternalizedString), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, SetWidth, v8::Local<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Width", v8::String::kInternalizedString), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, SetHeight, v8::Local<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Height", v8::String::kInternalizedString), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotation, v8::Local<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Rotation", v8::String::kInternalizedString), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, SetRotation, v8::Local<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Rotation", v8::String::kInternalizedString), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, GetCenterOffset, v8::Local<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CenterOffset", v8::String::kInternalizedString), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, SetCenterOffset, v8::Local<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CenterOffset", v8::String::kInternalizedString), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpin, v8::Local<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Spin", v8::String::kInternalizedString), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpin, v8::Local<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Spin", v8::String::kInternalizedString), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(isolate, GetMass, v8::Local<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Mass", v8::String::kInternalizedString), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(isolate, SetMass, v8::Local<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Mass", v8::String::kInternalizedString), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetMoveFriction, v8::Local<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MoveFriction", v8::String::kInternalizedString), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetMoveFriction, v8::Local<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MoveFriction", v8::String::kInternalizedString), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpinFriction, v8::Local<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpinFriction", v8::String::kInternalizedString), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpinFriction, v8::Local<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpinFriction", v8::String::kInternalizedString), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSizeFriction, v8::Local<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SizeFriction", v8::String::kInternalizedString), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSizeFriction, v8::Local<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SizeFriction", v8::String::kInternalizedString), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(isolate, Move, v8::Local<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "move", v8::String::kInternalizedString), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(isolate, MoveTo, v8::Local<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveTo", v8::String::kInternalizedString), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocityInRadians, v8::Local<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setVelocityInRadians", v8::String::kInternalizedString), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, GetMovementDirectionInRadians, v8::Local<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMovementDirectionInRadians", v8::String::kInternalizedString), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(isolate, StopMoving, v8::Local<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopMoving", v8::String::kInternalizedString), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(isolate, Accelerate, v8::Local<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerate", v8::String::kInternalizedString), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(isolate, AccelerateTo, v8::Local<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerateTo", v8::String::kInternalizedString), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(isolate, SetSize, v8::Local<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSize", v8::String::kInternalizedString), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(isolate, Grow, v8::Local<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "grow", v8::String::kInternalizedString), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(isolate, Stretch, v8::Local<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stretch", v8::String::kInternalizedString), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StartGrowing, v8::Local<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startGrowing", v8::String::kInternalizedString), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StopGrowing, v8::Local<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopGrowing", v8::String::kInternalizedString), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StartStretching, v8::Local<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startStretching", v8::String::kInternalizedString), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StopStretching, v8::Local<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopStretching", v8::String::kInternalizedString), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(isolate, Resize, v8::Local<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resize", v8::String::kInternalizedString), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(isolate, ResizeTo, v8::Local<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resizeTo", v8::String::kInternalizedString), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(isolate, Rotate, v8::Local<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotate", v8::String::kInternalizedString), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(isolate, RotateTo, v8::Local<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotateTo", v8::String::kInternalizedString), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(isolate, StopSpinning, v8::Local<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopSpinning", v8::String::kInternalizedString), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenter, v8::Local<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenter", v8::String::kInternalizedString), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenterTo, v8::Local<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenterTo", v8::String::kInternalizedString), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(isolate, Wait, v8::Local<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "wait", v8::String::kInternalizedString), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetFriction, v8::Local<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFriction", v8::String::kInternalizedString), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyForce, v8::Local<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyForce", v8::String::kInternalizedString), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyTorque, v8::Local<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyTorque", v8::String::kInternalizedString), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(isolate, StopAllForces, v8::Local<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAllForces", v8::String::kInternalizedString), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, AddAnimationHelper, v8::Local<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addAnimationHelper", v8::String::kInternalizedString), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAnimationHelper, v8::Local<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAnimationHelper", v8::String::kInternalizedString), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(isolate, ClearAnimationHelpers, v8::Local<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clearAnimationHelpers", v8::String::kInternalizedString), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> GetMyClassTag_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMyClassTag_Tpl =
            v8::FunctionTemplate::New(isolate, GetMyClassTag, v8::Local<v8::Value>(), GetMyClassTag_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MyClassTag", v8::String::kInternalizedString), GetMyClassTag_Tpl);
        v8::Local<v8::Signature> GetSerializedSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSerializedSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetSerializedSize, v8::Local<v8::Value>(), GetSerializedSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SerializedSize", v8::String::kInternalizedString), GetSerializedSize_Tpl);
        v8::Local<v8::Signature> Serialize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Serialize_Tpl =
            v8::FunctionTemplate::New(isolate, Serialize, v8::Local<v8::Value>(), Serialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "serialize", v8::String::kInternalizedString), Serialize_Tpl);
        v8::Local<v8::Signature> Deserialize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Deserialize_Tpl =
            v8::FunctionTemplate::New(isolate, Deserialize, v8::Local<v8::Value>(), Deserialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "deserialize", v8::String::kInternalizedString), Deserialize_Tpl);
        v8::Local<v8::Signature> SetSerializationFlags_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSerializationFlags_Tpl =
            v8::FunctionTemplate::New(isolate, SetSerializationFlags, v8::Local<v8::Value>(), SetSerializationFlags_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSerializationFlags", v8::String::kInternalizedString), SetSerializationFlags_Tpl);
        v8::Local<v8::Signature> StartAnimations_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartAnimations_Tpl =
            v8::FunctionTemplate::New(isolate, StartAnimations, v8::Local<v8::Value>(), StartAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startAnimations", v8::String::kInternalizedString), StartAnimations_Tpl);
        v8::Local<v8::Signature> StopAnimations_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAnimations_Tpl =
            v8::FunctionTemplate::New(isolate, StopAnimations, v8::Local<v8::Value>(), StopAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAnimations", v8::String::kInternalizedString), StopAnimations_Tpl);
        v8::Local<v8::Signature> Hide_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Hide_Tpl =
            v8::FunctionTemplate::New(isolate, Hide, v8::Local<v8::Value>(), Hide_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "hide", v8::String::kInternalizedString), Hide_Tpl);
        v8::Local<v8::Signature> Show_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Show_Tpl =
            v8::FunctionTemplate::New(isolate, Show, v8::Local<v8::Value>(), Show_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "show", v8::String::kInternalizedString), Show_Tpl);
        v8::Local<v8::Signature> IsHidden_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsHidden_Tpl =
            v8::FunctionTemplate::New(isolate, IsHidden, v8::Local<v8::Value>(), IsHidden_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isHidden", v8::String::kInternalizedString), IsHidden_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(isolate, FadeIn, v8::Local<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeIn", v8::String::kInternalizedString), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(isolate, FadeOut, v8::Local<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeOut", v8::String::kInternalizedString), FadeOut_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(isolate, MoveBehind, v8::Local<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveBehind", v8::String::kInternalizedString), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(isolate, MoveInFrontOf, v8::Local<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveInFrontOf", v8::String::kInternalizedString), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToFront, v8::Local<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToFront", v8::String::kInternalizedString), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToBack, v8::Local<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToBack", v8::String::kInternalizedString), MoveToBack_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(isolate, GetZOrder, v8::Local<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getZOrder", v8::String::kInternalizedString), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveWith_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveWith_Tpl =
            v8::FunctionTemplate::New(isolate, MoveWith, v8::Local<v8::Value>(), MoveWith_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveWith", v8::String::kInternalizedString), MoveWith_Tpl);
        v8::Local<v8::Signature> FindSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FindSprite_Tpl =
            v8::FunctionTemplate::New(isolate, FindSprite, v8::Local<v8::Value>(), FindSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "findSprite", v8::String::kInternalizedString), FindSprite_Tpl);
        v8::Local<v8::Signature> GetNthSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNthSprite_Tpl =
            v8::FunctionTemplate::New(isolate, GetNthSprite, v8::Local<v8::Value>(), GetNthSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getNthSprite", v8::String::kInternalizedString), GetNthSprite_Tpl);
        v8::Local<v8::Signature> GetSpriteZOrder_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpriteZOrder_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpriteZOrder, v8::Local<v8::Value>(), GetSpriteZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpriteZOrder", v8::String::kInternalizedString), GetSpriteZOrder_Tpl);
        v8::Local<v8::Signature> IsSpriteBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsSpriteBehind_Tpl =
            v8::FunctionTemplate::New(isolate, IsSpriteBehind, v8::Local<v8::Value>(), IsSpriteBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isSpriteBehind", v8::String::kInternalizedString), IsSpriteBehind_Tpl);
        v8::Local<v8::Signature> HasSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> HasSprite_Tpl =
            v8::FunctionTemplate::New(isolate, HasSprite, v8::Local<v8::Value>(), HasSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "hasSprite", v8::String::kInternalizedString), HasSprite_Tpl);
        v8::Local<v8::Signature> AddSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddSprite_Tpl =
            v8::FunctionTemplate::New(isolate, AddSprite, v8::Local<v8::Value>(), AddSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addSprite", v8::String::kInternalizedString), AddSprite_Tpl);
        v8::Local<v8::Signature> RemoveSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveSprite_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveSprite, v8::Local<v8::Value>(), RemoveSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeSprite", v8::String::kInternalizedString), RemoveSprite_Tpl);
        v8::Local<v8::Signature> RemoveAllSprites_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAllSprites_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAllSprites, v8::Local<v8::Value>(), RemoveAllSprites_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAllSprites", v8::String::kInternalizedString), RemoveAllSprites_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, EnableCollisions, v8::Local<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "enableCollisions", v8::String::kInternalizedString), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, DisableCollisions, v8::Local<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disableCollisions", v8::String::kInternalizedString), DisableCollisions_Tpl);
        v8::Local<v8::Signature> EnableCollisionsWithLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> EnableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(isolate, EnableCollisionsWithLayer, v8::Local<v8::Value>(), EnableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "enableCollisionsWithLayer", v8::String::kInternalizedString), EnableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> DisableCollisionsWithLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DisableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(isolate, DisableCollisionsWithLayer, v8::Local<v8::Value>(), DisableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disableCollisionsWithLayer", v8::String::kInternalizedString), DisableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> CreateSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateSprite_Tpl =
            v8::FunctionTemplate::New(isolate, CreateSprite, v8::Local<v8::Value>(), CreateSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createSprite", v8::String::kInternalizedString), CreateSprite_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> GetSpritePort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpritePort_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpritePort, v8::Local<v8::Value>(), GetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpritePort", v8::String::kInternalizedString), GetSpritePort_Tpl);
        v8::Local<v8::Signature> SetSpritePort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpritePort_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpritePort, v8::Local<v8::Value>(), SetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSpritePort", v8::String::kInternalizedString), SetSpritePort_Tpl);
        v8::Local<v8::Signature> SetOrigin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOrigin_Tpl =
            v8::FunctionTemplate::New(isolate, SetOrigin, v8::Local<v8::Value>(), SetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setOrigin", v8::String::kInternalizedString), SetOrigin_Tpl);
        v8::Local<v8::Signature> GetOrigin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOrigin_Tpl =
            v8::FunctionTemplate::New(isolate, GetOrigin, v8::Local<v8::Value>(), GetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getOrigin", v8::String::kInternalizedString), GetOrigin_Tpl);
        v8::Local<v8::Signature> SetAutoCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetAutoCenter_Tpl =
            v8::FunctionTemplate::New(isolate, SetAutoCenter, v8::Local<v8::Value>(), SetAutoCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setAutoCenter", v8::String::kInternalizedString), SetAutoCenter_Tpl);
        v8::Local<v8::Signature> SetFixedMoveAxis_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFixedMoveAxis_Tpl =
            v8::FunctionTemplate::New(isolate, SetFixedMoveAxis, v8::Local<v8::Value>(), SetFixedMoveAxis_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFixedMoveAxis", v8::String::kInternalizedString), SetFixedMoveAxis_Tpl);
        v8::Local<v8::Signature> SetZoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetZoom_Tpl =
            v8::FunctionTemplate::New(isolate, SetZoom, v8::Local<v8::Value>(), SetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setZoom", v8::String::kInternalizedString), SetZoom_Tpl);
        v8::Local<v8::Signature> GetZoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetZoom_Tpl =
            v8::FunctionTemplate::New(isolate, GetZoom, v8::Local<v8::Value>(), GetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getZoom", v8::String::kInternalizedString), GetZoom_Tpl);
        v8::Local<v8::Signature> ZoomTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ZoomTo_Tpl =
            v8::FunctionTemplate::New(isolate, ZoomTo, v8::Local<v8::Value>(), ZoomTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "zoomTo", v8::String::kInternalizedString), ZoomTo_Tpl);
        v8::Local<v8::Signature> Zoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Zoom_Tpl =
            v8::FunctionTemplate::New(isolate, Zoom, v8::Local<v8::Value>(), Zoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "zoom", v8::String::kInternalizedString), Zoom_Tpl);
        v8::Local<v8::Signature> LayerToPortPoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortPoint_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortPoint, v8::Local<v8::Value>(), LayerToPortPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortPoint", v8::String::kInternalizedString), LayerToPortPoint_Tpl);
        v8::Local<v8::Signature> LayerToPortOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortOffset_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortOffset, v8::Local<v8::Value>(), LayerToPortOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortOffset", v8::String::kInternalizedString), LayerToPortOffset_Tpl);
        v8::Local<v8::Signature> LayerToPortVector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortVector_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortVector, v8::Local<v8::Value>(), LayerToPortVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortVector", v8::String::kInternalizedString), LayerToPortVector_Tpl);
        v8::Local<v8::Signature> LayerToPortRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortRect_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortRect, v8::Local<v8::Value>(), LayerToPortRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortRect", v8::String::kInternalizedString), LayerToPortRect_Tpl);
        v8::Local<v8::Signature> LayerToPortQuad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortQuad_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortQuad, v8::Local<v8::Value>(), LayerToPortQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortQuad", v8::String::kInternalizedString), LayerToPortQuad_Tpl);
        v8::Local<v8::Signature> PortToLayerPoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerPoint_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerPoint, v8::Local<v8::Value>(), PortToLayerPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerPoint", v8::String::kInternalizedString), PortToLayerPoint_Tpl);
        v8::Local<v8::Signature> PortToLayerOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerOffset_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerOffset, v8::Local<v8::Value>(), PortToLayerOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerOffset", v8::String::kInternalizedString), PortToLayerOffset_Tpl);
        v8::Local<v8::Signature> PortToLayerVector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerVector_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerVector, v8::Local<v8::Value>(), PortToLayerVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerVector", v8::String::kInternalizedString), PortToLayerVector_Tpl);
        v8::Local<v8::Signature> PortToLayerRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerRect_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerRect, v8::Local<v8::Value>(), PortToLayerRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerRect", v8::String::kInternalizedString), PortToLayerRect_Tpl);
        v8::Local<v8::Signature> PortToLayerQuad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerQuad_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerQuad, v8::Local<v8::Value>(), PortToLayerQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerQuad", v8::String::kInternalizedString), PortToLayerQuad_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> SetGravity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGravity_Tpl =
            v8::FunctionTemplate::New(isolate, SetGravity, v8::Local<v8::Value>(), SetGravity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setGravity", v8::String::kInternalizedString), SetGravity_Tpl);
        v8::Local<v8::Signature> SetUseChipmunkPhysics_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetUseChipmunkPhysics_Tpl =
            v8::FunctionTemplate::New(isolate, SetUseChipmunkPhysics, v8::Local<v8::Value>(), SetUseChipmunkPhysics_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setUseChipmunkPhysics", v8::String::kInternalizedString), SetUseChipmunkPhysics_Tpl);
        v8::Local<v8::Signature> SetStaticLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetStaticLayer_Tpl =
            v8::FunctionTemplate::New(isolate, SetStaticLayer, v8::Local<v8::Value>(), SetStaticLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setStaticLayer", v8::String::kInternalizedString), SetStaticLayer_Tpl);
        v8::Local<v8::Signature> SetKeepGravityDownward_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetKeepGravityDownward_Tpl =
            v8::FunctionTemplate::New(isolate, SetKeepGravityDownward, v8::Local<v8::Value>(), SetKeepGravityDownward_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setKeepGravityDownward", v8::String::kInternalizedString), SetKeepGravityDownward_Tpl);
        v8::Local<v8::Signature> SetDamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetDamping_Tpl =
            v8::FunctionTemplate::New(isolate, SetDamping, v8::Local<v8::Value>(), SetDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setDamping", v8::String::kInternalizedString), SetDamping_Tpl);
        v8::Local<v8::Signature> GetSpace_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpace_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpace, v8::Local<v8::Value>(), GetSpace_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpace", v8::String::kInternalizedString), GetSpace_Tpl);
#endif
#ifdef PDG_SCML_SUPPORT
        v8::Local<v8::Signature> CreateSpriteFromSCML_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCML_Tpl =
            v8::FunctionTemplate::New(isolate, CreateSpriteFromSCML, v8::Local<v8::Value>(), CreateSpriteFromSCML_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createSpriteFromSCML", v8::String::kInternalizedString), CreateSpriteFromSCML_Tpl);
        v8::Local<v8::Signature> CreateSpriteFromSCMLFile_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCMLFile_Tpl =
            v8::FunctionTemplate::New(isolate, CreateSpriteFromSCMLFile, v8::Local<v8::Value>(), CreateSpriteFromSCMLFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createSpriteFromSCMLFile", v8::String::kInternalizedString), CreateSpriteFromSCMLFile_Tpl);
        v8::Local<v8::Signature> CreateSpriteFromSCMLEntity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCMLEntity_Tpl =
            v8::FunctionTemplate::New(isolate, CreateSpriteFromSCMLEntity, v8::Local<v8::Value>(), CreateSpriteFromSCMLEntity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createSpriteFromSCMLEntity", v8::String::kInternalizedString), CreateSpriteFromSCMLEntity_Tpl);
#endif
        target->Set(v8::String::NewFromUtf8(isolate, "SpriteLayer", v8::String::kInternalizedString), t->GetFunction());

    }

    void SpriteLayerWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 4321 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 4321 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 4321 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 4321 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 4321 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::GetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, theLocation) ); return; };
    }

    void SpriteLayerWrap::SetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "([object Point] inLocation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(isolate, args[1 -1]);

        self->setLocation(theLocation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpeed = self->getSpeed();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpeed) ); return; };
    }

    void SpriteLayerWrap::SetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inSpeed)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theWidth) ); return; };
    }

    void SpriteLayerWrap::SetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inWidth)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theHeight) ); return; };
    }

    void SpriteLayerWrap::SetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inHeight)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theRotation = self->getRotation();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRotation) ); return; };
    }

    void SpriteLayerWrap::SetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inRotation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theCenterOffset) ); return; };
    }

    void SpriteLayerWrap::SetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "([object Offset] inCenterOffset)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(isolate, args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpin = self->getSpin();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpin) ); return; };
    }

    void SpriteLayerWrap::SetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inSpin)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMass = self->getMass();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMass) ); return; };
    }

    void SpriteLayerWrap::SetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inMass)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMoveFriction) ); return; };
    }

    void SpriteLayerWrap::SetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inMoveFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpinFriction) ); return; };
    }

    void SpriteLayerWrap::SetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inSpinFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSizeFriction) ); return; };
    }

    void SpriteLayerWrap::SetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(number inSizeFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetBoundingBox(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void SpriteLayerWrap::GetRotatedBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void SpriteLayerWrap::Move(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            delta = v8_ValueToOffset(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(isolate, args[0]))
        {
            where = v8_ValueToPoint(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetVelocityInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number speed, number direction)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetMovementDirectionInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        { args.GetReturnValue().Set( v8::Number::New(isolate, dir) ); return; };
    }

    void SpriteLayerWrap::SetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "({[object Vector] deltaPerSec|number deltaXPerSec, number deltaYPerSec})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(isolate, args[0]))
        {
            deltaPerSec = v8_ValueToVector(isolate, args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::GetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, theVelocity) ); return; };
    }

    void SpriteLayerWrap::StopMoving(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopMoving();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Accelerate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::AccelerateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number width, number height)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::Grow(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Stretch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StartGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number amountPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StopGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopGrowing();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StartStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StopStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopStretching();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Resize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::ResizeTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Rotate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::RotateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StopSpinning(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopSpinning();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::ChangeCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::ChangeCenterTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Wait(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([number int] msDuration)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::SetFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number frictionCoefficient)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::ApplyForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::ApplyTorque(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StopAllForces(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAllForces();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::AddAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        self->mAnimatedScriptObj.Reset(isolate, args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 4322 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 4322 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 4322 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 4322 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 4322 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::RemoveAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::ClearAnimationHelpers(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clearAnimationHelpers();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::GetMyClassTag(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        uint32 theMyClassTag = self->getMyClassTag();
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, theMyClassTag) ); return; };
    }

    void SpriteLayerWrap::GetSerializedSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR [number uint]" " function" "([object Serializer] serializer)" " - " "get size of this object's data for the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, serializer, Serializer);
        uint32 dataSize = self->getSerializedSize(serializer);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, dataSize) ); return; };
    }

    void SpriteLayerWrap::Serialize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "([object Serializer] serializer)" " - " "write this object's data into the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, serializer, Serializer);
        self->serialize(serializer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Deserialize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "CR undefined" " function" "([object Deserializer] deserializer)" " - " "read this object's data from the given stream") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, deserializer, Deserializer);
        try
        {
            self->deserialize(deserializer);
            args.GetReturnValue().SetUndefined();
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(sync_error& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            isolate->ThrowException( v8::Exception::Error( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
    }

#ifndef PDG_NO_GUI

    void SpriteLayerWrap::GetSpritePort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Port* port = self->getSpritePort();
        if (!port) args.GetReturnValue().SetNull();
        if (port->mPortScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( PortWrap::NewFromCpp(isolate, port) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, port->mPortScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void SpriteLayerWrap::SetSpritePort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Port] port)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, port, Port);
        self->setSpritePort(port);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetOrigin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] origin)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point origin = v8_ValueToPoint(isolate, args[1 -1]);
        self->setOrigin(origin);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::GetOrigin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()" " - " "get the point in the layer that is drawn at 0,0 in the port") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Point p = self->getOrigin();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, p) ); return; };
    }

    void SpriteLayerWrap::SetAutoCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean autoCenter = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""autoCenter"")");
        bool autoCenter = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setAutoCenter(autoCenter);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetFixedMoveAxis(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean fixedAxis = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""fixedAxis"")");
        bool fixedAxis = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setFixedMoveAxis(fixedAxis);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetZoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number zoomLevel)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        self->setZoom(zoomLevel);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::GetZoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "get the current zoom factor") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float zoom = self->getZoom();
        { args.GetReturnValue().Set( v8::Number::New(isolate, zoom) ); return; };
    }

    void SpriteLayerWrap::ZoomTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number zoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(isolate, args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoomTo(zoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoomTo(zoomLevel, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Zoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaZoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaZoomLevel"")");
        double deltaZoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(isolate, args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoom(deltaZoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoom(deltaZoomLevel, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::LayerToPortPoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([object Point] p)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
        Point out = self->layerToPort(p);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, out) ); return; };
    }

    void SpriteLayerWrap::LayerToPortOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "([object Offset] o)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(isolate, args[1 -1]);
        Offset out = self->layerToPort(o);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, out) ); return; };
    }

    void SpriteLayerWrap::LayerToPortVector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "([object Vector] v)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(isolate, args[1 -1]);
        Vector out = self->layerToPort(v);
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, out) ); return; };
    }

    void SpriteLayerWrap::LayerToPortRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "([object Rect] r)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(isolate, args[1 -1]);
        RotatedRect out = self->layerToPort(r);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, out) ); return; };
    }

    void SpriteLayerWrap::LayerToPortQuad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Quad]" " function" "([object Quad] q)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(isolate, args[1 -1]);
        Quad out = self->layerToPort(q);
        { args.GetReturnValue().Set( v8_MakeJavascriptQuad(isolate, out) ); return; };
    }

    void SpriteLayerWrap::PortToLayerPoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([object Point] p)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
        Point out = self->portToLayer(p);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, out) ); return; };
    }

    void SpriteLayerWrap::PortToLayerOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "([object Offset] o)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(isolate, args[1 -1]);
        Offset out = self->portToLayer(o);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, out) ); return; };
    }

    void SpriteLayerWrap::PortToLayerVector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "([object Vector] v)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(isolate, args[1 -1]);
        Vector out = self->portToLayer(v);
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, out) ); return; };
    }

    void SpriteLayerWrap::PortToLayerRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "([object Rect] r)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(isolate, args[1 -1]);
        RotatedRect out = self->portToLayer(r);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, out) ); return; };
    }

    void SpriteLayerWrap::PortToLayerQuad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Quad]" " function" "([object Quad] q)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(isolate, args[1 -1]);
        Quad out = self->portToLayer(q);
        { args.GetReturnValue().Set( v8_MakeJavascriptQuad(isolate, out) ); return; };
    }
#endif

    void SpriteLayerWrap::SetSerializationFlags(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "([number uint] flags)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""flags"")");
        unsigned long flags = args[1 -1]->Uint32Value();
        self->setSerializationFlags(flags);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void SpriteLayerWrap::StartAnimations(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->startAnimations();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::StopAnimations(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAnimations();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Hide(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->hide();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::Show(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->show();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::IsHidden(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool hidden = self->isHidden();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, hidden) ); return; };
    }

    void SpriteLayerWrap::FadeIn(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::FadeOut(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveBehind(layer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveInFrontOf(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveInFrontOf(layer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveToFront(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "move this layer in front of all other layers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToFront();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveToBack(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "move this layer behind all other layers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToBack();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::MoveWith(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer, number moveRatio = 1.0, number zoomRatio = 1.0 )" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""moveRatio"")");
        double moveRatio = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""zoomRatio"")");
        double zoomRatio = (args.Length()<3) ? 1.0f : args[3 -1]->NumberValue();;
        self->moveWith(layer, moveRatio, zoomRatio);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::IsSpriteBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Sprite] sprite, [object Sprite] otherSprite)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        REQUIRE_CPP_OBJECT_ARG(2, otherSprite, Sprite);
        bool behind = self->isSpriteBehind(sprite, otherSprite);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, behind) ); return; };
    }

    void SpriteLayerWrap::GetZOrder(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number int]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        int zorder = self->getZOrder();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, zorder) ); return; };
    }

    void SpriteLayerWrap::GetSpriteZOrder(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number int]" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        int zorder = self->getSpriteZOrder(sprite);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, zorder) ); return; };
    }

    void SpriteLayerWrap::FindSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        Sprite* sprite = self->findSprite(id);
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void SpriteLayerWrap::GetNthSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] index)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""index"")");
        long index = args[1 -1]->Int32Value();
        Sprite* sprite = self->getNthSprite(index);
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void SpriteLayerWrap::HasSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        bool found = self->hasSprite(sprite);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, found) ); return; };
    }

    void SpriteLayerWrap::AddSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Sprite] newSprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, newSprite, Sprite);
        self->addSprite(newSprite);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::RemoveSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Sprite] oldSprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, oldSprite, Sprite);
        self->removeSprite(oldSprite);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::RemoveAllSprites(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->removeAllSprites();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::EnableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->enableCollisions();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::DisableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->disableCollisions();
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::EnableCollisionsWithLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->enableCollisionsWithLayer(otherLayer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::DisableCollisionsWithLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->disableCollisionsWithLayer(otherLayer);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::CreateSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Sprite* sprite = self->createSprite();
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    void SpriteLayerWrap::SetKeepGravityDownward(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean keepItDownward = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setKeepGravityDownward(keepItDownward);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetGravity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number gravity, boolean keepItDownward = true)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""gravity"")");
        double gravity = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 2, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
        self->setGravity(gravity, keepItDownward);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetDamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number damping)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""damping"")");
        double damping = args[1 -1]->NumberValue();
        self->setDamping(damping);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetStaticLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean isStatic = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""isStatic"")");
        bool isStatic = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setStaticLayer(isStatic);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::SetUseChipmunkPhysics(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean useIt = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""useIt"")");
        bool useIt = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setUseChipmunkPhysics(useIt);
        args.GetReturnValue().SetUndefined();
    }

    void SpriteLayerWrap::GetSpace(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpSpace]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpSpace* space = self->getSpace();
        if (!space) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpSpaceWrap::NewFromCpp(isolate, space) ); return; };
        ;
    }
#endif

    void SpriteLayerWrap::CreateSpriteFromSCML(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(string inSCML, string inEntityName = null)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inSCML"")");
        v8::String::Utf8Value inSCML_Str(args[1 -1]->ToString());
        const char* inSCML = *inSCML_Str;;
        const char* inEntityName = 0;
        if (args.Length() >= 2 && args[1]->IsString())
        {
            if (!args[2 -1]->IsString())
                v8_ThrowArgTypeException(isolate, 2, "a string  (""entityName"")");
            v8::String::Utf8Value entityName_Str(args[2 -1]->ToString());
            const char* entityName = *entityName_Str;;
            inEntityName = entityName;
        }
        Sprite* sprite = self->createSpriteFromSCML(inSCML, inEntityName);
        if (!sprite) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        ;
    }

    void SpriteLayerWrap::CreateSpriteFromSCMLFile(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(string inFileName, string inEntityName = null)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inFileName"")");
        v8::String::Utf8Value inFileName_Str(args[1 -1]->ToString());
        const char* inFileName = *inFileName_Str;;
        const char* inEntityName = 0;
        if (args.Length() >= 2 && args[1]->IsString())
        {
            if (!args[2 -1]->IsString())
                v8_ThrowArgTypeException(isolate, 2, "a string  (""entityName"")");
            v8::String::Utf8Value entityName_Str(args[2 -1]->ToString());
            const char* entityName = *entityName_Str;;
            inEntityName = entityName;
        }
        Sprite* sprite = self->createSpriteFromSCMLFile(inFileName, inEntityName);
        if (!sprite) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        ;
    }

    void SpriteLayerWrap::CreateSpriteFromSCMLEntity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "(string inEntityName)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""inEntityName"")");
        v8::String::Utf8Value inEntityName_Str(args[1 -1]->ToString());
        const char* inEntityName = *inEntityName_Str;;
        Sprite* sprite = self->createSpriteFromSCMLEntity(inEntityName);
        if (!sprite) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        ;
    }

    void CleanupSpriteLayerScriptObject(v8::Persistent<v8::Object> &obj) { }

    SpriteLayer* New_SpriteLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_SpriteLayer_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
#ifndef PDG_NO_GUI
        Port* port = GraphicsManager::getSingletonInstance()->getMainPort();
        return createSpriteLayer(port);
#else
        return createSpriteLayer();
#endif
    }

    void CreateSpriteLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "([object Port] port = null)" " - " "") ); return; };
        };
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        SpriteLayer* layer = createSpriteLayer(port);
#else
        SpriteLayer* layer = createSpriteLayer();
#endif
        if (!layer) args.GetReturnValue().SetNull();
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteLayerWrap::NewFromCpp(isolate, layer) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, layer->mSpriteLayerScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void CreateSpriteLayerFromSCMLFile(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "(string layerSCMLFilename, boolean addSprites = true, [object Port] port = null)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            v8_ThrowArgTypeException(isolate, 1, "a string  (""layerSCMLFilename"")");
        v8::String::Utf8Value layerSCMLFilename_Str(args[1 -1]->ToString());
        const char* layerSCMLFilename = *layerSCMLFilename_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 2, "a boolean (""addSprites"")");
        bool addSprites = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 3)
        {
            if (!args[3 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 3, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[3 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        SpriteLayer* layer = createSpriteLayerFromSCMLFile(layerSCMLFilename, addSprites, port);
#else
        SpriteLayer* layer = createSpriteLayerFromSCMLFile(layerSCMLFilename, addSprites);
#endif
        if (!layer) args.GetReturnValue().SetNull();
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteLayerWrap::NewFromCpp(isolate, layer) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, layer->mSpriteLayerScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void CleanupSpriteLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        cleanupSpriteLayer(layer);
        args.GetReturnValue().SetUndefined();
    }

    void CreateTileLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "([object Port] port = null)" " - " "") ); return; };
        };
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                v8_ThrowArgTypeException(isolate, 1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Local<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap< PortWrap>( port_);
                port = port__->getCppObject();
            }
        };
        TileLayer* layer = createTileLayer(port);
#else
        TileLayer* layer = createTileLayer();
#endif
        if (!layer) args.GetReturnValue().SetNull();
        if (layer->mTileLayerScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( TileLayerWrap::NewFromCpp(isolate, layer) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, layer->mTileLayerScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    ;
    ;

    static bool s_TileLayer_InNewFromCpp = false;

    void TileLayerWrap::New(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = new TileLayerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            v8::Local<v8::Value> s_err_ = v8::Local<v8::Value>::New(isolate, s_SavedError);
            isolate->ThrowException(s_err_);
        };
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    v8::Local<v8::Object> TileLayerWrap::NewFromCpp(v8::Isolate* isolate, TileLayer* cppObj)
    {
        s_TileLayer_InNewFromCpp = true;
        v8::EscapableHandleScope scope(isolate);
        v8::Local<v8::FunctionTemplate> constructor = v8::Local<v8::FunctionTemplate>::New(isolate, constructorTpl_);
        v8::Local<v8::Object> instance =
            constructor->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj(isolate, instance);
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(instance);

        cppObj->mEventEmitterScriptObj.Reset(isolate, obj); cppObj->mAnimatedScriptObj.Reset(isolate, obj); cppObj->mSpriteLayerScriptObj.Reset(isolate, obj); cppObj->mTileLayerScriptObj.Reset(isolate, obj);
        DEBUG_ASSERT(objWrapper->cppPtr_ == 0, "NewFromCpp() already have C++ object!");
        if (objWrapper->cppPtr_) delete objWrapper->cppPtr_;
        objWrapper->cppPtr_ = cppObj;
        s_TileLayer_InNewFromCpp = false;
        return scope.Escape(instance);
    }

    v8::Persistent<v8::FunctionTemplate> TileLayerWrap::constructorTpl_;

    void TileLayerWrap::Init(v8::Isolate* isolate, v8::Local<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate, New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewFromUtf8(isolate, "TileLayer", v8::String::kInternalizedString));
        constructorTpl_.Reset(isolate, t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(isolate, AddHandler, v8::Local<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addHandler", v8::String::kInternalizedString), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveHandler, v8::Local<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeHandler", v8::String::kInternalizedString), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(isolate, Clear, v8::Local<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clear", v8::String::kInternalizedString), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, BlockEvent, v8::Local<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "blockEvent", v8::String::kInternalizedString), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(isolate, UnblockEvent, v8::Local<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "unblockEvent", v8::String::kInternalizedString), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(isolate, GetBoundingBox, v8::Local<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""BoundingBox", v8::String::kInternalizedString), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotatedBounds, v8::Local<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""RotatedBounds", v8::String::kInternalizedString), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, GetLocation, v8::Local<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Location", v8::String::kInternalizedString), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(isolate, SetLocation, v8::Local<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Location", v8::String::kInternalizedString), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpeed, v8::Local<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Speed", v8::String::kInternalizedString), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpeed, v8::Local<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Speed", v8::String::kInternalizedString), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, GetVelocity, v8::Local<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Velocity", v8::String::kInternalizedString), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocity, v8::Local<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Velocity", v8::String::kInternalizedString), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, GetWidth, v8::Local<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Width", v8::String::kInternalizedString), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(isolate, SetWidth, v8::Local<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Width", v8::String::kInternalizedString), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, GetHeight, v8::Local<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Height", v8::String::kInternalizedString), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(isolate, SetHeight, v8::Local<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Height", v8::String::kInternalizedString), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, GetRotation, v8::Local<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Rotation", v8::String::kInternalizedString), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(isolate, SetRotation, v8::Local<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Rotation", v8::String::kInternalizedString), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, GetCenterOffset, v8::Local<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""CenterOffset", v8::String::kInternalizedString), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(isolate, SetCenterOffset, v8::Local<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""CenterOffset", v8::String::kInternalizedString), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpin, v8::Local<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Spin", v8::String::kInternalizedString), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpin, v8::Local<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Spin", v8::String::kInternalizedString), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(isolate, GetMass, v8::Local<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""Mass", v8::String::kInternalizedString), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(isolate, SetMass, v8::Local<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""Mass", v8::String::kInternalizedString), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetMoveFriction, v8::Local<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""MoveFriction", v8::String::kInternalizedString), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetMoveFriction, v8::Local<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""MoveFriction", v8::String::kInternalizedString), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpinFriction, v8::Local<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SpinFriction", v8::String::kInternalizedString), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpinFriction, v8::Local<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SpinFriction", v8::String::kInternalizedString), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, GetSizeFriction, v8::Local<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "get""SizeFriction", v8::String::kInternalizedString), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetSizeFriction, v8::Local<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "set""SizeFriction", v8::String::kInternalizedString), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(isolate, Move, v8::Local<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "move", v8::String::kInternalizedString), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(isolate, MoveTo, v8::Local<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveTo", v8::String::kInternalizedString), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, SetVelocityInRadians, v8::Local<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setVelocityInRadians", v8::String::kInternalizedString), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(isolate, GetMovementDirectionInRadians, v8::Local<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMovementDirectionInRadians", v8::String::kInternalizedString), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(isolate, StopMoving, v8::Local<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopMoving", v8::String::kInternalizedString), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(isolate, Accelerate, v8::Local<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerate", v8::String::kInternalizedString), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(isolate, AccelerateTo, v8::Local<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "accelerateTo", v8::String::kInternalizedString), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(isolate, SetSize, v8::Local<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSize", v8::String::kInternalizedString), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(isolate, Grow, v8::Local<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "grow", v8::String::kInternalizedString), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(isolate, Stretch, v8::Local<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stretch", v8::String::kInternalizedString), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StartGrowing, v8::Local<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startGrowing", v8::String::kInternalizedString), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(isolate, StopGrowing, v8::Local<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopGrowing", v8::String::kInternalizedString), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StartStretching, v8::Local<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startStretching", v8::String::kInternalizedString), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(isolate, StopStretching, v8::Local<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopStretching", v8::String::kInternalizedString), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(isolate, Resize, v8::Local<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resize", v8::String::kInternalizedString), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(isolate, ResizeTo, v8::Local<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "resizeTo", v8::String::kInternalizedString), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(isolate, Rotate, v8::Local<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotate", v8::String::kInternalizedString), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(isolate, RotateTo, v8::Local<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "rotateTo", v8::String::kInternalizedString), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(isolate, StopSpinning, v8::Local<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopSpinning", v8::String::kInternalizedString), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenter, v8::Local<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenter", v8::String::kInternalizedString), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(isolate, ChangeCenterTo, v8::Local<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "changeCenterTo", v8::String::kInternalizedString), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(isolate, Wait, v8::Local<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "wait", v8::String::kInternalizedString), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(isolate, SetFriction, v8::Local<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFriction", v8::String::kInternalizedString), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyForce, v8::Local<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyForce", v8::String::kInternalizedString), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(isolate, ApplyTorque, v8::Local<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "applyTorque", v8::String::kInternalizedString), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(isolate, StopAllForces, v8::Local<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAllForces", v8::String::kInternalizedString), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, AddAnimationHelper, v8::Local<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addAnimationHelper", v8::String::kInternalizedString), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAnimationHelper, v8::Local<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAnimationHelper", v8::String::kInternalizedString), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(isolate, ClearAnimationHelpers, v8::Local<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "clearAnimationHelpers", v8::String::kInternalizedString), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> SetSerializationFlags_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSerializationFlags_Tpl =
            v8::FunctionTemplate::New(isolate, SetSerializationFlags, v8::Local<v8::Value>(), SetSerializationFlags_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSerializationFlags", v8::String::kInternalizedString), SetSerializationFlags_Tpl);
        v8::Local<v8::Signature> StartAnimations_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StartAnimations_Tpl =
            v8::FunctionTemplate::New(isolate, StartAnimations, v8::Local<v8::Value>(), StartAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "startAnimations", v8::String::kInternalizedString), StartAnimations_Tpl);
        v8::Local<v8::Signature> StopAnimations_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> StopAnimations_Tpl =
            v8::FunctionTemplate::New(isolate, StopAnimations, v8::Local<v8::Value>(), StopAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "stopAnimations", v8::String::kInternalizedString), StopAnimations_Tpl);
        v8::Local<v8::Signature> Hide_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Hide_Tpl =
            v8::FunctionTemplate::New(isolate, Hide, v8::Local<v8::Value>(), Hide_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "hide", v8::String::kInternalizedString), Hide_Tpl);
        v8::Local<v8::Signature> Show_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Show_Tpl =
            v8::FunctionTemplate::New(isolate, Show, v8::Local<v8::Value>(), Show_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "show", v8::String::kInternalizedString), Show_Tpl);
        v8::Local<v8::Signature> IsHidden_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsHidden_Tpl =
            v8::FunctionTemplate::New(isolate, IsHidden, v8::Local<v8::Value>(), IsHidden_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isHidden", v8::String::kInternalizedString), IsHidden_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(isolate, FadeIn, v8::Local<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeIn", v8::String::kInternalizedString), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(isolate, FadeOut, v8::Local<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "fadeOut", v8::String::kInternalizedString), FadeOut_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(isolate, MoveBehind, v8::Local<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveBehind", v8::String::kInternalizedString), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(isolate, MoveInFrontOf, v8::Local<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveInFrontOf", v8::String::kInternalizedString), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToFront, v8::Local<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToFront", v8::String::kInternalizedString), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(isolate, MoveToBack, v8::Local<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveToBack", v8::String::kInternalizedString), MoveToBack_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(isolate, GetZOrder, v8::Local<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getZOrder", v8::String::kInternalizedString), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveWith_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> MoveWith_Tpl =
            v8::FunctionTemplate::New(isolate, MoveWith, v8::Local<v8::Value>(), MoveWith_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "moveWith", v8::String::kInternalizedString), MoveWith_Tpl);
        v8::Local<v8::Signature> FindSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> FindSprite_Tpl =
            v8::FunctionTemplate::New(isolate, FindSprite, v8::Local<v8::Value>(), FindSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "findSprite", v8::String::kInternalizedString), FindSprite_Tpl);
        v8::Local<v8::Signature> GetNthSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetNthSprite_Tpl =
            v8::FunctionTemplate::New(isolate, GetNthSprite, v8::Local<v8::Value>(), GetNthSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getNthSprite", v8::String::kInternalizedString), GetNthSprite_Tpl);
        v8::Local<v8::Signature> GetSpriteZOrder_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpriteZOrder_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpriteZOrder, v8::Local<v8::Value>(), GetSpriteZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpriteZOrder", v8::String::kInternalizedString), GetSpriteZOrder_Tpl);
        v8::Local<v8::Signature> IsSpriteBehind_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> IsSpriteBehind_Tpl =
            v8::FunctionTemplate::New(isolate, IsSpriteBehind, v8::Local<v8::Value>(), IsSpriteBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "isSpriteBehind", v8::String::kInternalizedString), IsSpriteBehind_Tpl);
        v8::Local<v8::Signature> HasSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> HasSprite_Tpl =
            v8::FunctionTemplate::New(isolate, HasSprite, v8::Local<v8::Value>(), HasSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "hasSprite", v8::String::kInternalizedString), HasSprite_Tpl);
        v8::Local<v8::Signature> AddSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> AddSprite_Tpl =
            v8::FunctionTemplate::New(isolate, AddSprite, v8::Local<v8::Value>(), AddSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "addSprite", v8::String::kInternalizedString), AddSprite_Tpl);
        v8::Local<v8::Signature> RemoveSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveSprite_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveSprite, v8::Local<v8::Value>(), RemoveSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeSprite", v8::String::kInternalizedString), RemoveSprite_Tpl);
        v8::Local<v8::Signature> RemoveAllSprites_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> RemoveAllSprites_Tpl =
            v8::FunctionTemplate::New(isolate, RemoveAllSprites, v8::Local<v8::Value>(), RemoveAllSprites_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "removeAllSprites", v8::String::kInternalizedString), RemoveAllSprites_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, EnableCollisions, v8::Local<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "enableCollisions", v8::String::kInternalizedString), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(isolate, DisableCollisions, v8::Local<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disableCollisions", v8::String::kInternalizedString), DisableCollisions_Tpl);
        v8::Local<v8::Signature> EnableCollisionsWithLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> EnableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(isolate, EnableCollisionsWithLayer, v8::Local<v8::Value>(), EnableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "enableCollisionsWithLayer", v8::String::kInternalizedString), EnableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> DisableCollisionsWithLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DisableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(isolate, DisableCollisionsWithLayer, v8::Local<v8::Value>(), DisableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "disableCollisionsWithLayer", v8::String::kInternalizedString), DisableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> CreateSprite_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CreateSprite_Tpl =
            v8::FunctionTemplate::New(isolate, CreateSprite, v8::Local<v8::Value>(), CreateSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "createSprite", v8::String::kInternalizedString), CreateSprite_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> GetSpritePort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpritePort_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpritePort, v8::Local<v8::Value>(), GetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpritePort", v8::String::kInternalizedString), GetSpritePort_Tpl);
        v8::Local<v8::Signature> SetSpritePort_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetSpritePort_Tpl =
            v8::FunctionTemplate::New(isolate, SetSpritePort, v8::Local<v8::Value>(), SetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setSpritePort", v8::String::kInternalizedString), SetSpritePort_Tpl);
        v8::Local<v8::Signature> SetOrigin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetOrigin_Tpl =
            v8::FunctionTemplate::New(isolate, SetOrigin, v8::Local<v8::Value>(), SetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setOrigin", v8::String::kInternalizedString), SetOrigin_Tpl);
        v8::Local<v8::Signature> GetOrigin_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetOrigin_Tpl =
            v8::FunctionTemplate::New(isolate, GetOrigin, v8::Local<v8::Value>(), GetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getOrigin", v8::String::kInternalizedString), GetOrigin_Tpl);
        v8::Local<v8::Signature> SetAutoCenter_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetAutoCenter_Tpl =
            v8::FunctionTemplate::New(isolate, SetAutoCenter, v8::Local<v8::Value>(), SetAutoCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setAutoCenter", v8::String::kInternalizedString), SetAutoCenter_Tpl);
        v8::Local<v8::Signature> SetFixedMoveAxis_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetFixedMoveAxis_Tpl =
            v8::FunctionTemplate::New(isolate, SetFixedMoveAxis, v8::Local<v8::Value>(), SetFixedMoveAxis_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setFixedMoveAxis", v8::String::kInternalizedString), SetFixedMoveAxis_Tpl);
        v8::Local<v8::Signature> SetZoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetZoom_Tpl =
            v8::FunctionTemplate::New(isolate, SetZoom, v8::Local<v8::Value>(), SetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setZoom", v8::String::kInternalizedString), SetZoom_Tpl);
        v8::Local<v8::Signature> GetZoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetZoom_Tpl =
            v8::FunctionTemplate::New(isolate, GetZoom, v8::Local<v8::Value>(), GetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getZoom", v8::String::kInternalizedString), GetZoom_Tpl);
        v8::Local<v8::Signature> ZoomTo_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> ZoomTo_Tpl =
            v8::FunctionTemplate::New(isolate, ZoomTo, v8::Local<v8::Value>(), ZoomTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "zoomTo", v8::String::kInternalizedString), ZoomTo_Tpl);
        v8::Local<v8::Signature> Zoom_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> Zoom_Tpl =
            v8::FunctionTemplate::New(isolate, Zoom, v8::Local<v8::Value>(), Zoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "zoom", v8::String::kInternalizedString), Zoom_Tpl);
        v8::Local<v8::Signature> LayerToPortPoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortPoint_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortPoint, v8::Local<v8::Value>(), LayerToPortPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortPoint", v8::String::kInternalizedString), LayerToPortPoint_Tpl);
        v8::Local<v8::Signature> LayerToPortOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortOffset_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortOffset, v8::Local<v8::Value>(), LayerToPortOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortOffset", v8::String::kInternalizedString), LayerToPortOffset_Tpl);
        v8::Local<v8::Signature> LayerToPortVector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortVector_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortVector, v8::Local<v8::Value>(), LayerToPortVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortVector", v8::String::kInternalizedString), LayerToPortVector_Tpl);
        v8::Local<v8::Signature> LayerToPortRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortRect_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortRect, v8::Local<v8::Value>(), LayerToPortRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortRect", v8::String::kInternalizedString), LayerToPortRect_Tpl);
        v8::Local<v8::Signature> LayerToPortQuad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LayerToPortQuad_Tpl =
            v8::FunctionTemplate::New(isolate, LayerToPortQuad, v8::Local<v8::Value>(), LayerToPortQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "layerToPortQuad", v8::String::kInternalizedString), LayerToPortQuad_Tpl);
        v8::Local<v8::Signature> PortToLayerPoint_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerPoint_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerPoint, v8::Local<v8::Value>(), PortToLayerPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerPoint", v8::String::kInternalizedString), PortToLayerPoint_Tpl);
        v8::Local<v8::Signature> PortToLayerOffset_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerOffset_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerOffset, v8::Local<v8::Value>(), PortToLayerOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerOffset", v8::String::kInternalizedString), PortToLayerOffset_Tpl);
        v8::Local<v8::Signature> PortToLayerVector_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerVector_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerVector, v8::Local<v8::Value>(), PortToLayerVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerVector", v8::String::kInternalizedString), PortToLayerVector_Tpl);
        v8::Local<v8::Signature> PortToLayerRect_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerRect_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerRect, v8::Local<v8::Value>(), PortToLayerRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerRect", v8::String::kInternalizedString), PortToLayerRect_Tpl);
        v8::Local<v8::Signature> PortToLayerQuad_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> PortToLayerQuad_Tpl =
            v8::FunctionTemplate::New(isolate, PortToLayerQuad, v8::Local<v8::Value>(), PortToLayerQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "portToLayerQuad", v8::String::kInternalizedString), PortToLayerQuad_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> SetGravity_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetGravity_Tpl =
            v8::FunctionTemplate::New(isolate, SetGravity, v8::Local<v8::Value>(), SetGravity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setGravity", v8::String::kInternalizedString), SetGravity_Tpl);
        v8::Local<v8::Signature> SetUseChipmunkPhysics_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetUseChipmunkPhysics_Tpl =
            v8::FunctionTemplate::New(isolate, SetUseChipmunkPhysics, v8::Local<v8::Value>(), SetUseChipmunkPhysics_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setUseChipmunkPhysics", v8::String::kInternalizedString), SetUseChipmunkPhysics_Tpl);
        v8::Local<v8::Signature> SetStaticLayer_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetStaticLayer_Tpl =
            v8::FunctionTemplate::New(isolate, SetStaticLayer, v8::Local<v8::Value>(), SetStaticLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setStaticLayer", v8::String::kInternalizedString), SetStaticLayer_Tpl);
        v8::Local<v8::Signature> SetKeepGravityDownward_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetKeepGravityDownward_Tpl =
            v8::FunctionTemplate::New(isolate, SetKeepGravityDownward, v8::Local<v8::Value>(), SetKeepGravityDownward_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setKeepGravityDownward", v8::String::kInternalizedString), SetKeepGravityDownward_Tpl);
        v8::Local<v8::Signature> SetDamping_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetDamping_Tpl =
            v8::FunctionTemplate::New(isolate, SetDamping, v8::Local<v8::Value>(), SetDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setDamping", v8::String::kInternalizedString), SetDamping_Tpl);
        v8::Local<v8::Signature> GetSpace_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetSpace_Tpl =
            v8::FunctionTemplate::New(isolate, GetSpace, v8::Local<v8::Value>(), GetSpace_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getSpace", v8::String::kInternalizedString), GetSpace_Tpl);
#endif
        v8::Local<v8::Signature> SetWorldSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetWorldSize_Tpl =
            v8::FunctionTemplate::New(isolate, SetWorldSize, v8::Local<v8::Value>(), SetWorldSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setWorldSize", v8::String::kInternalizedString), SetWorldSize_Tpl);
        v8::Local<v8::Signature> GetWorldSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWorldSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetWorldSize, v8::Local<v8::Value>(), GetWorldSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getWorldSize", v8::String::kInternalizedString), GetWorldSize_Tpl);
        v8::Local<v8::Signature> GetWorldBounds_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetWorldBounds_Tpl =
            v8::FunctionTemplate::New(isolate, GetWorldBounds, v8::Local<v8::Value>(), GetWorldBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getWorldBounds", v8::String::kInternalizedString), GetWorldBounds_Tpl);
        v8::Local<v8::Signature> DefineTileSet_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> DefineTileSet_Tpl =
            v8::FunctionTemplate::New(isolate, DefineTileSet, v8::Local<v8::Value>(), DefineTileSet_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "defineTileSet", v8::String::kInternalizedString), DefineTileSet_Tpl);
        v8::Local<v8::Signature> LoadMapData_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> LoadMapData_Tpl =
            v8::FunctionTemplate::New(isolate, LoadMapData, v8::Local<v8::Value>(), LoadMapData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "loadMapData", v8::String::kInternalizedString), LoadMapData_Tpl);
        v8::Local<v8::Signature> GetMapData_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetMapData_Tpl =
            v8::FunctionTemplate::New(isolate, GetMapData, v8::Local<v8::Value>(), GetMapData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getMapData", v8::String::kInternalizedString), GetMapData_Tpl);
        v8::Local<v8::Signature> GetTileSetImage_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTileSetImage_Tpl =
            v8::FunctionTemplate::New(isolate, GetTileSetImage, v8::Local<v8::Value>(), GetTileSetImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTileSetImage", v8::String::kInternalizedString), GetTileSetImage_Tpl);
        v8::Local<v8::Signature> GetTileSize_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTileSize_Tpl =
            v8::FunctionTemplate::New(isolate, GetTileSize, v8::Local<v8::Value>(), GetTileSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTileSize", v8::String::kInternalizedString), GetTileSize_Tpl);
        v8::Local<v8::Signature> GetTileTypeAt_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTileTypeAt_Tpl =
            v8::FunctionTemplate::New(isolate, GetTileTypeAt, v8::Local<v8::Value>(), GetTileTypeAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTileTypeAt", v8::String::kInternalizedString), GetTileTypeAt_Tpl);
        v8::Local<v8::Signature> GetTileTypeAndFacingAt_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> GetTileTypeAndFacingAt_Tpl =
            v8::FunctionTemplate::New(isolate, GetTileTypeAndFacingAt, v8::Local<v8::Value>(), GetTileTypeAndFacingAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "getTileTypeAndFacingAt", v8::String::kInternalizedString), GetTileTypeAndFacingAt_Tpl);
        v8::Local<v8::Signature> SetTileTypeAt_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> SetTileTypeAt_Tpl =
            v8::FunctionTemplate::New(isolate, SetTileTypeAt, v8::Local<v8::Value>(), SetTileTypeAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "setTileTypeAt", v8::String::kInternalizedString), SetTileTypeAt_Tpl);
        v8::Local<v8::Signature> CheckCollision_Sig = v8::Signature::New(isolate, t);
        v8::Local<v8::FunctionTemplate> CheckCollision_Tpl =
            v8::FunctionTemplate::New(isolate, CheckCollision, v8::Local<v8::Value>(), CheckCollision_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewFromUtf8(isolate, "checkCollision", v8::String::kInternalizedString), CheckCollision_Tpl);
        target->Set(v8::String::NewFromUtf8(isolate, "TileLayer", v8::String::kInternalizedString), t->GetFunction());

    }

    void TileLayerWrap::AddHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 4465 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 4465 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 4465 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 4465 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 4465 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::RemoveHandler(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                    "If the handler is listed multiple times it will only remove it once.\n"
                    "NOTE: inType == all_events doesn't work quite like you might expect. If "
                    "you have registered a handler for multiple events, but not with all_events, "
                    "doing removeHandler(handler, all_events) will do nothing. Basically, "
                    "all_events is a special event type that matches all event types when "
                    "considering whether to invoke a handler or not.\n"
                    "It is safe to call remove handler from within an event handler's handleEvent() call."
                    " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") ); return;
            };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Clear(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "remove all handlers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clear();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::BlockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                    "Events that are blocked are NOT cached for later, they are just dropped."
                    " \\param inEventType the type of event to block") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::UnblockEvent(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            {
                args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                    " \\param inEventType the type of event to unblock") ); return;
            };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, theLocation) ); return; };
    }

    void TileLayerWrap::SetLocation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "([object Point] inLocation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(isolate, args[1 -1]);

        self->setLocation(theLocation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpeed = self->getSpeed();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpeed) ); return; };
    }

    void TileLayerWrap::SetSpeed(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inSpeed)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theWidth = self->getWidth();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theWidth) ); return; };
    }

    void TileLayerWrap::SetWidth(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inWidth)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theHeight = self->getHeight();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theHeight) ); return; };
    }

    void TileLayerWrap::SetHeight(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inHeight)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theRotation = self->getRotation();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theRotation) ); return; };
    }

    void TileLayerWrap::SetRotation(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inRotation)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, theCenterOffset) ); return; };
    }

    void TileLayerWrap::SetCenterOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "([object Offset] inCenterOffset)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(isolate, args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpin = self->getSpin();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpin) ); return; };
    }

    void TileLayerWrap::SetSpin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inSpin)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMass = self->getMass();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMass) ); return; };
    }

    void TileLayerWrap::SetMass(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inMass)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theMoveFriction) ); return; };
    }

    void TileLayerWrap::SetMoveFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inMoveFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSpinFriction) ); return; };
    }

    void TileLayerWrap::SetSpinFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inSpinFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        { args.GetReturnValue().Set( v8::Number::New(isolate, theSizeFriction) ); return; };
    }

    void TileLayerWrap::SetSizeFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object TileLayer]" " function" "(number inSizeFriction)") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetBoundingBox(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void TileLayerWrap::GetRotatedBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void TileLayerWrap::Move(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            delta = v8_ValueToOffset(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(isolate, args[0]))
        {
            where = v8_ValueToPoint(isolate, args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetVelocityInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number speed, number direction)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetMovementDirectionInRadians(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        { args.GetReturnValue().Set( v8::Number::New(isolate, dir) ); return; };
    }

    void TileLayerWrap::SetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "({[object Vector] deltaPerSec|number deltaXPerSec, number deltaYPerSec})" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(isolate, args[0]))
        {
            deltaPerSec = v8_ValueToVector(isolate, args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::GetVelocity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "()") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, theVelocity) ); return; };
    }

    void TileLayerWrap::StopMoving(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopMoving();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Accelerate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::AccelerateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number width, number height)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::Grow(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Stretch(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StartGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number amountPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StopGrowing(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopGrowing();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StartStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StopStretching(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopStretching();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Resize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::ResizeTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? duration_Instantaneous : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Rotate(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::RotateTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StopSpinning(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopSpinning();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::ChangeCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::ChangeCenterTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(isolate, args[0]))
        {
            offset = v8_ValueToOffset(isolate, args[0]);
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration_2"")");
            long msDuration_2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration_2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 3, "a number (""msDuration_3"")");
            long msDuration_3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                v8_ThrowArgTypeException(isolate, 4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration_3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Wait(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "([number int] msDuration)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::SetFriction(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Animated]" " function" "(number frictionCoefficient)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::ApplyForce(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(isolate, args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::ApplyTorque(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StopAllForces(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAllForces();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::AddAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        self->mAnimatedScriptObj.Reset(isolate, args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< 4466 << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< 4466 << " - NOT JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<") : " << (args[0].IsEmpty() ? "empty" : args[0]->IsArray() ? "array" : args[0]->IsFunction() ? "function" : args[0]->IsStringObject() ? "string (object)" : args[0]->IsString() ? "string" : args[0]->IsNull() ? "null" : args[0]->IsUndefined() ? "undefined" : args[0]->IsNumberObject() ? "number (object)" : args[0]->IsNumber() ? "number" : args[0]->IsBoolean() ? "boolean" : args[0]->IsDate() ? "date" : args[0]->IsRegExp() ? "regexp" : args[0]->IsNativeError() ? "error" : args[0]->IsObject() ? "object" : "unknown") << "\n";
        }
        else
        {
            v8::Local<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Local<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap< IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< 4466 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of C++ ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< 4466 << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getCppObject());
                    std::cout << __func__<<":"<< 4466 << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps C++ ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::RemoveAnimationHelper(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object IAnimationHelper] helper)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::ClearAnimationHelpers(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->clearAnimationHelpers();
        args.GetReturnValue().SetUndefined();
    }

#ifndef PDG_NO_GUI

    void TileLayerWrap::GetSpritePort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Port]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Port* port = self->getSpritePort();
        if (!port) args.GetReturnValue().SetNull();
        if (port->mPortScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( PortWrap::NewFromCpp(isolate, port) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, port->mPortScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void TileLayerWrap::SetSpritePort(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Port] port)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, port, Port);
        self->setSpritePort(port);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetOrigin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Point] origin)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point origin = v8_ValueToPoint(isolate, args[1 -1]);
        self->setOrigin(origin);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetOrigin(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()" " - " "get the point in the layer that is drawn at 0,0 in the port") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Point p = self->getOrigin();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, p) ); return; };
    }

    void TileLayerWrap::SetAutoCenter(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean autoCenter = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""autoCenter"")");
        bool autoCenter = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setAutoCenter(autoCenter);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetFixedMoveAxis(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean fixedAxis = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""fixedAxis"")");
        bool fixedAxis = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setFixedMoveAxis(fixedAxis);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetZoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number zoomLevel)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        self->setZoom(zoomLevel);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetZoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "get the current zoom factor") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        float zoom = self->getZoom();
        { args.GetReturnValue().Set( v8::Number::New(isolate, zoom) ); return; };
    }

    void TileLayerWrap::ZoomTo(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number zoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(isolate, args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoomTo(zoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoomTo(zoomLevel, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Zoom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number deltaZoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""deltaZoomLevel"")");
        double deltaZoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(isolate, args[4 -1]))
            v8_ThrowArgTypeException(isolate, 4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(isolate, args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(isolate, args[5 -1]))
            v8_ThrowArgTypeException(isolate, 5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(isolate, args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoom(deltaZoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoom(deltaZoomLevel, msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::LayerToPortPoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([object Point] p)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
        Point out = self->layerToPort(p);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, out) ); return; };
    }

    void TileLayerWrap::LayerToPortOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "([object Offset] o)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(isolate, args[1 -1]);
        Offset out = self->layerToPort(o);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, out) ); return; };
    }

    void TileLayerWrap::LayerToPortVector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "([object Vector] v)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(isolate, args[1 -1]);
        Vector out = self->layerToPort(v);
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, out) ); return; };
    }

    void TileLayerWrap::LayerToPortRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "([object Rect] r)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(isolate, args[1 -1]);
        RotatedRect out = self->layerToPort(r);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, out) ); return; };
    }

    void TileLayerWrap::LayerToPortQuad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Quad]" " function" "([object Quad] q)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(isolate, args[1 -1]);
        Quad out = self->layerToPort(q);
        { args.GetReturnValue().Set( v8_MakeJavascriptQuad(isolate, out) ); return; };
    }

    void TileLayerWrap::PortToLayerPoint(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "([object Point] p)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsPoint(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(isolate, args[1 -1]);
        Point out = self->portToLayer(p);
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, out) ); return; };
    }

    void TileLayerWrap::PortToLayerOffset(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Offset]" " function" "([object Offset] o)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsOffset(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(isolate, args[1 -1]);
        Offset out = self->portToLayer(o);
        { args.GetReturnValue().Set( v8_MakeJavascriptOffset(isolate, out) ); return; };
    }

    void TileLayerWrap::PortToLayerVector(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Vector]" " function" "([object Vector] v)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsVector(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(isolate, args[1 -1]);
        Vector out = self->portToLayer(v);
        { args.GetReturnValue().Set( v8_MakeJavascriptVector(isolate, out) ); return; };
    }

    void TileLayerWrap::PortToLayerRect(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object RotatedRect]" " function" "([object Rect] r)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsRotatedRect(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(isolate, args[1 -1]);
        RotatedRect out = self->portToLayer(r);
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, out) ); return; };
    }

    void TileLayerWrap::PortToLayerQuad(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Quad]" " function" "([object Quad] q)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!v8_ValueIsQuad(isolate, args[1 -1]))
            v8_ThrowArgTypeException(isolate, 1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(isolate, args[1 -1]);
        Quad out = self->portToLayer(q);
        { args.GetReturnValue().Set( v8_MakeJavascriptQuad(isolate, out) ); return; };
    }
#endif

    void TileLayerWrap::SetSerializationFlags(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object SpriteLayer]" " function" "([number uint] flags)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""flags"")");
        unsigned long flags = args[1 -1]->Uint32Value();
        self->setSerializationFlags(flags);
        { args.GetReturnValue().Set( args.This() ); return; };
    }

    void TileLayerWrap::StartAnimations(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->startAnimations();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::StopAnimations(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->stopAnimations();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Hide(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->hide();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::Show(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->show();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::IsHidden(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool hidden = self->isHidden();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, hidden) ); return; };
    }

    void TileLayerWrap::FadeIn(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::FadeOut(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveBehind(layer);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveInFrontOf(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveInFrontOf(layer);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveToFront(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "move this layer in front of all other layers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToFront();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveToBack(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "move this layer behind all other layers") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->moveToBack();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::MoveWith(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] layer, number moveRatio = 1.0, number zoomRatio = 1.0 )" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, layer, SpriteLayer);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""moveRatio"")");
        double moveRatio = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""zoomRatio"")");
        double zoomRatio = (args.Length()<3) ? 1.0f : args[3 -1]->NumberValue();;
        self->moveWith(layer, moveRatio, zoomRatio);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::IsSpriteBehind(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Sprite] sprite, [object Sprite] otherSprite)" " - " "") ); return; };
        };
        if (args.Length() != 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        REQUIRE_CPP_OBJECT_ARG(2, otherSprite, Sprite);
        bool behind = self->isSpriteBehind(sprite, otherSprite);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, behind) ); return; };
    }

    void TileLayerWrap::GetZOrder(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number int]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        int zorder = self->getZOrder();
        { args.GetReturnValue().Set( v8::Integer::New(isolate, zorder) ); return; };
    }

    void TileLayerWrap::GetSpriteZOrder(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[number int]" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        int zorder = self->getSpriteZOrder(sprite);
        { args.GetReturnValue().Set( v8::Integer::New(isolate, zorder) ); return; };
    }

    void TileLayerWrap::FindSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] id)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        Sprite* sprite = self->findSprite(id);
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void TileLayerWrap::GetNthSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "([number int] index)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""index"")");
        long index = args[1 -1]->Int32Value();
        Sprite* sprite = self->getNthSprite(index);
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void TileLayerWrap::HasSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "([object Sprite] sprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, sprite, Sprite);
        bool found = self->hasSprite(sprite);
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, found) ); return; };
    }

    void TileLayerWrap::AddSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Sprite] newSprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, newSprite, Sprite);
        self->addSprite(newSprite);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::RemoveSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object Sprite] oldSprite)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, oldSprite, Sprite);
        self->removeSprite(oldSprite);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::RemoveAllSprites(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->removeAllSprites();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::EnableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->enableCollisions();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::DisableCollisions(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        self->disableCollisions();
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::EnableCollisionsWithLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->enableCollisionsWithLayer(otherLayer);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::DisableCollisionsWithLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        REQUIRE_CPP_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->disableCollisionsWithLayer(otherLayer);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::CreateSprite(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Sprite]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Sprite* sprite = self->createSprite();
        if (!sprite) args.GetReturnValue().SetNull();
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( SpriteWrap::NewFromCpp(isolate, sprite) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, sprite->mSpriteScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    void TileLayerWrap::SetKeepGravityDownward(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean keepItDownward = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setKeepGravityDownward(keepItDownward);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetGravity(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number gravity, boolean keepItDownward = true)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""gravity"")");
        double gravity = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 2, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
        self->setGravity(gravity, keepItDownward);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetDamping(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(number damping)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""damping"")");
        double damping = args[1 -1]->NumberValue();
        self->setDamping(damping);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetStaticLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean isStatic = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""isStatic"")");
        bool isStatic = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setStaticLayer(isStatic);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::SetUseChipmunkPhysics(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(boolean useIt = true)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""useIt"")");
        bool useIt = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setUseChipmunkPhysics(useIt);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetSpace(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object CpSpace]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        cpSpace* space = self->getSpace();
        if (!space) args.GetReturnValue().SetNull();
        { args.GetReturnValue().Set( cpSpaceWrap::NewFromCpp(isolate, space) ); return; };
        ;
    }
#endif

    void TileLayerWrap::SetWorldSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] width, [number int] height, boolean repeatingX = false, boolean repeatingY = false)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""width"")");
        long width = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""height"")");
        long height = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 3, "a boolean (""repeatingX"")");
        bool repeatingX = (args.Length()<3) ? false : args[3 -1]->BooleanValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 4, "a boolean (""repeatingY"")");
        bool repeatingY = (args.Length()<4) ? false : args[4 -1]->BooleanValue();;
        self->setWorldSize(width, height, repeatingX, repeatingY);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetWorldSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Rect r = self->getWorldSize();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void TileLayerWrap::GetWorldBounds(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Rect]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Rect r = self->getWorldBounds();
        { args.GetReturnValue().Set( v8_MakeJavascriptRect(isolate, r) ); return; };
    }

    void TileLayerWrap::GetTileTypeAt(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([number int] x, [number int] y)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        uint8 tileType;
        tileType = self->getTileTypeAt(x, y);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, tileType) ); return; };
    }

    void TileLayerWrap::GetTileTypeAndFacingAt(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "object" " function" "([number int] x, [number int] y)" " - " "") ); return; };
        };
        if (args.Length() < 2)
            v8_ThrowArgCountException(isolate, args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        uint8 tileType;
        TileLayer::TFacing facing;
        tileType = self->getTileTypeAt(x, y, &facing);
        if (self->mUseFacing || self->mUseFlipping)
        {
            if (self->mUseFlipping && (!self->mFlipHoriz || !self->mFlipVert))
            {
                tileType &= 0x7f;
            }
            else
            {
                tileType &= 0x3f;
            }
        }
        v8::Local<v8::Object> tileInfo = v8_ObjectCreateEmpty(isolate, 0);
        tileInfo->Set(v8::String::NewFromUtf8(isolate, "tileType", v8::String::kInternalizedString), v8::Integer::NewFromUnsigned(isolate, tileType));
        tileInfo->Set(v8::String::NewFromUtf8(isolate, "facing", v8::String::kInternalizedString), v8::Integer::NewFromUnsigned(isolate, facing));
        { args.GetReturnValue().Set( tileInfo ); return; };
    }

    void TileLayerWrap::DefineTileSet(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] tileWidth, [number int] tileHeight, [object Image] tiles, boolean hasTransparency = true, boolean flipTiles = false)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""tileWidth"")");
        long tileWidth = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""tileHeight"")");
        long tileHeight = args[2 -1]->Int32Value();
        REQUIRE_CPP_OBJECT_ARG(3, tiles, Image);
        if (args.Length() >= 4 && !args[4 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 4, "a boolean (""hasTransparency"")");
        bool hasTransparency = (args.Length()<4) ? true : args[4 -1]->BooleanValue();;
        if (args.Length() >= 5 && !args[5 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 5, "a boolean (""flipTiles"")");
        bool flipTiles = (args.Length()<5) ? false : args[5 -1]->BooleanValue();;
        self->defineTileSet(tileWidth, tileHeight, tiles, hasTransparency, flipTiles);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::LoadMapData(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "({[string Binary]|[object MemBlock]} data, [number int] mapWidth = 0, [number int] mapHeight = 0, [number int] dstX, [number int] dstY)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""mapWidth"")");
        long mapWidth = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""mapHeight"")");
        long mapHeight = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""dstX"")");
        long dstX = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 5, "a number (""dstY"")");
        long dstY = (args.Length()<5) ? 0 : args[5 -1]->Int32Value();;
        if (mapWidth > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 2 (mapWidth) is larger than world width";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if ((mapWidth + dstX) > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "mapWidth + dstX is larger than world width";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (mapHeight > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 3 (mapHeight) is larger than world height";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if ((mapHeight + dstY) > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "mapHeight + dstY is larger than world height";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (!args[0]->IsString() && !((!args[0]->IsObject()) ? false :
            (jswrap::ObjectWrap::Unwrap< MemBlockWrap>(args[0]->ToObject()) != 0) ? true :
            (args[0]->ToObject()->GetPrototype().IsEmpty()) ? false :
            (jswrap::ObjectWrap::Unwrap< MemBlockWrap>(args[0]->ToObject()->GetPrototype()->ToObject()) != 0)))
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (data) must be either a binary string or an object of type MemBlock";
            isolate->ThrowException( v8::Exception::TypeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            if (bytes < ((size_t)mapWidth * (size_t)mapHeight))
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 (data) is insufficient, please check mapWidth and mapHeight against data size";
                isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
            }
            self->loadMapData(ptr, mapWidth, mapHeight, dstX, dstY);
            std::free(ptr);
        }
        else
        {
            REQUIRE_CPP_OBJECT_ARG(1, memBlock, MemBlock);
            if (memBlock->bytes < ((size_t)mapWidth * (size_t)mapHeight))
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 (data) is insufficient, please check mapWidth and mapHeight against data size";
                isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
            }
            self->loadMapData((uint8*)memBlock->ptr, mapWidth, mapHeight, dstX, dstY);
        }
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::GetMapData(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object MemBlock]" " function" "([number int] mapWidth = 0, [number int] mapHeight = 0, [number int] srcX, [number int] srcY)" " - " "") ); return; };
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""mapWidth"")");
        long mapWidth = (args.Length()<1) ? self->mWorldWidth : args[1 -1]->Int32Value();;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""mapHeight"")");
        long mapHeight = (args.Length()<2) ? self->mWorldHeight : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""srcX"")");
        long srcX = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""srcY"")");
        long srcY = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        if (mapWidth > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mapWidth) is larger than world width";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if ((mapWidth + srcX) > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "mapWidth + srcX is larger than world width";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if (mapHeight > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 2 (mapHeight) is larger than world height";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        if ((mapHeight + srcY) > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "mapHeight + srcY is larger than world height";
            isolate->ThrowException( v8::Exception::RangeError( v8::String::NewFromUtf8(isolate, excpt_.str().c_str())));
        }
        const uint8* dataPtr = self->getMapData(mapWidth, mapHeight, srcX, srcY);
        size_t bufferSize = mapWidth * mapHeight;
        uint8* ptr = (uint8*) std::malloc(bufferSize);
        std::memcpy(ptr, dataPtr, bufferSize);
        MemBlock* memBlock = new MemBlock((char*)ptr, bufferSize, true);
        if (!memBlock) args.GetReturnValue().SetNull();
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( MemBlockWrap::NewFromCpp(isolate, memBlock) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, memBlock->mMemBlockScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void TileLayerWrap::GetTileSetImage(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Image]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Image* tiles = self->getTileSetImage();
        if (!tiles) args.GetReturnValue().SetNull();
        if (tiles->mImageScriptObj.IsEmpty())
        {
            { args.GetReturnValue().Set( ImageWrap::NewFromCpp(isolate, tiles) ); return; };
        }
        else
        {
            v8::Local<v8::Object> obj__ = v8::Local<v8::Object>::New(isolate, tiles->mImageScriptObj );
            { args.GetReturnValue().Set( obj__ ); return; };
        };
    }

    void TileLayerWrap::GetTileSize(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "[object Point]" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        Point size = self->getTileSize();
        { args.GetReturnValue().Set( v8_MakeJavascriptPoint(isolate, size) ); return; };
    }

    void TileLayerWrap::SetTileTypeAt(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number int] x, [number int] y, [number uint] t, [number uint] facing = facing_Ignore)" " - " "") ); return; };
        };
        if (args.Length() < 3)
            v8_ThrowArgCountException(isolate, args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        if (!args[3 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 3, "a number (""t"")");
        unsigned long t = args[3 -1]->Uint32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 4, "a number (""facing"")");
        unsigned long facing = (args.Length()<4) ? (uint32) TileLayer::facing_Ignore : args[4 -1]->Uint32Value();;
        self->setTileTypeAt(x, y, t, (TileLayer::TFacing) facing);
        args.GetReturnValue().SetUndefined();
    }

    void TileLayerWrap::CheckCollision(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->cppPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "([object Sprite] movingSprite, [number uint] alphaThreshold = 128, boolean shortCircuit = true)" " - " "") ); return; };
        };
        if (args.Length() < 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1, true);
        REQUIRE_CPP_OBJECT_ARG(1, movingSprite, Sprite);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 2, "a number (""alphaThreshold"")");
        unsigned long alphaThreshold = (args.Length()<2) ? 128 : args[2 -1]->Uint32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 3, "a boolean (""shortCircuit"")");
        bool shortCircuit = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        uint32 overlapPx = self->checkCollision(movingSprite, alphaThreshold, shortCircuit);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, overlapPx) ); return; };
    }

    void CleanupTileLayerScriptObject(v8::Persistent<v8::Object> &obj) { }

    TileLayer* New_TileLayer(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        if (s_TileLayer_InNewFromCpp) return 0;
        v8::Isolate* isolate = args.GetIsolate();
        return 0;
    }

    ScriptSerializable::ScriptSerializable()
    {
    }

    ScriptEventHandler::ScriptEventHandler()
    {
    }

    ScriptAnimationHelper::ScriptAnimationHelper()
    {
    }

    ScriptSpriteCollideHelper::ScriptSpriteCollideHelper()
    {
    }

#ifndef PDG_NO_GUI

    ScriptSpriteDrawHelper::ScriptSpriteDrawHelper()
    {
    }
#endif

    void Rand(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, OS::rand()) ); return; };
    }
    void GameCriticalRandom(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "number" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        { args.GetReturnValue().Set( v8::Integer::NewFromUnsigned(isolate, OS::gameCriticalRandom()) ); return; };
    }
    void Srand(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "([number uint] seed)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            v8_ThrowArgTypeException(isolate, 1, "a number (""seed"")");
        unsigned long seed = args[1 -1]->Uint32Value();
        OS::srand( seed );
        args.GetReturnValue().SetUndefined();
    }
    void SetSerializationDebugMode(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "(bool debugMode)" " - " "") ); return; };
        };
        if (args.Length() != 1)
            v8_ThrowArgCountException(isolate, args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            v8_ThrowArgTypeException(isolate, 1, "a boolean (""debugMode"")");
        bool debugMode = args[1 -1]->BooleanValue();
        ISerializer::s_DebugMode = debugMode;
        args.GetReturnValue().SetUndefined();
    }

    bool Initializer::allowHorizontalOrientation() throw() { return true; }
    bool Initializer::allowVerticalOrientation() throw() { return true; }
    const char* Initializer::getAppName(bool haveMainResourceFile) throw() { return "pdg"; }
    const char* Initializer::getMainResourceFileName() throw() {return NULL;}
    bool Initializer::installGlobalHandlers() throw() {return true;}
    bool Initializer::getGraphicsEnvironmentDimensions(Rect maxWindowDim, Rect maxFullScreenDim,
        long& ioWidth, long& ioHeight, uint8& ioDepth) throw()
    {
        ioWidth = 640;
        ioHeight = 480;
        ioDepth = 32;
        return false;
    }

    void Idle(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg_LibIdle();
        args.GetReturnValue().SetUndefined();
    }

    void Run(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg_LibRun();
        args.GetReturnValue().SetUndefined();
    }

    void Quit(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "undefined" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        pdg_LibQuit();
        args.GetReturnValue().SetUndefined();
    }

    void IsQuitting(const v8::FunctionCallbackInfo<v8::Value>& args)
    {
        v8::Isolate* isolate = args.GetIsolate();
        if (args.Length() == 1 && args[0]->IsNull())
        {
            { args.GetReturnValue().Set( v8::String::NewFromUtf8(isolate, "boolean" " function" "()" " - " "") ); return; };
        };
        if (args.Length() != 0)
            v8_ThrowArgCountException(isolate, args.Length(), 0);
        bool isQuitting = pdg_LibIsQuitting();
        { args.GetReturnValue().Set( v8::Boolean::New(isolate, isQuitting) ); return; };
    }

}
